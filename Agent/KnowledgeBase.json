{
  "type": "callHierarchy",
  "tree": [
    {
      "name": "RcMgrSetInputBlkPhx",
      "kind": 11,
      "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/PHX/RcMgrPhx.c",
      "documentation": "/**\n * RcMgrSetInputBlkPhx\n *\n * @brief Input block API that assigns host memory block to the IP.\n *\n * @param   SilContext          A context structure through which host firmware defined data\n *                              can be passed to openSIL. The host firmware is responsible\n *                              for initializing the SIL_CONTEXT structure.\n */",
      "definition": "SIL_STATUS\r\nRcMgrSetInputBlkPhx (\r\n  SIL_CONTEXT  *SilContext\r\n  )",
      "implementation": "SIL_STATUS\r\nRcMgrSetInputBlkPhx (\r\n  SIL_CONTEXT  *SilContext\r\n  )\r\n{\r\n  void *InfoBlkPtr;\r\n\r\n  InfoBlkPtr = SilCreateInfoBlock(SilContext,\r\n    SilId_RcManager,\r\n    sizeof (DFX_RCMGR_INPUT_BLK),\r\n    RCMGR_INIT_INSTANCE,\r\n    RCMGR_INIT_MAJOR_REV,\r\n    RCMGR_INIT_MINOR_REV\r\n    );\r\n\r\n  if (InfoBlkPtr == NULL) {\r\n    return SilAborted;\r\n  }\r\n\r\n  return SilPass;\r\n}",
      "range": [
        { "line": 37, "character": 0 },
        { "line": 57, "character": 1 }
      ],
      "selectionRange": [
        { "line": 38, "character": 0 },
        { "line": 38, "character": 19 }
      ],
      "dependencies": {
        "callTree": [
          {
            "name": "SIL_STATUS",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
            "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
            "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
            "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
            "range": [
              { "line": 49, "character": 0 },
              { "line": 74, "character": 13 }
            ],
            "selectionRange": [
              { "line": 74, "character": 2 },
              { "line": 74, "character": 12 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SIL_CONTEXT",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
            "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
            "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
            "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
            "range": [
              { "line": 131, "character": 0 },
              { "line": 135, "character": 14 }
            ],
            "selectionRange": [
              { "line": 135, "character": 2 },
              { "line": 135, "character": 13 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "DFX_RCMGR_INPUT_BLK",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
            "documentation": "",
            "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
            "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
            "range": [
              { "line": 124, "character": 0 },
              { "line": 143, "character": 22 }
            ],
            "selectionRange": [
              { "line": 143, "character": 2 },
              { "line": 143, "character": 21 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "RCMGR_INIT_INSTANCE",
            "kind": 13,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
            "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
            "definition": "#define RCMGR_INIT_INSTANCE    0",
            "implementation": "#define RCMGR_INIT_INSTANCE    0",
            "range": [
              { "line": 16, "character": 0 },
              { "line": 16, "character": 32 }
            ],
            "selectionRange": [
              { "line": 16, "character": 8 },
              { "line": 16, "character": 27 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "RCMGR_INIT_MAJOR_REV",
            "kind": 13,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
            "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
            "definition": "#define RCMGR_INIT_MAJOR_REV   0",
            "implementation": "#define RCMGR_INIT_MAJOR_REV   0",
            "range": [
              { "line": 14, "character": 0 },
              { "line": 14, "character": 32 }
            ],
            "selectionRange": [
              { "line": 14, "character": 8 },
              { "line": 14, "character": 28 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "RCMGR_INIT_MINOR_REV",
            "kind": 13,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
            "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
            "definition": "#define RCMGR_INIT_MINOR_REV   1",
            "implementation": "#define RCMGR_INIT_MINOR_REV   1",
            "range": [
              { "line": 15, "character": 0 },
              { "line": 15, "character": 32 }
            ],
            "selectionRange": [
              { "line": 15, "character": 8 },
              { "line": 15, "character": 28 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SilCreateInfoBlock",
            "kind": 11,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtxSIMFakeLib/UtxSIMFakeLib.c",
            "documentation": "/**\n * SilCreateInfoBlock (Fake)\n *\n * @brief Create an Info Block\n *\n * @details This is a fake implementation of SilCreateInfoBlock from xSIM.c\n *\n * This is a mock function\n * @param SilContext A context structure through which host firmware defined data\n *                   can be passed to openSIL. The host firmware is responsible\n *                   for initializing the SIL_CONTEXT structure.\n * @param BlockTag - IP block unique identifier\n * @param BlockSize - size of the requested block\n * @param Block_Instance - Instance of block using this ID\n * @param Block_MajorRev - Revision of the IP data structure used\n * @param Block_MinorRev  - Revision (minor) of the IP data struct used.\n * @return pointer to the IP data segment of the assigned memory space.\n *\n */",
            "definition": "void *\r\nSilCreateInfoBlock (\r\n  SIL_CONTEXT     *SilContext,\r\n  uint32_t        BlockTag,\r\n  size_t          BlockSize,\r\n  uint16_t        Block_Instance,\r\n  uint8_t         Block_MajorRev,\r\n  uint8_t         Block_MinorRev\r\n  )",
            "implementation": "void *\r\nSilCreateInfoBlock (\r\n  SIL_CONTEXT     *SilContext,\r\n  uint32_t        BlockTag,\r\n  size_t          BlockSize,\r\n  uint16_t        Block_Instance,\r\n  uint8_t         Block_MajorRev,\r\n  uint8_t         Block_MinorRev\r\n  )\r\n{\r\n  size_t                RequestSize;\r\n  SIL_INFO_BLOCK_HEADER *Header = NULL;\r\n\r\n  assert_true (BlockSize <= MAX_INFO_BLOCK_SIZE);\r\n\r\n  Header = (SIL_INFO_BLOCK_HEADER *)TempInfoBlock;\r\n  RequestSize = BlockSize + sizeof (SIL_INFO_BLOCK_HEADER);\r\n\r\n  // Fill the Info Block\r\n  Header->Id        = BlockTag;\r\n  Header->InfoBlockDataSize = (uint32_t)(RequestSize & 0xFFFFFFFF);\r\n  Header->Instance  = Block_Instance;\r\n  Header->RevMajor  = Block_MajorRev;\r\n  Header->RevMinor  = Block_MinorRev;\r\n  return (void *)Header->InfoBlockData;\r\n}",
            "range": [
              { "line": 37, "character": 0 },
              { "line": 62, "character": 1 }
            ],
            "selectionRange": [
              { "line": 38, "character": 0 },
              { "line": 38, "character": 18 }
            ],
            "dependencies": {
              "callTree": [
                {
                  "name": "SIL_CONTEXT",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                  "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "range": [
                    { "line": 131, "character": 0 },
                    { "line": 135, "character": 14 }
                  ],
                  "selectionRange": [
                    { "line": 135, "character": 2 },
                    { "line": 135, "character": 13 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_CONTEXT",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSim-api.h",
                  "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                  "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "range": [
                    { "line": 131, "character": 0 },
                    { "line": 135, "character": 14 }
                  ],
                  "selectionRange": [
                    { "line": 135, "character": 2 },
                    { "line": 135, "character": 13 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "size_t",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/SilToUefi/stddef.h",
                  "documentation": "/**\n * @file  stddef.h\n * @brief C type definitions.\n *\n * Copyright (C) 2021 - 2024 Advanced Micro Devices, Inc. All rights reserved.\n *\n */\n\n/*\t$OpenBSD: stddef.h,v 1.14 2017/01/06 14:36:50 kettenis Exp $\t*/\n/*\t$NetBSD: stddef.h,v 1.4 1994/10/26 00:56:26 cgd Exp $\t*/\n\n/*-\n * Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n *\t@(#)stddef.h\t5.5 (Berkeley) 4/3/91\n */",
                  "definition": "typedef UINTN  size_t;",
                  "implementation": "typedef UINTN  size_t;",
                  "range": [
                    { "line": 49, "character": 0 },
                    { "line": 49, "character": 22 }
                  ],
                  "selectionRange": [
                    { "line": 49, "character": 15 },
                    { "line": 49, "character": 21 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_INFO_BLOCK_HEADER",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/** @brief Header structure for openSIL Input & Output Blocks\n *\n *  @details This header is included at the front of each block assigned. It is\n *  used to manage the space and locate the assigned blocks,\n *  see @ref SilFindStructure.\n */",
                  "definition": "typedef struct  {\r\n  uint32_t Id;                ///< Information block identifier, see @ref SIL_DATA_BLOCK_ID\r\n  uint16_t Instance;          ///< Instance # of this ID (0..N) Instance '0'\r\n                              ///<  is reserved for the top level (class level)\r\n                              ///<  and values 1..N are for the ports.\r\n  uint8_t  RevMajor;          ///< Structure Major revision number. This is\r\n                              ///<  incremented when a non-backward compatible\r\n                              ///<  change is made.\r\n  uint8_t  RevMinor;          ///< Structure Minor revision number. This is\r\n                              ///<  is incremented for every change.\r\n  uint32_t InfoBlockDataSize; ///< Information block size. This is the\r\n                              ///<  size of block assigned, including the header,\r\n                              ///<  rounded up to the next full DWORD.\r\n  uint8_t  InfoBlockData[];   ///< start of the IP input block data struct.\r\n                              ///<  Cast this point to the IP structure type to\r\n                              ///<  reference the structure elements.\r\n} SIL_INFO_BLOCK_HEADER;",
                  "implementation": "typedef struct  {\r\n  uint32_t Id;                ///< Information block identifier, see @ref SIL_DATA_BLOCK_ID\r\n  uint16_t Instance;          ///< Instance # of this ID (0..N) Instance '0'\r\n                              ///<  is reserved for the top level (class level)\r\n                              ///<  and values 1..N are for the ports.\r\n  uint8_t  RevMajor;          ///< Structure Major revision number. This is\r\n                              ///<  incremented when a non-backward compatible\r\n                              ///<  change is made.\r\n  uint8_t  RevMinor;          ///< Structure Minor revision number. This is\r\n                              ///<  is incremented for every change.\r\n  uint32_t InfoBlockDataSize; ///< Information block size. This is the\r\n                              ///<  size of block assigned, including the header,\r\n                              ///<  rounded up to the next full DWORD.\r\n  uint8_t  InfoBlockData[];   ///< start of the IP input block data struct.\r\n                              ///<  Cast this point to the IP structure type to\r\n                              ///<  reference the structure elements.\r\n} SIL_INFO_BLOCK_HEADER;",
                  "range": [
                    { "line": 82, "character": 0 },
                    { "line": 98, "character": 24 }
                  ],
                  "selectionRange": [
                    { "line": 98, "character": 2 },
                    { "line": 98, "character": 23 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_INFO_BLOCK_HEADER",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSim-api.h",
                  "documentation": "/** @brief Header structure for openSIL Input & Output Blocks\n *\n *  @details This header is included at the front of each block assigned. It is\n *  used to manage the space and locate the assigned blocks,\n *  see @ref SilFindStructure.\n */",
                  "definition": "typedef struct  {\r\n  uint32_t Id;                ///< Information block identifier, see @ref SIL_DATA_BLOCK_ID\r\n  uint16_t Instance;          ///< Instance # of this ID (0..N) Instance '0'\r\n                              ///<  is reserved for the top level (class level)\r\n                              ///<  and values 1..N are for the ports.\r\n  uint8_t  RevMajor;          ///< Structure Major revision number. This is\r\n                              ///<  incremented when a non-backward compatible\r\n                              ///<  change is made.\r\n  uint8_t  RevMinor;          ///< Structure Minor revision number. This is\r\n                              ///<  is incremented for every change.\r\n  uint32_t InfoBlockDataSize; ///< Information block size. This is the\r\n                              ///<  size of block assigned, including the header,\r\n                              ///<  rounded up to the next full DWORD.\r\n  uint8_t  InfoBlockData[];   ///< start of the IP input block data struct.\r\n                              ///<  Cast this point to the IP structure type to\r\n                              ///<  reference the structure elements.\r\n} SIL_INFO_BLOCK_HEADER;",
                  "implementation": "typedef struct  {\r\n  uint32_t Id;                ///< Information block identifier, see @ref SIL_DATA_BLOCK_ID\r\n  uint16_t Instance;          ///< Instance # of this ID (0..N) Instance '0'\r\n                              ///<  is reserved for the top level (class level)\r\n                              ///<  and values 1..N are for the ports.\r\n  uint8_t  RevMajor;          ///< Structure Major revision number. This is\r\n                              ///<  incremented when a non-backward compatible\r\n                              ///<  change is made.\r\n  uint8_t  RevMinor;          ///< Structure Minor revision number. This is\r\n                              ///<  is incremented for every change.\r\n  uint32_t InfoBlockDataSize; ///< Information block size. This is the\r\n                              ///<  size of block assigned, including the header,\r\n                              ///<  rounded up to the next full DWORD.\r\n  uint8_t  InfoBlockData[];   ///< start of the IP input block data struct.\r\n                              ///<  Cast this point to the IP structure type to\r\n                              ///<  reference the structure elements.\r\n} SIL_INFO_BLOCK_HEADER;",
                  "range": [
                    { "line": 82, "character": 0 },
                    { "line": 98, "character": 24 }
                  ],
                  "selectionRange": [
                    { "line": 98, "character": 2 },
                    { "line": 98, "character": 23 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "MAX_INFO_BLOCK_SIZE",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Include/Library/UtxSIMFakeLib.h",
                  "documentation": "/**\n * MAX_INFO_BLOCK_SIZE\n *\n * @brief An arbitrary size to allocate a build time array.\n *\n * @details This size can be increased to accommodate block sizes that exceed 64k\n */",
                  "definition": "#define MAX_INFO_BLOCK_SIZE  0x10000",
                  "implementation": "#define MAX_INFO_BLOCK_SIZE  0x10000",
                  "range": [
                    { "line": 16, "character": 0 },
                    { "line": 16, "character": 36 }
                  ],
                  "selectionRange": [
                    { "line": 16, "character": 8 },
                    { "line": 16, "character": 27 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "TempInfoBlock",
                  "kind": 12,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtxSIMFakeLib/UtxSIMFakeLib.c",
                  "documentation": "/**\n * @file UtxSIMFakeLib.c\n * @brief Defines cpu specific common operations\n *\n */",
                  "definition": "uint8_t TempInfoBlock[sizeof(SIL_INFO_BLOCK_HEADER) + MAX_INFO_BLOCK_SIZE] = {0};",
                  "implementation": "uint8_t TempInfoBlock[sizeof(SIL_INFO_BLOCK_HEADER) + MAX_INFO_BLOCK_SIZE] = {0};",
                  "range": [
                    { "line": 16, "character": 0 },
                    { "line": 16, "character": 81 }
                  ],
                  "selectionRange": [
                    { "line": 16, "character": 8 },
                    { "line": 16, "character": 21 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SilCreateInfoBlock",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtxSIMFakeLib/UtxSIMFakeLib.c",
                  "documentation": "/**\n * SilCreateInfoBlock (Fake)\n *\n * @brief Create an Info Block\n *\n * @details This is a fake implementation of SilCreateInfoBlock from xSIM.c\n *\n * This is a mock function\n * @param SilContext A context structure through which host firmware defined data\n *                   can be passed to openSIL. The host firmware is responsible\n *                   for initializing the SIL_CONTEXT structure.\n * @param BlockTag - IP block unique identifier\n * @param BlockSize - size of the requested block\n * @param Block_Instance - Instance of block using this ID\n * @param Block_MajorRev - Revision of the IP data structure used\n * @param Block_MinorRev  - Revision (minor) of the IP data struct used.\n * @return pointer to the IP data segment of the assigned memory space.\n *\n */",
                  "definition": "void *\r\nSilCreateInfoBlock (\r\n  SIL_CONTEXT     *SilContext,\r\n  uint32_t        BlockTag,\r\n  size_t          BlockSize,\r\n  uint16_t        Block_Instance,\r\n  uint8_t         Block_MajorRev,\r\n  uint8_t         Block_MinorRev\r\n  )",
                  "implementation": "void *\r\nSilCreateInfoBlock (\r\n  SIL_CONTEXT     *SilContext,\r\n  uint32_t        BlockTag,\r\n  size_t          BlockSize,\r\n  uint16_t        Block_Instance,\r\n  uint8_t         Block_MajorRev,\r\n  uint8_t         Block_MinorRev\r\n  )\r\n{\r\n  size_t                RequestSize;\r\n  SIL_INFO_BLOCK_HEADER *Header = NULL;\r\n\r\n  assert_true (BlockSize <= MAX_INFO_BLOCK_SIZE);\r\n\r\n  Header = (SIL_INFO_BLOCK_HEADER *)TempInfoBlock;\r\n  RequestSize = BlockSize + sizeof (SIL_INFO_BLOCK_HEADER);\r\n\r\n  // Fill the Info Block\r\n  Header->Id        = BlockTag;\r\n  Header->InfoBlockDataSize = (uint32_t)(RequestSize & 0xFFFFFFFF);\r\n  Header->Instance  = Block_Instance;\r\n  Header->RevMajor  = Block_MajorRev;\r\n  Header->RevMinor  = Block_MinorRev;\r\n  return (void *)Header->InfoBlockData;\r\n}",
                  "range": [
                    { "line": 37, "character": 0 },
                    { "line": 62, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 38, "character": 0 },
                    { "line": 38, "character": 18 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "SIL_CONTEXT",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                        "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                        "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "range": [
                          { "line": 131, "character": 0 },
                          { "line": 135, "character": 14 }
                        ],
                        "selectionRange": [
                          { "line": 135, "character": 2 },
                          { "line": 135, "character": 13 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_INFO_BLOCK_HEADER",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                        "documentation": "/** @brief Header structure for openSIL Input & Output Blocks\n *\n *  @details This header is included at the front of each block assigned. It is\n *  used to manage the space and locate the assigned blocks,\n *  see @ref SilFindStructure.\n */",
                        "definition": "typedef struct  {\r\n  uint32_t Id;                ///< Information block identifier, see @ref SIL_DATA_BLOCK_ID\r\n  uint16_t Instance;          ///< Instance # of this ID (0..N) Instance '0'\r\n                              ///<  is reserved for the top level (class level)\r\n                              ///<  and values 1..N are for the ports.\r\n  uint8_t  RevMajor;          ///< Structure Major revision number. This is\r\n                              ///<  incremented when a non-backward compatible\r\n                              ///<  change is made.\r\n  uint8_t  RevMinor;          ///< Structure Minor revision number. This is\r\n                              ///<  is incremented for every change.\r\n  uint32_t InfoBlockDataSize; ///< Information block size. This is the\r\n                              ///<  size of block assigned, including the header,\r\n                              ///<  rounded up to the next full DWORD.\r\n  uint8_t  InfoBlockData[];   ///< start of the IP input block data struct.\r\n                              ///<  Cast this point to the IP structure type to\r\n                              ///<  reference the structure elements.\r\n} SIL_INFO_BLOCK_HEADER;",
                        "implementation": "typedef struct  {\r\n  uint32_t Id;                ///< Information block identifier, see @ref SIL_DATA_BLOCK_ID\r\n  uint16_t Instance;          ///< Instance # of this ID (0..N) Instance '0'\r\n                              ///<  is reserved for the top level (class level)\r\n                              ///<  and values 1..N are for the ports.\r\n  uint8_t  RevMajor;          ///< Structure Major revision number. This is\r\n                              ///<  incremented when a non-backward compatible\r\n                              ///<  change is made.\r\n  uint8_t  RevMinor;          ///< Structure Minor revision number. This is\r\n                              ///<  is incremented for every change.\r\n  uint32_t InfoBlockDataSize; ///< Information block size. This is the\r\n                              ///<  size of block assigned, including the header,\r\n                              ///<  rounded up to the next full DWORD.\r\n  uint8_t  InfoBlockData[];   ///< start of the IP input block data struct.\r\n                              ///<  Cast this point to the IP structure type to\r\n                              ///<  reference the structure elements.\r\n} SIL_INFO_BLOCK_HEADER;",
                        "range": [
                          { "line": 82, "character": 0 },
                          { "line": 98, "character": 24 }
                        ],
                        "selectionRange": [
                          { "line": 98, "character": 2 },
                          { "line": 98, "character": 23 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "MAX_INFO_BLOCK_SIZE",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Include/Library/UtxSIMFakeLib.h",
                        "documentation": "/**\n * MAX_INFO_BLOCK_SIZE\n *\n * @brief An arbitrary size to allocate a build time array.\n *\n * @details This size can be increased to accommodate block sizes that exceed 64k\n */",
                        "definition": "#define MAX_INFO_BLOCK_SIZE  0x10000",
                        "implementation": "#define MAX_INFO_BLOCK_SIZE  0x10000",
                        "range": [
                          { "line": 16, "character": 0 },
                          { "line": 16, "character": 36 }
                        ],
                        "selectionRange": [
                          { "line": 16, "character": 8 },
                          { "line": 16, "character": 27 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "TempInfoBlock",
                        "kind": 12,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtxSIMFakeLib/UtxSIMFakeLib.c",
                        "documentation": "/**\n * @file UtxSIMFakeLib.c\n * @brief Defines cpu specific common operations\n *\n */",
                        "definition": "uint8_t TempInfoBlock[sizeof(SIL_INFO_BLOCK_HEADER) + MAX_INFO_BLOCK_SIZE] = {0};",
                        "implementation": "uint8_t TempInfoBlock[sizeof(SIL_INFO_BLOCK_HEADER) + MAX_INFO_BLOCK_SIZE] = {0};",
                        "range": [
                          { "line": 16, "character": 0 },
                          { "line": 16, "character": 81 }
                        ],
                        "selectionRange": [
                          { "line": 16, "character": 8 },
                          { "line": 16, "character": 21 }
                        ],
                        "dependencies": { "callTree": [] }
                      }
                    ]
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "name": "InitializeRcMgrPhxTp1",
      "kind": 11,
      "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/PHX/RcMgrPhx.c",
      "documentation": "/**\n * InitializeRcMgrPhxTp1\n *\n * @brief Initialize PHX resource registers for each RootBridge.\n *\n * @param   SilContext          A context structure through which host firmware defined data\n *                              can be passed to openSIL. The host firmware is responsible\n *                              for initializing the SIL_CONTEXT structure.\n */",
      "definition": "SIL_STATUS\r\nInitializeRcMgrPhxTp1 (\r\n  SIL_CONTEXT  *SilContext\r\n  )",
      "implementation": "SIL_STATUS\r\nInitializeRcMgrPhxTp1 (\r\n  SIL_CONTEXT  *SilContext\r\n  )\r\n{\r\n  DFX_RCMGR_INPUT_BLK *SilData;\r\n  SIL_STATUS          Status;\r\n  SIL_STATUS          CalledStatus;\r\n  APOB_IP2IP_API      *ApobIp2IpApi;\r\n  APOB_SOC_DIE_INFO   SocMaxDieInfo;\r\n\r\n  // Locate the IP block\r\n  SilData = (DFX_RCMGR_INPUT_BLK *) xUslFindStructure(SilContext, SilId_RcManager, 0);\r\n  if (SilData == NULL) {\r\n    RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"SIL RC Init memory block not found!\\n\");\r\n    CalledStatus = SilNotFound; // Could not find the IP input block\r\n  } else {\r\n    RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"SIL RC Init memory block is found blk at: 0x%x \\n\", SilData);\r\n\r\n    CalledStatus = SilPass;\r\n\r\n    Status = SilGetIp2IpApi(SilContext, SilId_ApobClass, (void **) &ApobIp2IpApi);\r\n    if ((Status != SilPass) || (ApobIp2IpApi == NULL)) {\r\n      assert(Status == SilPass);\r\n      return Status;\r\n    }\r\n    ApobIp2IpApi->ApobGetMaxDieInfo(SilContext, &SocMaxDieInfo);\r\n    // These asserts prevent tainted scalar coverity warnings by checking values\r\n    // are within permissible ranges\r\n    RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"SilData->SocketNumber: 0x%x \\n\", SilData->SocketNumber);\r\n    RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"SilData->RbsPerSocket: 0x%x \\n\", SilData->RbsPerSocket);\r\n    assert((SilData->SocketNumber > 0) && (SilData->SocketNumber <= SocMaxDieInfo.MaxSocSocketsSupportedValue));\r\n    assert((SilData->RbsPerSocket > 0) && (SilData->RbsPerSocket <= PROJ_MAX_RBS_PER_SOCKET));\r\n\r\n    RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"SilData->MmioRcMgr: 0x%x \\n\", &SilData->MmioRcMgr);\r\n    RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"SilData->IoRcMgr:   0x%x \\n\", &SilData->IoRcMgr);\r\n\r\n\r\n    // Initialize MMIO\r\n    if (SilData->SetRcBasedOnNv) {\r\n      // Got NvVariable successfully, try to init MMIO based on it\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"  Init MMIO based on NV variable\\n\");\r\n      CalledStatus = SilInitMmioBasedOnNvVariable4(SilContext, SilData, NULL, true);\r\n    }\r\n\r\n    if ((CalledStatus != SilPass) || (!SilData->SetRcBasedOnNv)) {\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n        \" Can't get NV variable or init MMIO based on NV variable failed.\\n\"\r\n        );\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO, \" Init MMIO equally.\\n\");\r\n      /* coverity[tainted_data:SUPPRESS] */\r\n      CalledStatus = SilInitMmioEqually4(SilContext, SilData);\r\n    }\r\n\r\n    if (CalledStatus == SilPass) {\r\n      // Initialize IO\r\n      if (SilData->SetRcBasedOnNv) {\r\n        // Get NvVariable successfully, try to init IO base on it\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"  Init IO based on NV variable\\n\");\r\n        CalledStatus = SilInitIoBasedOnNvVariable4(SilContext, SilData, NULL, true);\r\n      }\r\n\r\n      if ((!SilData->SetRcBasedOnNv) || (CalledStatus != SilPass)) {\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO, \" Can't get NV variable or init IO based on NV variable failed.\\n\");\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"                      Init IO equally.\\n\");\r\n        /* coverity[tainted_data:SUPPRESS] */\r\n        CalledStatus = SilInitIoEqually4(SilContext, SilData);\r\n      }\r\n    }\r\n  }\r\n  return SilPass;\r\n}",
      "range": [
        { "line": 68, "character": 0 },
        { "line": 139, "character": 1 }
      ],
      "selectionRange": [
        { "line": 69, "character": 0 },
        { "line": 69, "character": 21 }
      ],
      "dependencies": {
        "callTree": [
          {
            "name": "SIL_STATUS",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
            "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
            "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
            "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
            "range": [
              { "line": 49, "character": 0 },
              { "line": 74, "character": 13 }
            ],
            "selectionRange": [
              { "line": 74, "character": 2 },
              { "line": 74, "character": 12 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SIL_CONTEXT",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
            "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
            "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
            "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
            "range": [
              { "line": 131, "character": 0 },
              { "line": 135, "character": 14 }
            ],
            "selectionRange": [
              { "line": 135, "character": 2 },
              { "line": 135, "character": 13 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "DFX_RCMGR_INPUT_BLK",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
            "documentation": "",
            "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
            "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
            "range": [
              { "line": 124, "character": 0 },
              { "line": 143, "character": 22 }
            ],
            "selectionRange": [
              { "line": 143, "character": 2 },
              { "line": 143, "character": 21 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "APOB_IP2IP_API",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/ApobIp2Ip.h",
            "documentation": "",
            "definition": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
            "implementation": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
            "range": [
              { "line": 105, "character": 0 },
              { "line": 119, "character": 17 }
            ],
            "selectionRange": [
              { "line": 119, "character": 2 },
              { "line": 119, "character": 16 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "APOB_SOC_DIE_INFO",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/Common/ApobCmn.h",
            "documentation": "/**\n * @brief AMD APOB_SOC_DIE_INFO\n *\n */",
            "definition": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
            "implementation": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
            "range": [
              { "line": 544, "character": 0 },
              { "line": 552, "character": 20 }
            ],
            "selectionRange": [
              { "line": 552, "character": 2 },
              { "line": 552, "character": 19 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "RCMGR_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
            "kind": 13,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
            "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
            "definition": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
            "implementation": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
            "range": [
              { "line": 18, "character": 0 },
              { "line": 23, "character": 19 }
            ],
            "selectionRange": [
              { "line": 18, "character": 8 },
              { "line": 18, "character": 24 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SIL_TRACE_INFO",
            "kind": 13,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
            "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
            "definition": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
            "implementation": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
            "range": [
              { "line": 104, "character": 0 },
              { "line": 104, "character": 118 }
            ],
            "selectionRange": [
              { "line": 104, "character": 8 },
              { "line": 104, "character": 22 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "PROJ_MAX_RBS_PER_SOCKET",
            "kind": 13,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xSIM/SoC/F19M70/F19M70Charz.h",
            "documentation": "/**\n * @file F19M70Charz.h\n * @brief SoC characteristics constants\n */\n\n#pragma once\n\n/* SoC construction constants */\n#if      (PROJ_MAX_SOCKETS_SUPPORTED < 1)\n  #undef  PROJ_MAX_SOCKETS_SUPPORTED\n  #define PROJ_MAX_SOCKETS_SUPPORTED      1\n#endif\n#if      (PROJ_MAX_CCD_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_CCD_DIES_PER_SOCKET\n  #define PROJ_MAX_CCD_DIES_PER_SOCKET      1\n#endif\n#if      (PROJ_MAX_MEM_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_MEM_DIES_PER_SOCKET\n  #define PROJ_MAX_MEM_DIES_PER_SOCKET      1\n#endif\n#if      (PROJ_MAX_IO_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_IO_DIES_PER_SOCKET\n  #define PROJ_MAX_IO_DIES_PER_SOCKET      1\n#endif\n\n/* Processor Cores sub-system constants */\n#if      (PROJ_MAX_COMPLEXES_PER_CCD < 1)\n  #undef  PROJ_MAX_COMPLEXES_PER_CCD\n  #define PROJ_MAX_COMPLEXES_PER_CCD      1\n#endif\n#if      (PROJ_MAX_CCX_CORES_PER_COMPLEX < 8)\n  #undef  PROJ_MAX_CCX_CORES_PER_COMPLEX\n  #define PROJ_MAX_CCX_CORES_PER_COMPLEX      8\n#endif\n#if      (PROJ_MAX_CCX_THREADS_PER_CORE < 2)\n  #undef  PROJ_MAX_CCX_THREADS_PER_CORE\n  #define PROJ_MAX_CCX_THREADS_PER_CORE      2\n#endif\n#if      (PROJ_CCX_MAX_DIES_PER_SOCKET < 1)\n  #undef  PROJ_CCX_MAX_DIES_PER_SOCKET\n  #define PROJ_CCX_MAX_DIES_PER_SOCKET      1\n#endif\n\n/* Memory sub-system constants */\n#if      (PROJ_MAX_UMCS_PER_MEM_DIE < 2)\n  #undef  PROJ_MAX_UMCS_PER_MEM_DIE\n  #define PROJ_MAX_UMCS_PER_MEM_DIE      2\n#endif\n#if      (PROJ_MAX_CHANNELS_PER_UMC < 1)\n  #undef  PROJ_MAX_CHANNELS_PER_UMC\n  #define PROJ_MAX_CHANNELS_PER_UMC      1\n#endif\n#if      (PROJ_MAX_DIMMS_PER_CHANNEL < 2)\n  #undef  PROJ_MAX_DIMMS_PER_CHANNEL\n  #define PROJ_MAX_DIMMS_PER_CHANNEL      2\n#endif\n\n/* IO Hub sub-system constants */",
            "definition": "#define PROJ_MAX_RBS_PER_SOCKET      20",
            "implementation": "#define PROJ_MAX_RBS_PER_SOCKET      20",
            "range": [
              { "line": 62, "character": 2 },
              { "line": 62, "character": 41 }
            ],
            "selectionRange": [
              { "line": 62, "character": 10 },
              { "line": 62, "character": 33 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "xUslFindStructure",
            "kind": 11,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
            "documentation": "/**\n * xUslFindStructure\n *\n * @brief This function returns the data block for the specified module (IpId)\n *\n * @param SilContext    A context structure through which host firmware defined data\n *                      can be passed to openSIL. The host firmware is responsible\n *                      for initializing the SIL_CONTEXT structure.\n * @param IpId          The SIL_DATA_BLOCK_ID value for the IP block to return.\n * @param InstanceNum   The instance of the IP block data. (0 based)\n *\n * @return void*      The pointer to the IP block data\n *\n */",
            "definition": "void *\r\nxUslFindStructure (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  uint16_t            InstanceNum\r\n  )",
            "implementation": "void *\r\nxUslFindStructure (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  uint16_t            InstanceNum\r\n  )\r\n{\r\n  SIL_BLOCK_VARIABLES     *SilVars;\r\n  SIL_INFO_BLOCK_HEADER   *LclMemPtr;\r\n  SIL_INFO_BLOCK_HEADER   *FreeSpaceBase;\r\n\r\n  XUSL_TRACEPOINT(SIL_TRACE_ENTRY, \"\\n\");\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /* make local pointer to first assigned Input block */\r\n  LclMemPtr = (SIL_INFO_BLOCK_HEADER *) ((uint8_t *) SilVars +\r\n    sizeof (SIL_BLOCK_VARIABLES));\r\n\r\n  XUSL_TRACEPOINT(SIL_TRACE_INFO,\r\n    \"Looking for IP block ID %d\\n\",\r\n    IpId\r\n    );\r\n\r\n  FreeSpaceBase = (SIL_INFO_BLOCK_HEADER *)((uint8_t *) SilVars +\r\n    SilVars->FreeSpaceOffset);\r\n  XUSL_TRACEPOINT(SIL_TRACE_INFO,\r\n    \"SilMemoryBase: 0x%x, FreeSpaceOffset: 0x%x, FreeSpaceBase = 0x%x\\n\",\r\n    SilVars,\r\n    SilVars->FreeSpaceOffset,\r\n    FreeSpaceBase\r\n    );\r\n\r\n  while ((uintptr_t) LclMemPtr < (uintptr_t) FreeSpaceBase) {\r\n    if ((LclMemPtr->Id == (uint32_t)IpId) &&\r\n      (LclMemPtr->Instance == InstanceNum)) {\r\n      XUSL_TRACEPOINT(SIL_TRACE_EXIT,\r\n        \"FoundStruc.Data @0x%x \\n\",\r\n        &LclMemPtr->InfoBlockData\r\n        );\r\n      return &(LclMemPtr->InfoBlockData);\r\n    }\r\n    LclMemPtr = (SIL_INFO_BLOCK_HEADER *)\r\n      ((uint8_t *)LclMemPtr + LclMemPtr->InfoBlockDataSize);\r\n  }\r\n\r\n  XUSL_TRACEPOINT(SIL_TRACE_EXIT, \"NoFindStruc ID:0x%x\\n\", LclMemPtr->Id);\r\n  return NULL;\r\n}",
            "range": [
              { "line": 80, "character": 0 },
              { "line": 127, "character": 1 }
            ],
            "selectionRange": [
              { "line": 81, "character": 0 },
              { "line": 81, "character": 17 }
            ],
            "dependencies": {
              "callTree": [
                {
                  "name": "SIL_CONTEXT",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                  "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "range": [
                    { "line": 131, "character": 0 },
                    { "line": 135, "character": 14 }
                  ],
                  "selectionRange": [
                    { "line": 135, "character": 2 },
                    { "line": 135, "character": 13 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_DATA_BLOCK_ID",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                  "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                  "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                  "range": [
                    { "line": 48, "character": 0 },
                    { "line": 73, "character": 20 }
                  ],
                  "selectionRange": [
                    { "line": 73, "character": 2 },
                    { "line": 73, "character": 19 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_BLOCK_VARIABLES",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                  "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                  "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                  "range": [
                    { "line": 182, "character": 0 },
                    { "line": 193, "character": 22 }
                  ],
                  "selectionRange": [
                    { "line": 193, "character": 2 },
                    { "line": 193, "character": 21 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_INFO_BLOCK_HEADER",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/** @brief Header structure for openSIL Input & Output Blocks\n *\n *  @details This header is included at the front of each block assigned. It is\n *  used to manage the space and locate the assigned blocks,\n *  see @ref SilFindStructure.\n */",
                  "definition": "typedef struct  {\r\n  uint32_t Id;                ///< Information block identifier, see @ref SIL_DATA_BLOCK_ID\r\n  uint16_t Instance;          ///< Instance # of this ID (0..N) Instance '0'\r\n                              ///<  is reserved for the top level (class level)\r\n                              ///<  and values 1..N are for the ports.\r\n  uint8_t  RevMajor;          ///< Structure Major revision number. This is\r\n                              ///<  incremented when a non-backward compatible\r\n                              ///<  change is made.\r\n  uint8_t  RevMinor;          ///< Structure Minor revision number. This is\r\n                              ///<  is incremented for every change.\r\n  uint32_t InfoBlockDataSize; ///< Information block size. This is the\r\n                              ///<  size of block assigned, including the header,\r\n                              ///<  rounded up to the next full DWORD.\r\n  uint8_t  InfoBlockData[];   ///< start of the IP input block data struct.\r\n                              ///<  Cast this point to the IP structure type to\r\n                              ///<  reference the structure elements.\r\n} SIL_INFO_BLOCK_HEADER;",
                  "implementation": "typedef struct  {\r\n  uint32_t Id;                ///< Information block identifier, see @ref SIL_DATA_BLOCK_ID\r\n  uint16_t Instance;          ///< Instance # of this ID (0..N) Instance '0'\r\n                              ///<  is reserved for the top level (class level)\r\n                              ///<  and values 1..N are for the ports.\r\n  uint8_t  RevMajor;          ///< Structure Major revision number. This is\r\n                              ///<  incremented when a non-backward compatible\r\n                              ///<  change is made.\r\n  uint8_t  RevMinor;          ///< Structure Minor revision number. This is\r\n                              ///<  is incremented for every change.\r\n  uint32_t InfoBlockDataSize; ///< Information block size. This is the\r\n                              ///<  size of block assigned, including the header,\r\n                              ///<  rounded up to the next full DWORD.\r\n  uint8_t  InfoBlockData[];   ///< start of the IP input block data struct.\r\n                              ///<  Cast this point to the IP structure type to\r\n                              ///<  reference the structure elements.\r\n} SIL_INFO_BLOCK_HEADER;",
                  "range": [
                    { "line": 82, "character": 0 },
                    { "line": 98, "character": 24 }
                  ],
                  "selectionRange": [
                    { "line": 98, "character": 2 },
                    { "line": 98, "character": 23 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "XUSL_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "",
                  "definition": "#define XUSL_TRACEPOINT(MsgLevel, Message, ...) \\\r\n        do { \\\r\n          if (SIL_DEBUG_ENABLE) { \\\r\n            ((HOST_DEBUG_SERVICE)SilTracePoint) (MsgLevel, \"SIL:xUSL:\", \\\r\n            Message, __FUNCTION__, __LINE__, ## __VA_ARGS__); \\\r\n          } \\\r\n        } while (false)",
                  "implementation": "#define XUSL_TRACEPOINT(MsgLevel, Message, ...) \\\r\n        do { \\\r\n          if (SIL_DEBUG_ENABLE) { \\\r\n            ((HOST_DEBUG_SERVICE)SilTracePoint) (MsgLevel, \"SIL:xUSL:\", \\\r\n            Message, __FUNCTION__, __LINE__, ## __VA_ARGS__); \\\r\n          } \\\r\n        } while (false)",
                  "range": [
                    { "line": 136, "character": 0 },
                    { "line": 142, "character": 23 }
                  ],
                  "selectionRange": [
                    { "line": 136, "character": 8 },
                    { "line": 136, "character": 23 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_ENTRY",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_ENTRY   BIT_32(2)   ///< Messages showing entry flow",
                  "implementation": "#define SIL_TRACE_ENTRY   BIT_32(2)   ///< Messages showing entry flow",
                  "range": [
                    { "line": 102, "character": 0 },
                    { "line": 102, "character": 70 }
                  ],
                  "selectionRange": [
                    { "line": 102, "character": 8 },
                    { "line": 102, "character": 23 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_INFO",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                  "implementation": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                  "range": [
                    { "line": 104, "character": 0 },
                    { "line": 104, "character": 118 }
                  ],
                  "selectionRange": [
                    { "line": 104, "character": 8 },
                    { "line": 104, "character": 22 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_EXIT",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_EXIT    BIT_32(3)   ///< Messages showing exit flow",
                  "implementation": "#define SIL_TRACE_EXIT    BIT_32(3)   ///< Messages showing exit flow",
                  "range": [
                    { "line": 103, "character": 0 },
                    { "line": 103, "character": 69 }
                  ],
                  "selectionRange": [
                    { "line": 103, "character": 8 },
                    { "line": 103, "character": 22 }
                  ],
                  "dependencies": { "callTree": [] }
                }
              ]
            }
          },
          {
            "name": "SilGetIp2IpApi",
            "kind": 11,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
            "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
            "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
            "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
            "range": [
              { "line": 190, "character": 0 },
              { "line": 219, "character": 1 }
            ],
            "selectionRange": [
              { "line": 191, "character": 0 },
              { "line": 191, "character": 14 }
            ],
            "dependencies": {
              "callTree": [
                {
                  "name": "SIL_STATUS",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                  "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                  "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "range": [
                    { "line": 49, "character": 0 },
                    { "line": 74, "character": 13 }
                  ],
                  "selectionRange": [
                    { "line": 74, "character": 2 },
                    { "line": 74, "character": 12 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_CONTEXT",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                  "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "range": [
                    { "line": 131, "character": 0 },
                    { "line": 135, "character": 14 }
                  ],
                  "selectionRange": [
                    { "line": 135, "character": 2 },
                    { "line": 135, "character": 13 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_DATA_BLOCK_ID",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                  "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                  "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                  "range": [
                    { "line": 48, "character": 0 },
                    { "line": 73, "character": 20 }
                  ],
                  "selectionRange": [
                    { "line": 73, "character": 2 },
                    { "line": 73, "character": 19 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_BLOCK_VARIABLES",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                  "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                  "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                  "range": [
                    { "line": 182, "character": 0 },
                    { "line": 193, "character": 22 }
                  ],
                  "selectionRange": [
                    { "line": 193, "character": 2 },
                    { "line": 193, "character": 21 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_ERROR",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                  "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                  "range": [
                    { "line": 100, "character": 0 },
                    { "line": 100, "character": 87 }
                  ],
                  "selectionRange": [
                    { "line": 100, "character": 8 },
                    { "line": 100, "character": 23 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "__disable_tail_calls",
                  "kind": 12,
                  "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                  "documentation": "",
                  "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                  "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                  "range": [
                    { "line": 59, "character": 0 },
                    { "line": 59, "character": 101 }
                  ],
                  "selectionRange": [
                    { "line": 59, "character": 80 },
                    { "line": 59, "character": 100 }
                  ],
                  "dependencies": { "callTree": [] }
                }
              ]
            }
          },
          {
            "name": "__disable_tail_calls",
            "kind": 12,
            "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
            "documentation": "",
            "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
            "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
            "range": [
              { "line": 59, "character": 0 },
              { "line": 59, "character": 101 }
            ],
            "selectionRange": [
              { "line": 59, "character": 80 },
              { "line": 59, "character": 100 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SilInitMmioBasedOnNvVariable4",
            "kind": 11,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
            "documentation": "/**\n * SilInitMmioBasedOnNvVariable4\n *\n * @brief Initialize MMIO registers for each Root Bridge based on NV variable.\n *\n * @param   SilContext                          A context structure through which host firmware defined data\n *                                              can be passed to openSIL. The host firmware is responsible\n *                                              for initializing the SIL_CONTEXT structure.\n * @param   SilData                             Pointer to DFX_RCMGR_INPUT_BLK\n *            SilData->FabricMmioManager        Point to DFX_FABRIC_MMIO_MANAGER\n *            SilData->MmioSizeForEachRb        How much MMIO size is required for each Root Bridge\n *            SilData->SocketNumber             System socket count\n *            SilData->RbsPerSocket             Root Bridge number per socket\n * @param   SpaceStatus                          Current status\n * @param   SetDfRegisters                      true  - Set DF MMIO registers\n *                                              false - Do Not set DF MMIO registers, just calculate\n *                                                     if user's requirement could be satisfied.\n */",
            "definition": "SIL_STATUS\r\nSilInitMmioBasedOnNvVariable4 (\r\n  SIL_CONTEXT             *SilContext,\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  FABRIC_ADDR_SPACE_SIZE  *SpaceStatus,\r\n  bool                    SetDfRegisters\r\n  )",
            "implementation": "SIL_STATUS\r\nSilInitMmioBasedOnNvVariable4 (\r\n  SIL_CONTEXT             *SilContext,\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  FABRIC_ADDR_SPACE_SIZE  *SpaceStatus,\r\n  bool                    SetDfRegisters\r\n  )\r\n{\r\n  uint64_t MmioLimitAbove4G;\r\n  uint64_t MmioBaseAddrNextRb;\r\n  uint64_t MmioBaseAddrAbovePcieCfg;\r\n  uint64_t MmioBaseAddrBelowPcieCfg;\r\n  uint64_t TOM;\r\n  uint64_t TOM2;\r\n  uint64_t PciCfgSpace;\r\n  uint64_t MmioSizeBelowHole;\r\n  uint64_t MmioSizeAboveHole;\r\n  uint64_t SizeNonPci;\r\n  uint32_t PrimarySocket;\r\n  uint32_t PrimaryDie;\r\n  uint32_t PrimaryRootBridge;\r\n  SIL_STATUS Status;\r\n  bool MmioIsAbovePcieCfg[PROJ_MAX_SOCKETS_SUPPORTED * PROJ_MAX_HOST_BRIDGES_PER_SOCKET];\r\n  bool LastCombinationWork;\r\n  bool EnoughAbovePcieSpaceForPrimaryRb;\r\n  uint32_t OverSizeBelowPcieMin;\r\n  uint32_t AlignmentMask;\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB  *MmioSizeForEachRb;\r\n  uint64_t MmioLimitAbovePcieCfg;\r\n\r\n  Status = SilPass;\r\n  MmioSizeForEachRb = &SilData->ResourceSizeForEachRb;\r\n  MmioLimitAbovePcieCfg = SilData->MmioLimitAbovePcieCfg;\r\n\r\n  OverSizeBelowPcieMin = 0xFFFFFFFF;\r\n  AlignmentMask = 0;\r\n  EnoughAbovePcieSpaceForPrimaryRb = false;\r\n\r\n  // System information\r\n  PciCfgSpace = (xUslRdMsr(0xC0010058) >> 2) & 0xF;            // Get bus range from MSR_C001_0058[5:2][BusRange]\r\n  PciCfgSpace = ((uint64_t) 1 << PciCfgSpace) * (1024 * 1024); // 1MB times the number of buses\r\n  TOM = xUslRdMsr(MSR_TOM);\r\n  TOM2 = xUslRdMsr(MSR_TOM2);\r\n  RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n    \"  TOM: 0x%llX, TOM2: 0x%llX, Pcie configuration space: 0x%llX ~ 0x%llX\\n\",\r\n    TOM,\r\n    TOM2,\r\n    SilData->PciExpressBaseAddress,\r\n    SilData->PciExpressBaseAddress + PciCfgSpace\r\n    );\r\n\r\n  if (SilData->PciExpressBaseAddress < 0x100000000) {\r\n    assert(SilData->BottomMmioReservedForPrimaryRb >= (SilData->PciExpressBaseAddress + PciCfgSpace));\r\n    assert(SilData->PciExpressBaseAddress >= TOM);\r\n  }\r\n\r\n  // Calculate size of above 4G\r\n  MmioBaseAddrNextRb = (TOM2 > 0x100000000)? TOM2 : 0x100000000; // Check if TOM2 > 4G\r\n  MmioLimitAbove4G = (uint64_t)xUslGetPhysAddrSize ();\r\n  if (SilData->AmdSmee) {\r\n    MmioLimitAbove4G -= (uint64_t)xUslGetPhysAddrReduction ();\r\n  }\r\n  MmioLimitAbove4G = (1ull << MmioLimitAbove4G) - 0x300000000;\r\n\r\n  if (SilData->MmioAbove4GLimit < MmioLimitAbove4G) {\r\n    MmioLimitAbove4G = (SilData->MmioAbove4GLimit + 1) & 0xFFFFFFFFFFFF0000;\r\n    if (MmioLimitAbove4G <= MmioBaseAddrNextRb) {\r\n      MmioLimitAbove4G = MmioBaseAddrNextRb;\r\n    }\r\n  }\r\n\r\n  if (SilData->AmdFabric1TbRemap) {\r\n    // there's a hole at 0xFD_0000_0000 ~ 0x100_0000_0000\r\n    MmioSizeBelowHole = 0;\r\n    MmioSizeAboveHole = 0;\r\n\r\n    // calculate Mmio size below/above this hole\r\n    if (MmioBaseAddrNextRb < 0xFD00000000) {\r\n      MmioSizeBelowHole = (MmioLimitAbove4G < 0xFD00000000) ? MmioLimitAbove4G : 0xFD00000000;\r\n      MmioSizeBelowHole = MmioSizeBelowHole - MmioBaseAddrNextRb;\r\n    }\r\n\r\n    if (MmioLimitAbove4G > 0x10000000000) {\r\n      MmioSizeAboveHole = (MmioBaseAddrNextRb > 0x10000000000)? MmioBaseAddrNextRb : 0x10000000000;\r\n      MmioSizeAboveHole = MmioLimitAbove4G - MmioSizeAboveHole;\r\n    }\r\n\r\n    if ((MmioSizeBelowHole == 0) && (MmioSizeAboveHole == 0)) {\r\n      MmioLimitAbove4G = 0; // set limit to 0, so there's no MMIO space above 4G\r\n      RCMGR_TRACEPOINT(SIL_TRACE_WARNING, \"    There's no MMIO space above 4G\\n\");\r\n    } else {\r\n      if (MmioSizeAboveHole > MmioSizeBelowHole) {\r\n        MmioBaseAddrNextRb = (TOM2 > 0x10000000000) ? TOM2 : 0x10000000000; // Check if TOM2 > 1T\r\n      } else {\r\n        MmioLimitAbove4G = (MmioLimitAbove4G < 0xFD00000000) ? MmioLimitAbove4G : 0xFD00000000;\r\n      }\r\n    }\r\n  }\r\n\r\n  // There's a PCIE hole if PciExpressBaseAddress is above 4\r\n  if (SilData->PciExpressBaseAddress >= 0x100000000) {\r\n    assert(SilData->PciExpressBaseAddress >= TOM2);\r\n    assert((SilData->PciExpressBaseAddress + PciCfgSpace) < MmioLimitAbove4G);\r\n    if ((SilData->PciExpressBaseAddress <= MmioBaseAddrNextRb) &&\r\n      ((SilData->PciExpressBaseAddress + PciCfgSpace) >= MmioBaseAddrNextRb)) {\r\n      MmioBaseAddrNextRb = SilData->PciExpressBaseAddress + PciCfgSpace;\r\n    } else if ((SilData->PciExpressBaseAddress <= MmioLimitAbove4G) &&\r\n      ((SilData->PciExpressBaseAddress + PciCfgSpace) >= MmioLimitAbove4G)) {\r\n      MmioLimitAbove4G = SilData->PciExpressBaseAddress;\r\n    } else if ((SilData->PciExpressBaseAddress >= MmioBaseAddrNextRb) &&\r\n      (SilData->PciExpressBaseAddress <= MmioLimitAbove4G) &&\r\n      ((SilData->PciExpressBaseAddress + PciCfgSpace) >= MmioBaseAddrNextRb) &&\r\n      (SilData->PciExpressBaseAddress + PciCfgSpace) <= MmioLimitAbove4G) {\r\n      if ((SilData->PciExpressBaseAddress - MmioBaseAddrNextRb) <\r\n        (MmioLimitAbove4G - (SilData->PciExpressBaseAddress + PciCfgSpace))) {\r\n        MmioBaseAddrNextRb = SilData->PciExpressBaseAddress + PciCfgSpace;\r\n      } else {\r\n        MmioLimitAbove4G = SilData->PciExpressBaseAddress;\r\n      }\r\n    } else {\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"    MMIO region is completed in the PCIE configuration space.\\n\");\r\n      assert(false);\r\n    }\r\n  }\r\n\r\n  RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n    \"    Above 4G MMIO base is 0x%llX, limit is 0x%llX\\n\",\r\n    MmioBaseAddrNextRb,\r\n    MmioLimitAbove4G\r\n    );\r\n\r\n  if (!SilArrangeMmioAbove4G(SilContext,\r\n    SilData,\r\n    SpaceStatus,\r\n    &MmioBaseAddrNextRb,\r\n    MmioLimitAbove4G,\r\n    SetDfRegisters\r\n    )) {\r\n    return SilOutOfResources;\r\n  }\r\n\r\n  // Calculate size of below 4G\r\n  if (SilData->PciExpressBaseAddress >= 0x100000000) {\r\n    MmioBaseAddrAbovePcieCfg = SilData->BottomMmioReservedForPrimaryRb;\r\n    MmioBaseAddrBelowPcieCfg = TOM;\r\n  } else {\r\n    MmioBaseAddrAbovePcieCfg = SilData->PciExpressBaseAddress + PciCfgSpace;\r\n    MmioBaseAddrBelowPcieCfg = TOM;\r\n  }\r\n\r\n  SilGetPrimaryRb(SilContext, &PrimarySocket, &PrimaryDie, &PrimaryRootBridge);\r\n\r\n  SizeNonPci = SilData->MmioSizePerRbForNonPciDevice;\r\n  if ((MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[PrimarySocket][PrimaryRootBridge].Size +\r\n    MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[PrimarySocket][PrimaryRootBridge].Size + SizeNonPci) <=\r\n    (MmioLimitAbovePcieCfg - MmioBaseAddrAbovePcieCfg)) {\r\n    EnoughAbovePcieSpaceForPrimaryRb = true;\r\n  }\r\n\r\n  LastCombinationWork = false;\r\n  if (SilFabricGetResourceDistribution(SilData, &MmioIsAbovePcieCfg[0]) == SilPass) {\r\n    // Get distribution information from NV, try it first\r\n    if (SilTryThisCombination(SilContext,\r\n      SilData,\r\n      MmioBaseAddrAbovePcieCfg,\r\n      MmioBaseAddrBelowPcieCfg,\r\n      MmioIsAbovePcieCfg,\r\n      SetDfRegisters,\r\n      &OverSizeBelowPcieMin,\r\n      &AlignmentMask\r\n      )) {\r\n      // It works! No need to find out a new combination that which RootBridge is above Pcie Cfg\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"  Use combination of RB resources from NV.\\n\");\r\n      LastCombinationWork = true;\r\n    }\r\n  }\r\n\r\n  if (!LastCombinationWork) {\r\n    if (SilArrangeMmioBelow4G(SilContext,\r\n      SilData,\r\n      MmioBaseAddrAbovePcieCfg,\r\n      MmioBaseAddrBelowPcieCfg,\r\n      MmioIsAbovePcieCfg,\r\n      (uint8_t) PrimarySocket,\r\n      (uint8_t) PrimaryRootBridge,\r\n      SetDfRegisters,\r\n      &OverSizeBelowPcieMin,\r\n      &AlignmentMask,\r\n      &EnoughAbovePcieSpaceForPrimaryRb\r\n      )) {\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"  Save combination to NV\\n\");\r\n      /* coverity[side_effect_free] */\r\n      SilFabricSetResourceDistribution(SilData, &MmioIsAbovePcieCfg[0]);\r\n    } else {\r\n      if (EnoughAbovePcieSpaceForPrimaryRb) {\r\n        EnoughAbovePcieSpaceForPrimaryRb = false;\r\n        if (SilArrangeMmioBelow4G(SilContext,\r\n          SilData,\r\n          MmioBaseAddrAbovePcieCfg,\r\n          MmioBaseAddrBelowPcieCfg,\r\n          MmioIsAbovePcieCfg,\r\n          (uint8_t) PrimarySocket,\r\n          (uint8_t) PrimaryRootBridge,\r\n          SetDfRegisters,\r\n          &OverSizeBelowPcieMin,\r\n          &AlignmentMask,\r\n          &EnoughAbovePcieSpaceForPrimaryRb\r\n          )) {\r\n          RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"  Save combination to NV\\n\");\r\n          /* coverity[side_effect_free] */\r\n          SilFabricSetResourceDistribution(SilData, &MmioIsAbovePcieCfg[0]);\r\n        } else {\r\n          RCMGR_TRACEPOINT(SIL_TRACE_WARNING, \"  Not enough resources below 4G\\n\");\r\n          Status = SilOutOfResources;\r\n        }\r\n      } else {\r\n        RCMGR_TRACEPOINT(SIL_TRACE_WARNING, \"  Not enough resources below 4G\\n\");\r\n        Status = SilOutOfResources;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Update SpaceStatus\r\n  if (SpaceStatus != NULL) {\r\n    assert(OverSizeBelowPcieMin != 0xFFFFFFFF);\r\n    SpaceStatus->MmioSizeAbove4GReqInc = (MmioBaseAddrNextRb > MmioLimitAbove4G) ?\r\n      (MmioBaseAddrNextRb - MmioLimitAbove4G) : 0;\r\n    SpaceStatus->MmioSizeBelow4GReqInc = OverSizeBelowPcieMin;\r\n    if (SpaceStatus->MmioSizeBelow4GReqInc != 0) {\r\n      SpaceStatus->MmioSizeBelow4GReqInc = (SpaceStatus->MmioSizeBelow4GReqInc + AlignmentMask) & (~AlignmentMask);\r\n    }\r\n    RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n      \"  Space Status: MmioSizeAbove4G %llX, MmioSizeAbove4GReqInc %llX\\n\",\r\n      SpaceStatus->MmioSizeAbove4G,\r\n      SpaceStatus->MmioSizeAbove4GReqInc\r\n      );\r\n    RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n      \"  Space Status: MmioSizeBelow4G %llX, MmioSizeBelow4GReqInc %llX\\n\",\r\n      SpaceStatus->MmioSizeBelow4G,\r\n      SpaceStatus->MmioSizeBelow4GReqInc\r\n      );\r\n  }\r\n\r\n  return Status;\r\n}",
            "range": [
              { "line": 1225, "character": 0 },
              { "line": 1469, "character": 1 }
            ],
            "selectionRange": [
              { "line": 1226, "character": 0 },
              { "line": 1226, "character": 29 }
            ],
            "dependencies": {
              "callTree": [
                {
                  "name": "SIL_STATUS",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                  "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                  "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "range": [
                    { "line": 49, "character": 0 },
                    { "line": 74, "character": 13 }
                  ],
                  "selectionRange": [
                    { "line": 74, "character": 2 },
                    { "line": 74, "character": 12 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_CONTEXT",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                  "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "range": [
                    { "line": 131, "character": 0 },
                    { "line": 135, "character": 14 }
                  ],
                  "selectionRange": [
                    { "line": 135, "character": 2 },
                    { "line": 135, "character": 13 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "DFX_RCMGR_INPUT_BLK",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                  "documentation": "",
                  "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                  "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                  "range": [
                    { "line": 124, "character": 0 },
                    { "line": 143, "character": 22 }
                  ],
                  "selectionRange": [
                    { "line": 143, "character": 2 },
                    { "line": 143, "character": 21 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "FABRIC_ADDR_SPACE_SIZE",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                  "documentation": "/// Current status",
                  "definition": "typedef struct _FABRIC_ADDR_SPACE_SIZE {\r\n  uint32_t  IoSize;                ///< IO size required by system resources\r\n  uint32_t  IoSizeReqInc;          ///< The amount needed over the current size\r\n  uint32_t  MmioSizeBelow4G;       ///< Below 4G Mmio size required by system resources\r\n  uint32_t  MmioSizeBelow4GReqInc; ///< The amount needed over the current size\r\n  uint64_t  MmioSizeAbove4G;       ///< Above 4G Mmio size required by system resources\r\n  uint64_t  MmioSizeAbove4GReqInc; ///< The amount needed over the current size\r\n} FABRIC_ADDR_SPACE_SIZE;",
                  "implementation": "typedef struct _FABRIC_ADDR_SPACE_SIZE {\r\n  uint32_t  IoSize;                ///< IO size required by system resources\r\n  uint32_t  IoSizeReqInc;          ///< The amount needed over the current size\r\n  uint32_t  MmioSizeBelow4G;       ///< Below 4G Mmio size required by system resources\r\n  uint32_t  MmioSizeBelow4GReqInc; ///< The amount needed over the current size\r\n  uint64_t  MmioSizeAbove4G;       ///< Above 4G Mmio size required by system resources\r\n  uint64_t  MmioSizeAbove4GReqInc; ///< The amount needed over the current size\r\n} FABRIC_ADDR_SPACE_SIZE;",
                  "range": [
                    { "line": 45, "character": 0 },
                    { "line": 52, "character": 25 }
                  ],
                  "selectionRange": [
                    { "line": 52, "character": 2 },
                    { "line": 52, "character": 24 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "PROJ_MAX_SOCKETS_SUPPORTED",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xSIM/SoC/F19M70/F19M70Charz.h",
                  "documentation": "/**\n * @file F19M70Charz.h\n * @brief SoC characteristics constants\n */\n\n#pragma once\n\n/* SoC construction constants */",
                  "definition": "#define PROJ_MAX_SOCKETS_SUPPORTED      1",
                  "implementation": "#define PROJ_MAX_SOCKETS_SUPPORTED      1",
                  "range": [
                    { "line": 12, "character": 2 },
                    { "line": 12, "character": 43 }
                  ],
                  "selectionRange": [
                    { "line": 12, "character": 10 },
                    { "line": 12, "character": 36 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "PROJ_MAX_HOST_BRIDGES_PER_SOCKET",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xSIM/SoC/F19M70/F19M70Charz.h",
                  "documentation": "/**\n * @file F19M70Charz.h\n * @brief SoC characteristics constants\n */\n\n#pragma once\n\n/* SoC construction constants */\n#if      (PROJ_MAX_SOCKETS_SUPPORTED < 1)\n  #undef  PROJ_MAX_SOCKETS_SUPPORTED\n  #define PROJ_MAX_SOCKETS_SUPPORTED      1\n#endif\n#if      (PROJ_MAX_CCD_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_CCD_DIES_PER_SOCKET\n  #define PROJ_MAX_CCD_DIES_PER_SOCKET      1\n#endif\n#if      (PROJ_MAX_MEM_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_MEM_DIES_PER_SOCKET\n  #define PROJ_MAX_MEM_DIES_PER_SOCKET      1\n#endif\n#if      (PROJ_MAX_IO_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_IO_DIES_PER_SOCKET\n  #define PROJ_MAX_IO_DIES_PER_SOCKET      1\n#endif\n\n/* Processor Cores sub-system constants */\n#if      (PROJ_MAX_COMPLEXES_PER_CCD < 1)\n  #undef  PROJ_MAX_COMPLEXES_PER_CCD\n  #define PROJ_MAX_COMPLEXES_PER_CCD      1\n#endif\n#if      (PROJ_MAX_CCX_CORES_PER_COMPLEX < 8)\n  #undef  PROJ_MAX_CCX_CORES_PER_COMPLEX\n  #define PROJ_MAX_CCX_CORES_PER_COMPLEX      8\n#endif\n#if      (PROJ_MAX_CCX_THREADS_PER_CORE < 2)\n  #undef  PROJ_MAX_CCX_THREADS_PER_CORE\n  #define PROJ_MAX_CCX_THREADS_PER_CORE      2\n#endif\n#if      (PROJ_CCX_MAX_DIES_PER_SOCKET < 1)\n  #undef  PROJ_CCX_MAX_DIES_PER_SOCKET\n  #define PROJ_CCX_MAX_DIES_PER_SOCKET      1\n#endif\n\n/* Memory sub-system constants */\n#if      (PROJ_MAX_UMCS_PER_MEM_DIE < 2)\n  #undef  PROJ_MAX_UMCS_PER_MEM_DIE\n  #define PROJ_MAX_UMCS_PER_MEM_DIE      2\n#endif\n#if      (PROJ_MAX_CHANNELS_PER_UMC < 1)\n  #undef  PROJ_MAX_CHANNELS_PER_UMC\n  #define PROJ_MAX_CHANNELS_PER_UMC      1\n#endif\n#if      (PROJ_MAX_DIMMS_PER_CHANNEL < 2)\n  #undef  PROJ_MAX_DIMMS_PER_CHANNEL\n  #define PROJ_MAX_DIMMS_PER_CHANNEL      2\n#endif\n\n/* IO Hub sub-system constants */",
                  "definition": "#define PROJ_MAX_HOST_BRIDGES_PER_SOCKET      1",
                  "implementation": "#define PROJ_MAX_HOST_BRIDGES_PER_SOCKET      1",
                  "range": [
                    { "line": 66, "character": 2 },
                    { "line": 66, "character": 49 }
                  ],
                  "selectionRange": [
                    { "line": 66, "character": 10 },
                    { "line": 66, "character": 42 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "DFX_FABRIC_RESOURCE_FOR_EACH_RB",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                  "documentation": "/// Resource for each RootBridge",
                  "definition": "typedef struct {\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondNonPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  IO[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  uint16_t              PciBusNumber[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n} DFX_FABRIC_RESOURCE_FOR_EACH_RB;",
                  "implementation": "typedef struct {\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondNonPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  IO[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  uint16_t              PciBusNumber[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n} DFX_FABRIC_RESOURCE_FOR_EACH_RB;",
                  "range": [
                    { "line": 74, "character": 0 },
                    { "line": 83, "character": 34 }
                  ],
                  "selectionRange": [
                    { "line": 83, "character": 2 },
                    { "line": 83, "character": 33 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "MSR_TOM",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/MsrReg.h",
                  "documentation": "// MSRs\n// ------------------------",
                  "definition": "#define MSR_TOM                             0xC001001Aul",
                  "implementation": "#define MSR_TOM                             0xC001001Aul",
                  "range": [
                    { "line": 222, "character": 0 },
                    { "line": 222, "character": 56 }
                  ],
                  "selectionRange": [
                    { "line": 222, "character": 8 },
                    { "line": 222, "character": 15 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "MSR_TOM2",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/MsrReg.h",
                  "documentation": "// MSRs\n// ------------------------",
                  "definition": "#define MSR_TOM2                            0xC001001Dul",
                  "implementation": "#define MSR_TOM2                            0xC001001Dul",
                  "range": [
                    { "line": 223, "character": 0 },
                    { "line": 223, "character": 56 }
                  ],
                  "selectionRange": [
                    { "line": 223, "character": 8 },
                    { "line": 223, "character": 16 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "RCMGR_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                  "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
                  "definition": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                  "implementation": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                  "range": [
                    { "line": 18, "character": 0 },
                    { "line": 23, "character": 19 }
                  ],
                  "selectionRange": [
                    { "line": 18, "character": 8 },
                    { "line": 18, "character": 24 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_INFO",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                  "implementation": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                  "range": [
                    { "line": 104, "character": 0 },
                    { "line": 104, "character": 118 }
                  ],
                  "selectionRange": [
                    { "line": 104, "character": 8 },
                    { "line": 104, "character": 22 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_WARNING",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_WARNING BIT_32(1)   ///< Result is unexpected but not necessarily a problem",
                  "implementation": "#define SIL_TRACE_WARNING BIT_32(1)   ///< Result is unexpected but not necessarily a problem",
                  "range": [
                    { "line": 101, "character": 0 },
                    { "line": 101, "character": 93 }
                  ],
                  "selectionRange": [
                    { "line": 101, "character": 8 },
                    { "line": 101, "character": 25 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "xUslRdMsr",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtCpuOpsFakeLib/UtCpuOpsFakeLib.c",
                  "documentation": "/**\n * xUslRdMsr (Fake)\n *\n * @brief    Fake function to return the value of in MSR specified in MsrAddress\n *\n * @details  The function will traverse the linked list and return the first MsrValue with the matching MsrAddress. The\n *           node will then be removed from the list. The linked list is built by the UT case using FakexUslRdMsrAdd.\n *\n * @param[in] MsrAddress - The address of the MSR to read\n *\n * @retval   The faked MSR value.\n */",
                  "definition": "uint64_t\r\nxUslRdMsr (\r\n  uint32_t MsrAddress\r\n  )",
                  "implementation": "uint64_t\r\nxUslRdMsr (\r\n  uint32_t MsrAddress\r\n  )\r\n{\r\n  MSR_PAIR  *Node;\r\n  MSR_PAIR  *Parent;\r\n  uint64_t  MsrValue;\r\n\r\n  MsrValue = 0;\r\n  Node = Head;\r\n  Parent = NULL;\r\n  while (Node != NULL) {\r\n    if (Node->MsrAddress == MsrAddress) {\r\n      MsrValue = Node->MsrValue;\r\n      PruneNode (Parent, Node);\r\n      free (Node);\r\n      break;\r\n    } else {\r\n      Parent = Node;\r\n      Node = (MSR_PAIR *)Node->Next;\r\n      // If we have reached the end of the list and no match is found, fail the test.\r\n      assert_true (Node != NULL);\r\n    }\r\n  }\r\n  return MsrValue;\r\n}",
                  "range": [
                    { "line": 91, "character": 0 },
                    { "line": 117, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 92, "character": 0 },
                    { "line": 92, "character": 9 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "Head",
                        "kind": 12,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtCpuOpsFakeLib/UtCpuOpsFakeLib.c",
                        "documentation": "",
                        "definition": "MSR_PAIR *Head = NULL;",
                        "implementation": "MSR_PAIR *Head = NULL;",
                        "range": [
                          { "line": 16, "character": 0 },
                          { "line": 16, "character": 22 }
                        ],
                        "selectionRange": [
                          { "line": 16, "character": 10 },
                          { "line": 16, "character": 14 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "PruneNode",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtCpuOpsFakeLib/UtCpuOpsFakeLib.c",
                        "documentation": "/**\n * PruneNode\n *\n * @brief This function will prune a node from the linked list.\n *\n * @param Parent[in,out]  The Parent of Node\n * @param Node[in]        The Node to prune\n */",
                        "definition": "static\r\nvoid\r\nPruneNode (\r\n  MSR_PAIR  *Parent,\r\n  MSR_PAIR  *Node\r\n  )",
                        "implementation": "static\r\nvoid\r\nPruneNode (\r\n  MSR_PAIR  *Parent,\r\n  MSR_PAIR  *Node\r\n  )\r\n{\r\n  if (Head == Tail) {\r\n    // If there is only one node in the list, set Head and Tail to NULL.\r\n    Head = NULL;\r\n    Tail = NULL;\r\n    return;\r\n  } else {\r\n    if (Head == Node) {\r\n      // If the matching Node is Head, move Head to the Child Node.\r\n      Head = Node->Next;\r\n    } else if (Tail == Node) {\r\n      // If the matching Node is Tail, move Tail to the Parent node.\r\n      Tail = Parent;\r\n      Tail->Next = NULL;\r\n    } else {\r\n      Parent->Next = Node->Next;\r\n    }\r\n  }\r\n}",
                        "range": [
                          { "line": 51, "character": 0 },
                          { "line": 75, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 53, "character": 0 },
                          { "line": 53, "character": 9 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "MSR_PAIR",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Include/Library/UtCpuOpsFakeLib.h",
                              "documentation": "/**\n * @file UtCpuOpsFakeLib.h\n * @brief This header contains definitions used by UtCpuOpsFakeLib\n *\n */",
                              "definition": "typedef struct {\r\n  uint32_t  MsrAddress;\r\n  uint64_t  MsrValue;\r\n  void      *Next;\r\n} MSR_PAIR;",
                              "implementation": "typedef struct {\r\n  uint32_t  MsrAddress;\r\n  uint64_t  MsrValue;\r\n  void      *Next;\r\n} MSR_PAIR;",
                              "range": [
                                { "line": 11, "character": 0 },
                                { "line": 15, "character": 11 }
                              ],
                              "selectionRange": [
                                { "line": 15, "character": 2 },
                                { "line": 15, "character": 10 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "Head",
                              "kind": 12,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtCpuOpsFakeLib/UtCpuOpsFakeLib.c",
                              "documentation": "",
                              "definition": "MSR_PAIR *Head = NULL;",
                              "implementation": "MSR_PAIR *Head = NULL;",
                              "range": [
                                { "line": 16, "character": 0 },
                                { "line": 16, "character": 22 }
                              ],
                              "selectionRange": [
                                { "line": 16, "character": 10 },
                                { "line": 16, "character": 14 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "Tail",
                              "kind": 12,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtCpuOpsFakeLib/UtCpuOpsFakeLib.c",
                              "documentation": "/**\n * @file UtCpuOpsFakeLib.c\n * @brief This library contains fake function implementation for CpuOps nasm functions\n *\n */",
                              "definition": "MSR_PAIR *Tail = NULL;",
                              "implementation": "MSR_PAIR *Tail = NULL;",
                              "range": [
                                { "line": 15, "character": 0 },
                                { "line": 15, "character": 22 }
                              ],
                              "selectionRange": [
                                { "line": 15, "character": 10 },
                                { "line": 15, "character": 14 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      },
                      {
                        "name": "xUslRdMsr",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtCpuOpsFakeLib/UtCpuOpsFakeLib.c",
                        "documentation": "/**\n * xUslRdMsr (Fake)\n *\n * @brief    Fake function to return the value of in MSR specified in MsrAddress\n *\n * @details  The function will traverse the linked list and return the first MsrValue with the matching MsrAddress. The\n *           node will then be removed from the list. The linked list is built by the UT case using FakexUslRdMsrAdd.\n *\n * @param[in] MsrAddress - The address of the MSR to read\n *\n * @retval   The faked MSR value.\n */",
                        "definition": "uint64_t\r\nxUslRdMsr (\r\n  uint32_t MsrAddress\r\n  )",
                        "implementation": "uint64_t\r\nxUslRdMsr (\r\n  uint32_t MsrAddress\r\n  )\r\n{\r\n  MSR_PAIR  *Node;\r\n  MSR_PAIR  *Parent;\r\n  uint64_t  MsrValue;\r\n\r\n  MsrValue = 0;\r\n  Node = Head;\r\n  Parent = NULL;\r\n  while (Node != NULL) {\r\n    if (Node->MsrAddress == MsrAddress) {\r\n      MsrValue = Node->MsrValue;\r\n      PruneNode (Parent, Node);\r\n      free (Node);\r\n      break;\r\n    } else {\r\n      Parent = Node;\r\n      Node = (MSR_PAIR *)Node->Next;\r\n      // If we have reached the end of the list and no match is found, fail the test.\r\n      assert_true (Node != NULL);\r\n    }\r\n  }\r\n  return MsrValue;\r\n}",
                        "range": [
                          { "line": 91, "character": 0 },
                          { "line": 117, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 92, "character": 0 },
                          { "line": 92, "character": 9 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "MSR_PAIR",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Include/Library/UtCpuOpsFakeLib.h",
                              "documentation": "/**\n * @file UtCpuOpsFakeLib.h\n * @brief This header contains definitions used by UtCpuOpsFakeLib\n *\n */",
                              "definition": "typedef struct {\r\n  uint32_t  MsrAddress;\r\n  uint64_t  MsrValue;\r\n  void      *Next;\r\n} MSR_PAIR;",
                              "implementation": "typedef struct {\r\n  uint32_t  MsrAddress;\r\n  uint64_t  MsrValue;\r\n  void      *Next;\r\n} MSR_PAIR;",
                              "range": [
                                { "line": 11, "character": 0 },
                                { "line": 15, "character": 11 }
                              ],
                              "selectionRange": [
                                { "line": 15, "character": 2 },
                                { "line": 15, "character": 10 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "Head",
                              "kind": 12,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtCpuOpsFakeLib/UtCpuOpsFakeLib.c",
                              "documentation": "",
                              "definition": "MSR_PAIR *Head = NULL;",
                              "implementation": "MSR_PAIR *Head = NULL;",
                              "range": [
                                { "line": 16, "character": 0 },
                                { "line": 16, "character": 22 }
                              ],
                              "selectionRange": [
                                { "line": 16, "character": 10 },
                                { "line": 16, "character": 14 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      },
                      {
                        "name": "xUslRdMsr",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtCpuOpsFakeLib/UtCpuOpsFakeLib.c",
                        "documentation": "/**\n * xUslRdMsr (Fake)\n *\n * @brief    Fake function to return the value of in MSR specified in MsrAddress\n *\n * @details  The function will traverse the linked list and return the first MsrValue with the matching MsrAddress. The\n *           node will then be removed from the list. The linked list is built by the UT case using FakexUslRdMsrAdd.\n *\n * @param[in] MsrAddress - The address of the MSR to read\n *\n * @retval   The faked MSR value.\n */",
                        "definition": "uint64_t\r\nxUslRdMsr (\r\n  uint32_t MsrAddress\r\n  )",
                        "implementation": "uint64_t\r\nxUslRdMsr (\r\n  uint32_t MsrAddress\r\n  )\r\n{\r\n  MSR_PAIR  *Node;\r\n  MSR_PAIR  *Parent;\r\n  uint64_t  MsrValue;\r\n\r\n  MsrValue = 0;\r\n  Node = Head;\r\n  Parent = NULL;\r\n  while (Node != NULL) {\r\n    if (Node->MsrAddress == MsrAddress) {\r\n      MsrValue = Node->MsrValue;\r\n      PruneNode (Parent, Node);\r\n      free (Node);\r\n      break;\r\n    } else {\r\n      Parent = Node;\r\n      Node = (MSR_PAIR *)Node->Next;\r\n      // If we have reached the end of the list and no match is found, fail the test.\r\n      assert_true (Node != NULL);\r\n    }\r\n  }\r\n  return MsrValue;\r\n}",
                        "range": [
                          { "line": 91, "character": 0 },
                          { "line": 117, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 92, "character": 0 },
                          { "line": 92, "character": 9 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "MSR_PAIR",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Include/Library/UtCpuOpsFakeLib.h",
                              "documentation": "/**\n * @file UtCpuOpsFakeLib.h\n * @brief This header contains definitions used by UtCpuOpsFakeLib\n *\n */",
                              "definition": "typedef struct {\r\n  uint32_t  MsrAddress;\r\n  uint64_t  MsrValue;\r\n  void      *Next;\r\n} MSR_PAIR;",
                              "implementation": "typedef struct {\r\n  uint32_t  MsrAddress;\r\n  uint64_t  MsrValue;\r\n  void      *Next;\r\n} MSR_PAIR;",
                              "range": [
                                { "line": 11, "character": 0 },
                                { "line": 15, "character": 11 }
                              ],
                              "selectionRange": [
                                { "line": 15, "character": 2 },
                                { "line": 15, "character": 10 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "Head",
                              "kind": 12,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Library/Fakes/UtCpuOpsFakeLib/UtCpuOpsFakeLib.c",
                              "documentation": "",
                              "definition": "MSR_PAIR *Head = NULL;",
                              "implementation": "MSR_PAIR *Head = NULL;",
                              "range": [
                                { "line": 16, "character": 0 },
                                { "line": 16, "character": 22 }
                              ],
                              "selectionRange": [
                                { "line": 16, "character": 10 },
                                { "line": 16, "character": 14 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "__disable_tail_calls",
                  "kind": 12,
                  "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                  "documentation": "",
                  "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                  "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                  "range": [
                    { "line": 59, "character": 0 },
                    { "line": 59, "character": 101 }
                  ],
                  "selectionRange": [
                    { "line": 59, "character": 80 },
                    { "line": 59, "character": 100 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "xUslGetPhysAddrSize",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/CpuOps.c",
                  "documentation": "/**\n * xUslGetPhysAddrSize\n *\n * @brief Get maximum physical address size in bits.\n *\n * @details  CPUID_8000_0008_EAX[7:0] Maximum physical byte address size in bits\n *\n * @param    None\n *\n * @retval   Maximum physical address size in bits\n */",
                  "definition": "uint8_t\r\nxUslGetPhysAddrSize (void)",
                  "implementation": "uint8_t\r\nxUslGetPhysAddrSize (void)\r\n{\r\n  CPUID_DATA  Regs = {0};\r\n\r\n  xUslCpuId(AMD_CPUID_ASIZE_PCCOUNT, 0, &Regs);\r\n\r\n  return (uint8_t) (Regs.EaxReg & 0xFF);\r\n}",
                  "range": [
                    { "line": 164, "character": 0 },
                    { "line": 172, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 165, "character": 0 },
                    { "line": 165, "character": 19 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "CPUID_DATA",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/CpuLib.h",
                        "documentation": "/// CPUID data received registers format",
                        "definition": "typedef struct {\r\n  uint32_t  EaxReg;                    ///< CPUID instruction result in EAX\r\n  uint32_t  EbxReg;                    ///< CPUID instruction result in EBX\r\n  uint32_t  EcxReg;                    ///< CPUID instruction result in ECX\r\n  uint32_t  EdxReg;                    ///< CPUID instruction result in EDX\r\n} CPUID_DATA;",
                        "implementation": "typedef struct {\r\n  uint32_t  EaxReg;                    ///< CPUID instruction result in EAX\r\n  uint32_t  EbxReg;                    ///< CPUID instruction result in EBX\r\n  uint32_t  EcxReg;                    ///< CPUID instruction result in ECX\r\n  uint32_t  EdxReg;                    ///< CPUID instruction result in EDX\r\n} CPUID_DATA;",
                        "range": [
                          { "line": 32, "character": 0 },
                          { "line": 37, "character": 13 }
                        ],
                        "selectionRange": [
                          { "line": 37, "character": 2 },
                          { "line": 37, "character": 12 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "AMD_CPUID_ASIZE_PCCOUNT",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/CpuLib.h",
                        "documentation": "/// CPUID related registers",
                        "definition": "#define AMD_CPUID_ASIZE_PCCOUNT                 0x80000008ul  // Address Size, Physical Core Count",
                        "implementation": "#define AMD_CPUID_ASIZE_PCCOUNT                 0x80000008ul  // Address Size, Physical Core Count",
                        "range": [
                          { "line": 57, "character": 0 },
                          { "line": 57, "character": 98 }
                        ],
                        "selectionRange": [
                          { "line": 57, "character": 8 },
                          { "line": 57, "character": 31 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "xUslGetPhysAddrSize",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/CpuOps.c",
                        "documentation": "/**\n * xUslGetPhysAddrSize\n *\n * @brief Get maximum physical address size in bits.\n *\n * @details  CPUID_8000_0008_EAX[7:0] Maximum physical byte address size in bits\n *\n * @param    None\n *\n * @retval   Maximum physical address size in bits\n */",
                        "definition": "uint8_t\r\nxUslGetPhysAddrSize (void)",
                        "implementation": "uint8_t\r\nxUslGetPhysAddrSize (void)\r\n{\r\n  CPUID_DATA  Regs = {0};\r\n\r\n  xUslCpuId(AMD_CPUID_ASIZE_PCCOUNT, 0, &Regs);\r\n\r\n  return (uint8_t) (Regs.EaxReg & 0xFF);\r\n}",
                        "range": [
                          { "line": 164, "character": 0 },
                          { "line": 172, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 165, "character": 0 },
                          { "line": 165, "character": 19 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "CPUID_DATA",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/CpuLib.h",
                              "documentation": "/// CPUID data received registers format",
                              "definition": "typedef struct {\r\n  uint32_t  EaxReg;                    ///< CPUID instruction result in EAX\r\n  uint32_t  EbxReg;                    ///< CPUID instruction result in EBX\r\n  uint32_t  EcxReg;                    ///< CPUID instruction result in ECX\r\n  uint32_t  EdxReg;                    ///< CPUID instruction result in EDX\r\n} CPUID_DATA;",
                              "implementation": "typedef struct {\r\n  uint32_t  EaxReg;                    ///< CPUID instruction result in EAX\r\n  uint32_t  EbxReg;                    ///< CPUID instruction result in EBX\r\n  uint32_t  EcxReg;                    ///< CPUID instruction result in ECX\r\n  uint32_t  EdxReg;                    ///< CPUID instruction result in EDX\r\n} CPUID_DATA;",
                              "range": [
                                { "line": 32, "character": 0 },
                                { "line": 37, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 37, "character": 2 },
                                { "line": 37, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "AMD_CPUID_ASIZE_PCCOUNT",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/CpuLib.h",
                              "documentation": "/// CPUID related registers",
                              "definition": "#define AMD_CPUID_ASIZE_PCCOUNT                 0x80000008ul  // Address Size, Physical Core Count",
                              "implementation": "#define AMD_CPUID_ASIZE_PCCOUNT                 0x80000008ul  // Address Size, Physical Core Count",
                              "range": [
                                { "line": 57, "character": 0 },
                                { "line": 57, "character": 98 }
                              ],
                              "selectionRange": [
                                { "line": 57, "character": 8 },
                                { "line": 57, "character": 31 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "xUslGetPhysAddrReduction",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/CpuOps.c",
                  "documentation": "/**\n * xUslGetPhysAddrReduction\n *\n * @brief Get physical address bit reduction\n *\n * @details  CPUID_8000_001F_EBX[11:6] MemEncryptPhysAddWidth\n *\n * @retval   Physical address bit reduction in bits\n */",
                  "definition": "uint8_t\r\nxUslGetPhysAddrReduction (void)",
                  "implementation": "uint8_t\r\nxUslGetPhysAddrReduction (void)\r\n{\r\n  CPUID_DATA  Regs = {0};\r\n\r\n  xUslCpuId(0x8000001F, 0, &Regs);\r\n\r\n  return (uint8_t)((Regs.EbxReg >> 6) & 0x3F);\r\n}",
                  "range": [
                    { "line": 183, "character": 0 },
                    { "line": 191, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 184, "character": 0 },
                    { "line": 184, "character": 24 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "CPUID_DATA",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/CpuLib.h",
                        "documentation": "/// CPUID data received registers format",
                        "definition": "typedef struct {\r\n  uint32_t  EaxReg;                    ///< CPUID instruction result in EAX\r\n  uint32_t  EbxReg;                    ///< CPUID instruction result in EBX\r\n  uint32_t  EcxReg;                    ///< CPUID instruction result in ECX\r\n  uint32_t  EdxReg;                    ///< CPUID instruction result in EDX\r\n} CPUID_DATA;",
                        "implementation": "typedef struct {\r\n  uint32_t  EaxReg;                    ///< CPUID instruction result in EAX\r\n  uint32_t  EbxReg;                    ///< CPUID instruction result in EBX\r\n  uint32_t  EcxReg;                    ///< CPUID instruction result in ECX\r\n  uint32_t  EdxReg;                    ///< CPUID instruction result in EDX\r\n} CPUID_DATA;",
                        "range": [
                          { "line": 32, "character": 0 },
                          { "line": 37, "character": 13 }
                        ],
                        "selectionRange": [
                          { "line": 37, "character": 2 },
                          { "line": 37, "character": 12 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "xUslGetPhysAddrSize",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/CpuOps.c",
                        "documentation": "/**\n * xUslGetPhysAddrSize\n *\n * @brief Get maximum physical address size in bits.\n *\n * @details  CPUID_8000_0008_EAX[7:0] Maximum physical byte address size in bits\n *\n * @param    None\n *\n * @retval   Maximum physical address size in bits\n */",
                        "definition": "uint8_t\r\nxUslGetPhysAddrSize (void)",
                        "implementation": "uint8_t\r\nxUslGetPhysAddrSize (void)\r\n{\r\n  CPUID_DATA  Regs = {0};\r\n\r\n  xUslCpuId(AMD_CPUID_ASIZE_PCCOUNT, 0, &Regs);\r\n\r\n  return (uint8_t) (Regs.EaxReg & 0xFF);\r\n}",
                        "range": [
                          { "line": 164, "character": 0 },
                          { "line": 172, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 165, "character": 0 },
                          { "line": 165, "character": 19 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "CPUID_DATA",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/CpuLib.h",
                              "documentation": "/// CPUID data received registers format",
                              "definition": "typedef struct {\r\n  uint32_t  EaxReg;                    ///< CPUID instruction result in EAX\r\n  uint32_t  EbxReg;                    ///< CPUID instruction result in EBX\r\n  uint32_t  EcxReg;                    ///< CPUID instruction result in ECX\r\n  uint32_t  EdxReg;                    ///< CPUID instruction result in EDX\r\n} CPUID_DATA;",
                              "implementation": "typedef struct {\r\n  uint32_t  EaxReg;                    ///< CPUID instruction result in EAX\r\n  uint32_t  EbxReg;                    ///< CPUID instruction result in EBX\r\n  uint32_t  EcxReg;                    ///< CPUID instruction result in ECX\r\n  uint32_t  EdxReg;                    ///< CPUID instruction result in EDX\r\n} CPUID_DATA;",
                              "range": [
                                { "line": 32, "character": 0 },
                                { "line": 37, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 37, "character": 2 },
                                { "line": 37, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "AMD_CPUID_ASIZE_PCCOUNT",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/CpuLib.h",
                              "documentation": "/// CPUID related registers",
                              "definition": "#define AMD_CPUID_ASIZE_PCCOUNT                 0x80000008ul  // Address Size, Physical Core Count",
                              "implementation": "#define AMD_CPUID_ASIZE_PCCOUNT                 0x80000008ul  // Address Size, Physical Core Count",
                              "range": [
                                { "line": 57, "character": 0 },
                                { "line": 57, "character": 98 }
                              ],
                              "selectionRange": [
                                { "line": 57, "character": 8 },
                                { "line": 57, "character": 31 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "SilArrangeMmioAbove4G",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                  "documentation": "/**\n * SilArrangeMmioAbove4G\n *\n * @brief Try to arrange MMIO above 4G\n *\n * @param   SilContext                     A context structure through which host firmware defined data\n *                                         can be passed to openSIL. The host firmware is responsible\n *                                         for initializing the SIL_CONTEXT structure.\n * @param   SilData                        openSIL input block structure for RC manager\n *            SilData->MmioSizeForEachRb   Required MMIO size for each RootBridge\n *            SilData->SocketNumber        System socket count\n *            SilData->RbsPerSocket        RootBridge number per socket\n *            SilData->MmioRcMgr           Point to DFX_FABRIC_MMIO_MANAGER\n * @param   SpaceStatus                    Current status\n * @param   MmioBaseAddrNextRb             MmioBaseAddr for next RB, be used to check overflow\n * @param   MmioLimitAbove4G               MmioLimitAbove4G\n * @param   SetDfRegisters                 true  - Set DF MMIO registers\n *                                                false - Do Not set DF MMIO registers, just calculate if\n *                                                        user's requirement could be satisfied.\n *\n * @retval            true\n *                    false\n */",
                  "definition": "static\r\nbool\r\nSilArrangeMmioAbove4G (\r\n  SIL_CONTEXT             *SilContext,\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  FABRIC_ADDR_SPACE_SIZE  *SpaceStatus,\r\n  uint64_t                *MmioBaseAddrNextRb,\r\n  uint64_t                MmioLimitAbove4G,\r\n  bool                    SetDfRegisters\r\n  )",
                  "implementation": "static\r\nbool\r\nSilArrangeMmioAbove4G (\r\n  SIL_CONTEXT             *SilContext,\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  FABRIC_ADDR_SPACE_SIZE  *SpaceStatus,\r\n  uint64_t                *MmioBaseAddrNextRb,\r\n  uint64_t                MmioLimitAbove4G,\r\n  bool                    SetDfRegisters\r\n  )\r\n{\r\n  uint8_t  i;\r\n  uint8_t  j;\r\n  uint8_t  SktLoop;\r\n  uint8_t  RbLoop;\r\n  uint64_t MmioBaseAddr;\r\n  uint64_t MmioBaseAddrPrefetchable;\r\n  uint64_t MmioBaseAddrNonPrefetchable;\r\n  uint64_t MmioBaseAddrNonPci;\r\n  uint64_t SizePrefetchable;\r\n  uint64_t SizeNonPrefetchable;\r\n  uint64_t SizeNonPciAbove4G;\r\n  uint64_t AlignMask;\r\n  uint64_t AlignMaskP;\r\n  uint64_t AlignMaskNonPci;\r\n  bool EnoughSpaceAbove4G;\r\n  bool BigAlignFirst;\r\n  FABRIC_MMIO_ABOVE_4G_QUEUE  MmioQueue[MMIO_QUEUE_SIZE];\r\n  FABRIC_MMIO_ABOVE_4G_QUEUE  Temp;\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB *MmioSizeForEachRb;\r\n  DFX_FABRIC_MMIO_MANAGER *FabricMmioManager;\r\n  DF_IP2IP_API            *DfIp2IpApi;\r\n  SIL_STATUS              Status;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  assert(Status == SilPass);\r\n\r\n  FabricMmioManager = &SilData->MmioRcMgr;\r\n  MmioSizeForEachRb = &SilData->ResourceSizeForEachRb;\r\n\r\n  EnoughSpaceAbove4G = true;\r\n  BigAlignFirst = true;\r\n  AlignMaskNonPci = RCMGR_NON_PCI_MMIO_ALIGN_MASK_ABOVE4G;\r\n  MmioBaseAddrPrefetchable = 0;\r\n  MmioBaseAddrNonPrefetchable = 0;\r\n  MmioBaseAddrNonPci = 0;\r\n  SizePrefetchable = 0;\r\n  SizeNonPrefetchable = 0;\r\n  SizeNonPciAbove4G = (SilData->Above4GMmioSizePerRbForNonPciDevice > MMIO_MIN_NON_PCI_SIZE_ABOVE4G) ?\r\n    SilData->Above4GMmioSizePerRbForNonPciDevice : MMIO_MIN_NON_PCI_SIZE_ABOVE4G;\r\n  RCMGR_TRACEPOINT(SIL_TRACE_INFO, \" # of sockets %d, RB per skt %d\\n\", SilData->SocketNumber, SilData->RbsPerSocket);\r\n  for (SktLoop = 0; SktLoop < SilData->SocketNumber; SktLoop++) {\r\n    for (RbLoop = 0; RbLoop < SilData->RbsPerSocket; RbLoop++) {\r\n      // Calculate required size, it's for output parameter 'SpaceStatus'\r\n      if (SpaceStatus != NULL) {\r\n        SpaceStatus->MmioSizeAbove4G +=\r\n          MmioSizeForEachRb->PrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Size +\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Size;\r\n        SpaceStatus->MmioSizeBelow4G +=\r\n          (uint32_t) (MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SktLoop][RbLoop].Size +\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SktLoop][RbLoop].Size);\r\n      }\r\n\r\n      // If there's no MMIO request for above 4G, try next one\r\n      if ((MmioSizeForEachRb->NonPrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Size +\r\n        MmioSizeForEachRb->PrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Size + SizeNonPciAbove4G) == 0) {\r\n        continue;\r\n      }\r\n\r\n      AlignMask = MmioSizeForEachRb->NonPrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Alignment;\r\n      AlignMaskP = MmioSizeForEachRb->PrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Alignment;\r\n      MmioBaseAddr = *MmioBaseAddrNextRb;\r\n\r\n      // default sequence should be Non Pci -> Prefetchable -> Non Prefetchable\r\n      // this would match the sequence used in FabricInitMmioEqually3 ()\r\n      i = 0;\r\n      MmioQueue[i].MmioType = NON_PCI_DEVICE_ABOVE_4G;\r\n      MmioQueue[i++].AlignBit = AlignMaskNonPci;\r\n      MmioQueue[i].MmioType = P_MMIO_ABOVE_4G;\r\n      MmioQueue[i++].AlignBit = AlignMaskP;\r\n      MmioQueue[i].MmioType = MMIO_ABOVE_4G;\r\n      MmioQueue[i++].AlignBit = AlignMask;\r\n      assert(i <= MMIO_QUEUE_SIZE);\r\n\r\n      if (BigAlignFirst) {\r\n        // MmioQueue[0] has the biggest align bit\r\n        for (i = 0; i < MMIO_QUEUE_SIZE; i++) {\r\n          for (j = 0; j < (MMIO_QUEUE_SIZE - i - 1); j++) {\r\n            if (MmioQueue[j].AlignBit < MmioQueue[j + 1].AlignBit) {\r\n              Temp = MmioQueue[j + 1];\r\n              MmioQueue[j + 1] = MmioQueue[j];\r\n              MmioQueue[j] = Temp;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        // MmioQueue[0] has the smallest align bit (except align bit = 0)\r\n        // always put MMIO region whose align bit is 0 on high address\r\n        // this would match the algorithm used in FabricInitMmioEqually3 ()\r\n        for (i = 0; i < MMIO_QUEUE_SIZE; i++) {\r\n          for (j = 0; j < (MMIO_QUEUE_SIZE - i - 1); j++) {\r\n            if (((MmioQueue[j].AlignBit > MmioQueue[j + 1].AlignBit) || (MmioQueue[j].AlignBit == 0)) &&\r\n              (MmioQueue[j + 1].AlignBit != 0)) {\r\n              Temp = MmioQueue[j + 1];\r\n              MmioQueue[j + 1] = MmioQueue[j];\r\n              MmioQueue[j] = Temp;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      BigAlignFirst = !BigAlignFirst;\r\n\r\n      MmioBaseAddr = *MmioBaseAddrNextRb;\r\n      for (i = 0; i < MMIO_QUEUE_SIZE; i++) {\r\n        switch (MmioQueue[i].MmioType) {\r\n        case MMIO_ABOVE_4G:\r\n          MmioBaseAddrNonPrefetchable = (*MmioBaseAddrNextRb + AlignMask) & (~AlignMask);\r\n          SizeNonPrefetchable = MmioSizeForEachRb->NonPrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Size;\r\n          *MmioBaseAddrNextRb = MmioBaseAddrNonPrefetchable + SizeNonPrefetchable;\r\n          break;\r\n        case P_MMIO_ABOVE_4G:\r\n          MmioBaseAddrPrefetchable = (*MmioBaseAddrNextRb + AlignMaskP) & (~AlignMaskP);\r\n          SizePrefetchable = MmioSizeForEachRb->PrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Size;\r\n          *MmioBaseAddrNextRb = MmioBaseAddrPrefetchable + SizePrefetchable;\r\n          break;\r\n        case NON_PCI_DEVICE_ABOVE_4G:\r\n          MmioBaseAddrNonPci = (*MmioBaseAddrNextRb + AlignMaskNonPci) & (~AlignMaskNonPci);\r\n          *MmioBaseAddrNextRb = MmioBaseAddrNonPci + SizeNonPciAbove4G;\r\n          break;\r\n        default:\r\n          assert(false);\r\n          break;\r\n        };\r\n      }\r\n\r\n      if (SizeNonPrefetchable == 0) {\r\n        MmioBaseAddrNonPrefetchable = 0;\r\n      }\r\n      if (SizePrefetchable == 0) {\r\n        MmioBaseAddrPrefetchable = 0;\r\n      }\r\n\r\n      // Check if space is enough\r\n      if (*MmioBaseAddrNextRb > MmioLimitAbove4G) {\r\n        EnoughSpaceAbove4G = false;\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"  Insufficient space for MMIO above 4GB.\\n\");\r\n      }\r\n\r\n      if (SetDfRegisters && EnoughSpaceAbove4G && (FabricMmioManager != NULL)) {\r\n        //   Set MMIO above 4G\r\n        if ((MmioSizeForEachRb->NonPrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Size == 0) &&\r\n          (MmioSizeForEachRb->PrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Size == 0) &&\r\n          (SizeNonPciAbove4G == 0)) {\r\n          continue;\r\n        }\r\n\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"---Socket%x RootBridge%x---\\n\", SktLoop, RbLoop);\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"  Request above 4G\\n\");\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n          \"        Prefetch Size 0x%llX, AlignBit 0x%X\\n\",\r\n          MmioSizeForEachRb->PrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Size,\r\n          MmioSizeForEachRb->PrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Alignment\r\n          );\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n          \"    Non Prefetch Size 0x%llX, AlignBit 0x%X\\n\\n\",\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Size,\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Alignment\r\n          );\r\n        Status = SilSetMmioReg4(SilContext,\r\n          DfIp2IpApi,\r\n          SilData->SocketNumber,\r\n          ((SktLoop * SilData->RbsPerSocket + RbLoop) * 2 + 1),\r\n          SktLoop,\r\n          RbLoop,\r\n          MmioBaseAddr,\r\n          (*MmioBaseAddrNextRb - MmioBaseAddr)\r\n          );\r\n        FabricMmioManager->AllocateMmioAbove4GOnThisRb[SktLoop][RbLoop] = true;\r\n        FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].BaseNonPci = MmioBaseAddrNonPci;  // No Non Pci MMIO >4G\r\n        FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].BasePrefetch = MmioBaseAddrPrefetchable;\r\n        FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].BaseNonPrefetch = MmioBaseAddrNonPrefetchable;\r\n        FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].SizeNonPci = SizeNonPciAbove4G;\r\n        FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].SizePrefetch = SizePrefetchable;\r\n        FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].SizeNonPrefetch = SizeNonPrefetchable;\r\n        FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].UsedSizeNonPci = 0;\r\n        FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].UsedSizePrefetch = 0;\r\n        FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].UsedSizeNonPrefetch = 0;\r\n        FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].AlignNonPrefetch =\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Alignment;\r\n        FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].AlignPrefetch =\r\n          MmioSizeForEachRb->PrefetchableMmioSizeAbove4G[SktLoop][RbLoop].Alignment;\r\n\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n          \"    NonPci      0x%llX ~ 0x%llX, Size 0x%llX\\n\",\r\n          FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].BaseNonPci,\r\n          (FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].BaseNonPci +\r\n          FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].SizeNonPci),\r\n          FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].SizeNonPci\r\n          );\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n          \"    Prefetch    0x%llX ~ 0x%llX, Size 0x%llX\\n\",\r\n          FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].BasePrefetch,\r\n          (FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].BasePrefetch +\r\n          FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].SizePrefetch),\r\n          FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].SizePrefetch\r\n          );\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n          \"    NonPrefetch 0x%llX ~ 0x%llX, Size 0x%llX\\n\\n\",\r\n          FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].BaseNonPrefetch,\r\n          (FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].BaseNonPrefetch +\r\n          FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].SizeNonPrefetch),\r\n          FabricMmioManager->MmioRegionAbove4G[SktLoop][RbLoop].SizeNonPrefetch\r\n          );\r\n      }\r\n    }\r\n  }\r\n\r\n  return EnoughSpaceAbove4G;\r\n}",
                  "range": [
                    { "line": 987, "character": 0 },
                    { "line": 1205, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 989, "character": 0 },
                    { "line": 989, "character": 21 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "SIL_CONTEXT",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                        "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                        "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "range": [
                          { "line": 131, "character": 0 },
                          { "line": 135, "character": 14 }
                        ],
                        "selectionRange": [
                          { "line": 135, "character": 2 },
                          { "line": 135, "character": 13 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DFX_RCMGR_INPUT_BLK",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                        "documentation": "",
                        "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                        "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                        "range": [
                          { "line": 124, "character": 0 },
                          { "line": 143, "character": 22 }
                        ],
                        "selectionRange": [
                          { "line": 143, "character": 2 },
                          { "line": 143, "character": 21 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "FABRIC_ADDR_SPACE_SIZE",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                        "documentation": "/// Current status",
                        "definition": "typedef struct _FABRIC_ADDR_SPACE_SIZE {\r\n  uint32_t  IoSize;                ///< IO size required by system resources\r\n  uint32_t  IoSizeReqInc;          ///< The amount needed over the current size\r\n  uint32_t  MmioSizeBelow4G;       ///< Below 4G Mmio size required by system resources\r\n  uint32_t  MmioSizeBelow4GReqInc; ///< The amount needed over the current size\r\n  uint64_t  MmioSizeAbove4G;       ///< Above 4G Mmio size required by system resources\r\n  uint64_t  MmioSizeAbove4GReqInc; ///< The amount needed over the current size\r\n} FABRIC_ADDR_SPACE_SIZE;",
                        "implementation": "typedef struct _FABRIC_ADDR_SPACE_SIZE {\r\n  uint32_t  IoSize;                ///< IO size required by system resources\r\n  uint32_t  IoSizeReqInc;          ///< The amount needed over the current size\r\n  uint32_t  MmioSizeBelow4G;       ///< Below 4G Mmio size required by system resources\r\n  uint32_t  MmioSizeBelow4GReqInc; ///< The amount needed over the current size\r\n  uint64_t  MmioSizeAbove4G;       ///< Above 4G Mmio size required by system resources\r\n  uint64_t  MmioSizeAbove4GReqInc; ///< The amount needed over the current size\r\n} FABRIC_ADDR_SPACE_SIZE;",
                        "range": [
                          { "line": 45, "character": 0 },
                          { "line": 52, "character": 25 }
                        ],
                        "selectionRange": [
                          { "line": 52, "character": 2 },
                          { "line": 52, "character": 24 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "FABRIC_MMIO_ABOVE_4G_QUEUE",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcManagerDfX.h",
                        "documentation": "/// MMIO ABOVE 4G",
                        "definition": "typedef struct _FABRIC_MMIO_ABOVE_4G_QUEUE {\r\n  uint8_t  MmioType;\r\n  uint64_t AlignBit;\r\n} FABRIC_MMIO_ABOVE_4G_QUEUE;",
                        "implementation": "typedef struct _FABRIC_MMIO_ABOVE_4G_QUEUE {\r\n  uint8_t  MmioType;\r\n  uint64_t AlignBit;\r\n} FABRIC_MMIO_ABOVE_4G_QUEUE;",
                        "range": [
                          { "line": 18, "character": 0 },
                          { "line": 21, "character": 29 }
                        ],
                        "selectionRange": [
                          { "line": 21, "character": 2 },
                          { "line": 21, "character": 28 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "MMIO_QUEUE_SIZE",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                        "documentation": "/**\n * @file  FabricRcInit.c\n * @brief Fabric MMIO initialization based on NV variable for DFX\n *\n */",
                        "definition": "#define MMIO_QUEUE_SIZE 3",
                        "implementation": "#define MMIO_QUEUE_SIZE 3",
                        "range": [
                          { "line": 22, "character": 0 },
                          { "line": 22, "character": 25 }
                        ],
                        "selectionRange": [
                          { "line": 22, "character": 8 },
                          { "line": 22, "character": 23 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DFX_FABRIC_RESOURCE_FOR_EACH_RB",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                        "documentation": "/// Resource for each RootBridge",
                        "definition": "typedef struct {\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondNonPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  IO[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  uint16_t              PciBusNumber[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n} DFX_FABRIC_RESOURCE_FOR_EACH_RB;",
                        "implementation": "typedef struct {\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondNonPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  IO[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  uint16_t              PciBusNumber[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n} DFX_FABRIC_RESOURCE_FOR_EACH_RB;",
                        "range": [
                          { "line": 74, "character": 0 },
                          { "line": 83, "character": 34 }
                        ],
                        "selectionRange": [
                          { "line": 83, "character": 2 },
                          { "line": 83, "character": 33 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DFX_FABRIC_MMIO_MANAGER",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                        "documentation": "",
                        "definition": "typedef struct {\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  bool    AllocateMmioAbove4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO above 4G?\r\n  bool    AllocateMmioBelow4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO below 4G?\r\n  bool    PrimaryRbHas2ndMmioBelow4G;                                               ///< Indicate if RootBridge 0 has a 2nd MMIO which is below 4G\r\n  bool    ReportToGcd;                                                              ///< TRUE - Need to report GCD if user call FabricAllocateMmio\r\n  uint8_t PrimaryRb2ndMmioPairBelow4G;                                              ///< Since AllocateMmioOnThisRootBridge[i][j] is FALSE, use this one for\r\n                                                                                    ///< RootBridge0's 2nd MMIO, RootBridge02ndMmioPair = (i << 4) | j\r\n  uint64_t  Reserved;                                                               ///< compatibility (ImageHandle)\r\n} DFX_FABRIC_MMIO_MANAGER;",
                        "implementation": "typedef struct {\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  bool    AllocateMmioAbove4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO above 4G?\r\n  bool    AllocateMmioBelow4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO below 4G?\r\n  bool    PrimaryRbHas2ndMmioBelow4G;                                               ///< Indicate if RootBridge 0 has a 2nd MMIO which is below 4G\r\n  bool    ReportToGcd;                                                              ///< TRUE - Need to report GCD if user call FabricAllocateMmio\r\n  uint8_t PrimaryRb2ndMmioPairBelow4G;                                              ///< Since AllocateMmioOnThisRootBridge[i][j] is FALSE, use this one for\r\n                                                                                    ///< RootBridge0's 2nd MMIO, RootBridge02ndMmioPair = (i << 4) | j\r\n  uint64_t  Reserved;                                                               ///< compatibility (ImageHandle)\r\n} DFX_FABRIC_MMIO_MANAGER;",
                        "range": [
                          { "line": 100, "character": 0 },
                          { "line": 110, "character": 26 }
                        ],
                        "selectionRange": [
                          { "line": 110, "character": 2 },
                          { "line": 110, "character": 25 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DF_IP2IP_API",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                        "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                        "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                        "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                        "range": [
                          { "line": 199, "character": 0 },
                          { "line": 226, "character": 15 }
                        ],
                        "selectionRange": [
                          { "line": 226, "character": 2 },
                          { "line": 226, "character": 14 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_STATUS",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                        "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                        "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "range": [
                          { "line": 49, "character": 0 },
                          { "line": 74, "character": 13 }
                        ],
                        "selectionRange": [
                          { "line": 74, "character": 2 },
                          { "line": 74, "character": 12 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "RCMGR_NON_PCI_MMIO_ALIGN_MASK_ABOVE4G",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                        "documentation": "",
                        "definition": "#define RCMGR_NON_PCI_MMIO_ALIGN_MASK_ABOVE4G  0xFFFFFFFull // MMIO for non-PCI devices should be 256MB aligned",
                        "implementation": "#define RCMGR_NON_PCI_MMIO_ALIGN_MASK_ABOVE4G  0xFFFFFFFull // MMIO for non-PCI devices should be 256MB aligned",
                        "range": [
                          { "line": 27, "character": 0 },
                          { "line": 27, "character": 111 }
                        ],
                        "selectionRange": [
                          { "line": 27, "character": 8 },
                          { "line": 27, "character": 45 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "MMIO_MIN_NON_PCI_SIZE_ABOVE4G",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                        "documentation": "",
                        "definition": "#define MMIO_MIN_NON_PCI_SIZE_ABOVE4G       0x20200000      // 514MB is the minimum size of NonPci MMIO pool",
                        "implementation": "#define MMIO_MIN_NON_PCI_SIZE_ABOVE4G       0x20200000      // 514MB is the minimum size of NonPci MMIO pool",
                        "range": [
                          { "line": 28, "character": 0 },
                          { "line": 28, "character": 108 }
                        ],
                        "selectionRange": [
                          { "line": 28, "character": 8 },
                          { "line": 28, "character": 37 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "RCMGR_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                        "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
                        "definition": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                        "implementation": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                        "range": [
                          { "line": 18, "character": 0 },
                          { "line": 23, "character": 19 }
                        ],
                        "selectionRange": [
                          { "line": 18, "character": 8 },
                          { "line": 18, "character": 24 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_TRACE_INFO",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                        "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                        "definition": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                        "implementation": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                        "range": [
                          { "line": 104, "character": 0 },
                          { "line": 104, "character": 118 }
                        ],
                        "selectionRange": [
                          { "line": 104, "character": 8 },
                          { "line": 104, "character": 22 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "NON_PCI_DEVICE_ABOVE_4G",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/RcMgrIp2Ip.h",
                        "documentation": "/// Alignment",
                        "definition": "#define NON_PCI_DEVICE_ABOVE_4G    5 // For non-discoverable devices, such as IO APIC, GPIO, MP0/1 mailbox, IOMMU...",
                        "implementation": "#define NON_PCI_DEVICE_ABOVE_4G    5 // For non-discoverable devices, such as IO APIC, GPIO, MP0/1 mailbox, IOMMU...",
                        "range": [
                          { "line": 30, "character": 0 },
                          { "line": 30, "character": 116 }
                        ],
                        "selectionRange": [
                          { "line": 30, "character": 8 },
                          { "line": 30, "character": 31 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "P_MMIO_ABOVE_4G",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/RcMgrIp2Ip.h",
                        "documentation": "/// Alignment",
                        "definition": "#define P_MMIO_ABOVE_4G            3 // Prefetchable MMIO",
                        "implementation": "#define P_MMIO_ABOVE_4G            3 // Prefetchable MMIO",
                        "range": [
                          { "line": 28, "character": 0 },
                          { "line": 28, "character": 57 }
                        ],
                        "selectionRange": [
                          { "line": 28, "character": 8 },
                          { "line": 28, "character": 23 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "MMIO_ABOVE_4G",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/RcMgrIp2Ip.h",
                        "documentation": "/// Alignment",
                        "definition": "#define MMIO_ABOVE_4G              1 // Non-Prefetchable MMIO",
                        "implementation": "#define MMIO_ABOVE_4G              1 // Non-Prefetchable MMIO",
                        "range": [
                          { "line": 26, "character": 0 },
                          { "line": 26, "character": 61 }
                        ],
                        "selectionRange": [
                          { "line": 26, "character": 8 },
                          { "line": 26, "character": 21 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SilGetIp2IpApi",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                        "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                        "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                        "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                        "range": [
                          { "line": 190, "character": 0 },
                          { "line": 219, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 191, "character": 0 },
                          { "line": 191, "character": 14 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "SIL_STATUS",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                              "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                              "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "range": [
                                { "line": 49, "character": 0 },
                                { "line": 74, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 74, "character": 2 },
                                { "line": 74, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_CONTEXT",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                              "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "range": [
                                { "line": 131, "character": 0 },
                                { "line": 135, "character": 14 }
                              ],
                              "selectionRange": [
                                { "line": 135, "character": 2 },
                                { "line": 135, "character": 13 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_DATA_BLOCK_ID",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                              "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                              "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                              "range": [
                                { "line": 48, "character": 0 },
                                { "line": 73, "character": 20 }
                              ],
                              "selectionRange": [
                                { "line": 73, "character": 2 },
                                { "line": 73, "character": 19 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_BLOCK_VARIABLES",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                              "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                              "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                              "range": [
                                { "line": 182, "character": 0 },
                                { "line": 193, "character": 22 }
                              ],
                              "selectionRange": [
                                { "line": 193, "character": 2 },
                                { "line": 193, "character": 21 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_TRACE_ERROR",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                              "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                              "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                              "range": [
                                { "line": 100, "character": 0 },
                                { "line": 100, "character": 87 }
                              ],
                              "selectionRange": [
                                { "line": 100, "character": 8 },
                                { "line": 100, "character": 23 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "__disable_tail_calls",
                              "kind": 12,
                              "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                              "documentation": "",
                              "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "range": [
                                { "line": 59, "character": 0 },
                                { "line": 59, "character": 101 }
                              ],
                              "selectionRange": [
                                { "line": 59, "character": 80 },
                                { "line": 59, "character": 100 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      },
                      {
                        "name": "__disable_tail_calls",
                        "kind": 12,
                        "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                        "documentation": "",
                        "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "range": [
                          { "line": 59, "character": 0 },
                          { "line": 59, "character": 101 }
                        ],
                        "selectionRange": [
                          { "line": 59, "character": 80 },
                          { "line": 59, "character": 100 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SilSetMmioReg4",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                        "documentation": "/**\n * SilSetMmioReg4\n *\n * @brief Set MMIO register pairs according to input parameters\n *\n * @param   SilContext      A context structure through which host firmware defined data\n *                          can be passed to openSIL. The host firmware is responsible\n *                          for initializing the SIL_CONTEXT structure.\n * @param   DfIp2IpApi      A pointer to the data fabric I2I api\n * @param   TotalSocket     System socket count\n * @param   MmioPairIndex   Which MMIO register pair should be set\n * @param   SktNum          Socket number\n * @param   RbNum           Root bridge number\n * @param   BaseAddress     Base address of MMIO region\n * @param   Length          Length of MMIO region\n *\n */",
                        "definition": "SIL_STATUS\r\nSilSetMmioReg4 (\r\n  SIL_CONTEXT                   *SilContext,\r\n  DF_IP2IP_API                  *DfIp2IpApi,\r\n  uint8_t                       TotalSocket,\r\n  uint8_t                       MmioPairIndex,\r\n  uint32_t                      SktNum,\r\n  uint32_t                      RbNum,\r\n  uint64_t                      BaseAddress,\r\n  uint64_t                      Length\r\n  )",
                        "implementation": "SIL_STATUS\r\nSilSetMmioReg4 (\r\n  SIL_CONTEXT                   *SilContext,\r\n  DF_IP2IP_API                  *DfIp2IpApi,\r\n  uint8_t                       TotalSocket,\r\n  uint8_t                       MmioPairIndex,\r\n  uint32_t                      SktNum,\r\n  uint32_t                      RbNum,\r\n  uint64_t                      BaseAddress,\r\n  uint64_t                      Length\r\n  )\r\n{\r\n  uint32_t            DiePerSkt;\r\n  SIL_STATUS          Status;\r\n  APOB_SOC_DIE_INFO   SocMaxDieInfo;\r\n  APOB_IP2IP_API      *ApobIp2IpApi;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_ApobClass, (void **) &ApobIp2IpApi);\r\n  if ((Status != SilPass) || (ApobIp2IpApi == NULL)) {\r\n    assert(Status == SilPass);\r\n  } else {\r\n    ApobIp2IpApi->ApobGetMaxDieInfo(SilContext, &SocMaxDieInfo);\r\n    assert(Length >= RCMGR_MMIO_MIN_SIZE);\r\n    BaseAddress = (BaseAddress + 0xFFFF) & 0xFFFFFFFFFFFF0000;\r\n\r\n    DiePerSkt = DfIp2IpApi->DfGetNumberOfDiesOnSocket(SilContext, SktNum);\r\n    if (DiePerSkt <= SocMaxDieInfo.MaxSocDiesPerSocketValue) {\r\n      for (uint32_t i = 0; i < TotalSocket; i++) {\r\n        for (uint32_t j = 0; j < DiePerSkt; j++) {\r\n          DfIp2IpApi->DfFabricRegisterAccWrite(SilContext,\r\n            i,\r\n            j,\r\n            MMIOBASEADDRESS_0_FUNC,\r\n            (MMIOBASEADDRESS_0_REG + MmioPairIndex * (MMIOBASEADDRESS_1_REG - MMIOBASEADDRESS_0_REG)),\r\n            FABRIC_REG_ACC_BC,\r\n            (uint32_t) (BaseAddress >> 16)\r\n            );\r\n          DfIp2IpApi->DfFabricRegisterAccWrite(SilContext,\r\n            i,\r\n            j,\r\n            MMIOLIMITADDRESS_0_FUNC,\r\n            (MMIOLIMITADDRESS_0_REG + MmioPairIndex * (MMIOLIMITADDRESS_1_REG - MMIOLIMITADDRESS_0_REG)),\r\n            FABRIC_REG_ACC_BC,\r\n            (uint32_t) ((BaseAddress + Length - 1) >> 16)\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_RE,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            1,\r\n            0\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_WE,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            1,\r\n            0\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_DstFabricID,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            (uint32_t) DfIp2IpApi->DfGetHostBridgeSystemFabricID(SilContext, SktNum, 0, RbNum),\r\n            0\r\n            );\r\n        }\r\n      }\r\n    }\r\n\r\n    Status = SilPass;\r\n  }\r\n\r\n  return Status;\r\n}",
                        "range": [
                          { "line": 1594, "character": 0 },
                          { "line": 1680, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 1595, "character": 0 },
                          { "line": 1595, "character": 14 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "SIL_STATUS",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                              "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                              "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "range": [
                                { "line": 49, "character": 0 },
                                { "line": 74, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 74, "character": 2 },
                                { "line": 74, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_CONTEXT",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                              "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "range": [
                                { "line": 131, "character": 0 },
                                { "line": 135, "character": 14 }
                              ],
                              "selectionRange": [
                                { "line": 135, "character": 2 },
                                { "line": 135, "character": 13 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "DF_IP2IP_API",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                              "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                              "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                              "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                              "range": [
                                { "line": 199, "character": 0 },
                                { "line": 226, "character": 15 }
                              ],
                              "selectionRange": [
                                { "line": 226, "character": 2 },
                                { "line": 226, "character": 14 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "APOB_SOC_DIE_INFO",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/Common/ApobCmn.h",
                              "documentation": "/**\n * @brief AMD APOB_SOC_DIE_INFO\n *\n */",
                              "definition": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                              "implementation": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                              "range": [
                                { "line": 544, "character": 0 },
                                { "line": 552, "character": 20 }
                              ],
                              "selectionRange": [
                                { "line": 552, "character": 2 },
                                { "line": 552, "character": 19 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "APOB_IP2IP_API",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/ApobIp2Ip.h",
                              "documentation": "",
                              "definition": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                              "implementation": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                              "range": [
                                { "line": 105, "character": 0 },
                                { "line": 119, "character": 17 }
                              ],
                              "selectionRange": [
                                { "line": 119, "character": 2 },
                                { "line": 119, "character": 16 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "RCMGR_MMIO_MIN_SIZE",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                              "documentation": "",
                              "definition": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                              "implementation": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                              "range": [
                                { "line": 25, "character": 0 },
                                { "line": 25, "character": 53 }
                              ],
                              "selectionRange": [
                                { "line": 25, "character": 8 },
                                { "line": 25, "character": 27 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "MMIOBASEADDRESS_0_FUNC",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "",
                              "definition": "#define MMIOBASEADDRESS_0_FUNC 0x0",
                              "implementation": "#define MMIOBASEADDRESS_0_FUNC 0x0",
                              "range": [
                                { "line": 149, "character": 0 },
                                { "line": 149, "character": 34 }
                              ],
                              "selectionRange": [
                                { "line": 149, "character": 8 },
                                { "line": 149, "character": 30 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "MMIOBASEADDRESS_0_REG",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "",
                              "definition": "#define MMIOBASEADDRESS_0_REG  0xD80",
                              "implementation": "#define MMIOBASEADDRESS_0_REG  0xD80",
                              "range": [
                                { "line": 150, "character": 0 },
                                { "line": 150, "character": 36 }
                              ],
                              "selectionRange": [
                                { "line": 150, "character": 8 },
                                { "line": 150, "character": 29 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "MMIOBASEADDRESS_1_REG",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "",
                              "definition": "#define MMIOBASEADDRESS_1_REG  0xD90",
                              "implementation": "#define MMIOBASEADDRESS_1_REG  0xD90",
                              "range": [
                                { "line": 152, "character": 0 },
                                { "line": 152, "character": 36 }
                              ],
                              "selectionRange": [
                                { "line": 152, "character": 8 },
                                { "line": 152, "character": 29 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "FABRIC_REG_ACC_BC",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/FabricRegisterAccCmn.h",
                              "documentation": "/**\n * @file  FabricRegisterAccCmn.h\n * @brief Common definitions for Df fabric register access\n *\n */",
                              "definition": "#define FABRIC_REG_ACC_BC    (0xFFFFFFFF)",
                              "implementation": "#define FABRIC_REG_ACC_BC    (0xFFFFFFFF)",
                              "range": [
                                { "line": 12, "character": 0 },
                                { "line": 12, "character": 41 }
                              ],
                              "selectionRange": [
                                { "line": 12, "character": 8 },
                                { "line": 12, "character": 25 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "MMIOLIMITADDRESS_0_FUNC",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "",
                              "definition": "#define MMIOLIMITADDRESS_0_FUNC 0x0",
                              "implementation": "#define MMIOLIMITADDRESS_0_FUNC 0x0",
                              "range": [
                                { "line": 154, "character": 0 },
                                { "line": 154, "character": 35 }
                              ],
                              "selectionRange": [
                                { "line": 154, "character": 8 },
                                { "line": 154, "character": 31 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "MMIOLIMITADDRESS_0_REG",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "",
                              "definition": "#define MMIOLIMITADDRESS_0_REG  0xD84",
                              "implementation": "#define MMIOLIMITADDRESS_0_REG  0xD84",
                              "range": [
                                { "line": 155, "character": 0 },
                                { "line": 155, "character": 37 }
                              ],
                              "selectionRange": [
                                { "line": 155, "character": 8 },
                                { "line": 155, "character": 30 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "MMIOLIMITADDRESS_1_REG",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "",
                              "definition": "#define MMIOLIMITADDRESS_1_REG  0xD94",
                              "implementation": "#define MMIOLIMITADDRESS_1_REG  0xD94",
                              "range": [
                                { "line": 157, "character": 0 },
                                { "line": 157, "character": 37 }
                              ],
                              "selectionRange": [
                                { "line": 157, "character": 8 },
                                { "line": 157, "character": 30 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "DF_ABSTRACT_REG_WRITE",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "// Registers that are not supported in a specific program in register abstraction",
                              "definition": "#define DF_ABSTRACT_REG_WRITE  1",
                              "implementation": "#define DF_ABSTRACT_REG_WRITE  1",
                              "range": [
                                { "line": 90, "character": 0 },
                                { "line": 90, "character": 32 }
                              ],
                              "selectionRange": [
                                { "line": 90, "character": 8 },
                                { "line": 90, "character": 29 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SilGetIp2IpApi",
                              "kind": 11,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                              "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                              "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                              "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                              "range": [
                                { "line": 190, "character": 0 },
                                { "line": 219, "character": 1 }
                              ],
                              "selectionRange": [
                                { "line": 191, "character": 0 },
                                { "line": 191, "character": 14 }
                              ],
                              "dependencies": {
                                "callTree": [
                                  {
                                    "name": "SIL_STATUS",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                    "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                    "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "range": [
                                      { "line": 49, "character": 0 },
                                      { "line": 74, "character": 13 }
                                    ],
                                    "selectionRange": [
                                      { "line": 74, "character": 2 },
                                      { "line": 74, "character": 12 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_CONTEXT",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                    "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "range": [
                                      { "line": 131, "character": 0 },
                                      { "line": 135, "character": 14 }
                                    ],
                                    "selectionRange": [
                                      { "line": 135, "character": 2 },
                                      { "line": 135, "character": 13 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_DATA_BLOCK_ID",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                                    "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                    "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                    "range": [
                                      { "line": 48, "character": 0 },
                                      { "line": 73, "character": 20 }
                                    ],
                                    "selectionRange": [
                                      { "line": 73, "character": 2 },
                                      { "line": 73, "character": 19 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_BLOCK_VARIABLES",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                    "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                                    "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                    "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                    "range": [
                                      { "line": 182, "character": 0 },
                                      { "line": 193, "character": 22 }
                                    ],
                                    "selectionRange": [
                                      { "line": 193, "character": 2 },
                                      { "line": 193, "character": 21 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_TRACE_ERROR",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                    "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                                    "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                    "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                    "range": [
                                      { "line": 100, "character": 0 },
                                      { "line": 100, "character": 87 }
                                    ],
                                    "selectionRange": [
                                      { "line": 100, "character": 8 },
                                      { "line": 100, "character": 23 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "__disable_tail_calls",
                                    "kind": 12,
                                    "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                    "documentation": "",
                                    "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "range": [
                                      { "line": 59, "character": 0 },
                                      { "line": 59, "character": 101 }
                                    ],
                                    "selectionRange": [
                                      { "line": 59, "character": 80 },
                                      { "line": 59, "character": 100 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "__disable_tail_calls",
                              "kind": 12,
                              "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                              "documentation": "",
                              "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "range": [
                                { "line": 59, "character": 0 },
                                { "line": 59, "character": 101 }
                              ],
                              "selectionRange": [
                                { "line": 59, "character": 80 },
                                { "line": 59, "character": 100 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "SilGetPrimaryRb",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricRcInit.c",
                  "documentation": "/**\n * SilGetPrimaryRb\n *\n * @brief Returns primary RB socket number and RB number\n *\n * @param   SilContext          A context structure through which host firmware defined data\n *                              can be passed to openSIL. The host firmware is responsible\n *                              for initializing the SIL_CONTEXT structure.\n * @param   SocketNum           Primary RB socket number\n * @param   RootBridgeNum       Primary RB number\n *\n */",
                  "definition": "void\r\nSilGetPrimaryRb (\r\n  SIL_CONTEXT      *SilContext,\r\n  uint32_t         *SocketNum,\r\n  uint32_t         *DieNum,\r\n  uint32_t         *RootBridgeNum\r\n  )",
                  "implementation": "void\r\nSilGetPrimaryRb (\r\n  SIL_CONTEXT      *SilContext,\r\n  uint32_t         *SocketNum,\r\n  uint32_t         *DieNum,\r\n  uint32_t         *RootBridgeNum\r\n  )\r\n{\r\n  ROOT_BRIDGE_LOCATION Location;\r\n  DF_IP2IP_API *DfIp2IpApi;\r\n  SIL_STATUS           Status;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  if (Status != SilPass) {\r\n    assert(Status == SilPass);\r\n    return;\r\n  }\r\n\r\n  if (DfIp2IpApi->DfGetSystemComponentRootBridgeLocation(SilContext, PrimaryFch, &Location)) {\r\n    *SocketNum = Location.Socket;\r\n    *DieNum = Location.Die;\r\n    *RootBridgeNum = Location.Index;\r\n  } else {\r\n    *SocketNum = 0;\r\n    *DieNum = 0;\r\n    *RootBridgeNum = 0;\r\n  }\r\n}",
                  "range": [
                    { "line": 25, "character": 0 },
                    { "line": 52, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 26, "character": 0 },
                    { "line": 26, "character": 15 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "SIL_CONTEXT",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                        "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                        "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "range": [
                          { "line": 131, "character": 0 },
                          { "line": 135, "character": 14 }
                        ],
                        "selectionRange": [
                          { "line": 135, "character": 2 },
                          { "line": 135, "character": 13 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_CONTEXT",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSim-api.h",
                        "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                        "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "range": [
                          { "line": 131, "character": 0 },
                          { "line": 135, "character": 14 }
                        ],
                        "selectionRange": [
                          { "line": 135, "character": 2 },
                          { "line": 135, "character": 13 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "ROOT_BRIDGE_LOCATION",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/SilBaseFabricTopologyLib.h",
                        "documentation": "/// Root Bridge location",
                        "definition": "typedef struct {\r\n  uint32_t       Socket;\r\n  uint32_t       Die;\r\n  uint32_t       Index;\r\n} ROOT_BRIDGE_LOCATION;",
                        "implementation": "typedef struct {\r\n  uint32_t       Socket;\r\n  uint32_t       Die;\r\n  uint32_t       Index;\r\n} ROOT_BRIDGE_LOCATION;",
                        "range": [
                          { "line": 24, "character": 0 },
                          { "line": 28, "character": 23 }
                        ],
                        "selectionRange": [
                          { "line": 28, "character": 2 },
                          { "line": 28, "character": 22 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DF_IP2IP_API",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                        "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                        "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                        "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                        "range": [
                          { "line": 199, "character": 0 },
                          { "line": 226, "character": 15 }
                        ],
                        "selectionRange": [
                          { "line": 226, "character": 2 },
                          { "line": 226, "character": 14 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DfIp2IpApi",
                        "kind": 12,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Source/xUSL/RcMgr/Common/SilGetPrimaryRbUt/SilGetPrimaryRbUt.c",
                        "documentation": "/**\n * @file SilGetPrimaryRbUt.c\n * @brief\n *\n * SilGetPrimaryRb Iteration definitions\n * SilGetPrimaryRb: Returns primary RB socket number and RB number\n *\n * 2 iterations:\n *\n * Ip2IpStatusValidation:     Inside SilGetPrimaryRb, DF IP2IP API is located based on the IpId.\n *                            In this case, we arrange to get a NULL Api.\n *                            To pass, the call must fail.\n *\n * SuccessfulReturn:          This Iteration has all the right arguments\n *                            To pass, the call must return success.\n *\n * PhxGetSystemComponentRootBridgeLocationFail:\n *                            Inside SilGetPrimaryRb, PhxGetSystemComponentRootBridgeLocation will be called.\n *                            In this case, we arrange this procedure to return false.\n *                            To pass, SocketNum, PrimaryDie and RootBridgeNum are all 0.\n *\n */",
                        "definition": "DF_IP2IP_API    DfIp2IpApi = {\r\n  .DfGetSystemComponentRootBridgeLocation = PhxGetSystemComponentRootBridgeLocation\r\n};",
                        "implementation": "DF_IP2IP_API    DfIp2IpApi = {\r\n  .DfGetSystemComponentRootBridgeLocation = PhxGetSystemComponentRootBridgeLocation\r\n};",
                        "range": [
                          { "line": 26, "character": 0 },
                          { "line": 28, "character": 2 }
                        ],
                        "selectionRange": [
                          { "line": 26, "character": 16 },
                          { "line": 26, "character": 26 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_STATUS",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                        "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                        "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "range": [
                          { "line": 49, "character": 0 },
                          { "line": 74, "character": 13 }
                        ],
                        "selectionRange": [
                          { "line": 74, "character": 2 },
                          { "line": 74, "character": 12 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "assert(statement)",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/SilToUefi/assert.h",
                        "documentation": "/**\n * @file  assert.h\n * @brief SIL interface to ASSERT\n *\n */",
                        "definition": "#define assert(statement)",
                        "implementation": "#define assert(statement)",
                        "range": [
                          { "line": 11, "character": 1 },
                          { "line": 11, "character": 27 }
                        ],
                        "selectionRange": [
                          { "line": 11, "character": 9 },
                          { "line": 11, "character": 15 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "assert(Statement)",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/SilToUefi/assert.h",
                        "documentation": "/**\n * @file  assert.h\n * @brief SIL interface to ASSERT\n *\n */",
                        "definition": "#define assert(Statement)  ASSERT(Statement)",
                        "implementation": "#define assert(Statement)  ASSERT(Statement)",
                        "range": [
                          { "line": 13, "character": 1 },
                          { "line": 13, "character": 45 }
                        ],
                        "selectionRange": [
                          { "line": 13, "character": 9 },
                          { "line": 13, "character": 15 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SilGetIp2IpApi",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                        "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                        "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                        "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                        "range": [
                          { "line": 190, "character": 0 },
                          { "line": 219, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 191, "character": 0 },
                          { "line": 191, "character": 14 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "SIL_STATUS",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                              "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                              "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "range": [
                                { "line": 49, "character": 0 },
                                { "line": 74, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 74, "character": 2 },
                                { "line": 74, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_CONTEXT",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                              "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "range": [
                                { "line": 131, "character": 0 },
                                { "line": 135, "character": 14 }
                              ],
                              "selectionRange": [
                                { "line": 135, "character": 2 },
                                { "line": 135, "character": 13 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_DATA_BLOCK_ID",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                              "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                              "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                              "range": [
                                { "line": 48, "character": 0 },
                                { "line": 73, "character": 20 }
                              ],
                              "selectionRange": [
                                { "line": 73, "character": 2 },
                                { "line": 73, "character": 19 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_BLOCK_VARIABLES",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                              "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                              "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                              "range": [
                                { "line": 182, "character": 0 },
                                { "line": 193, "character": 22 }
                              ],
                              "selectionRange": [
                                { "line": 193, "character": 2 },
                                { "line": 193, "character": 21 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_TRACE_ERROR",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                              "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                              "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                              "range": [
                                { "line": 100, "character": 0 },
                                { "line": 100, "character": 87 }
                              ],
                              "selectionRange": [
                                { "line": 100, "character": 8 },
                                { "line": 100, "character": 23 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "__disable_tail_calls",
                              "kind": 12,
                              "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                              "documentation": "",
                              "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "range": [
                                { "line": 59, "character": 0 },
                                { "line": 59, "character": 101 }
                              ],
                              "selectionRange": [
                                { "line": 59, "character": 80 },
                                { "line": 59, "character": 100 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      },
                      {
                        "name": "__disable_tail_calls",
                        "kind": 12,
                        "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                        "documentation": "",
                        "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "range": [
                          { "line": 59, "character": 0 },
                          { "line": 59, "character": 101 }
                        ],
                        "selectionRange": [
                          { "line": 59, "character": 80 },
                          { "line": 59, "character": 100 }
                        ],
                        "dependencies": { "callTree": [] }
                      }
                    ]
                  }
                },
                {
                  "name": "SilFabricGetResourceDistribution",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                  "documentation": "/**\n * SilFabricGetResourceDistribution\n *\n * @brief Fills in the given memory block with the resource distribution data\n *\n * @param[in]         SilData               DFX_RCMGR_INPUT_BLK\n * @param[in, out]    ResourceDistribution  Array of booleans to be filled with the data\n *\n */",
                  "definition": "static\r\nSIL_STATUS\r\nSilFabricGetResourceDistribution (\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  bool                    *ResourceDistribution\r\n  )",
                  "implementation": "static\r\nSIL_STATUS\r\nSilFabricGetResourceDistribution (\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  bool                    *ResourceDistribution\r\n  )\r\n{\r\n  memcpy(ResourceDistribution,\r\n    &SilData->ResourceDistributionNv,\r\n    sizeof (bool) * PROJ_MAX_SOCKETS_SUPPORTED * PROJ_MAX_HOST_BRIDGES_PER_SOCKET\r\n    );\r\n  return SilPass;\r\n}",
                  "range": [
                    { "line": 203, "character": 0 },
                    { "line": 215, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 205, "character": 0 },
                    { "line": 205, "character": 32 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "SIL_STATUS",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                        "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                        "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "range": [
                          { "line": 49, "character": 0 },
                          { "line": 74, "character": 13 }
                        ],
                        "selectionRange": [
                          { "line": 74, "character": 2 },
                          { "line": 74, "character": 12 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DFX_RCMGR_INPUT_BLK",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                        "documentation": "",
                        "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                        "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                        "range": [
                          { "line": 124, "character": 0 },
                          { "line": 143, "character": 22 }
                        ],
                        "selectionRange": [
                          { "line": 143, "character": 2 },
                          { "line": 143, "character": 21 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "PROJ_MAX_SOCKETS_SUPPORTED",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xSIM/SoC/F19M70/F19M70Charz.h",
                        "documentation": "/**\n * @file F19M70Charz.h\n * @brief SoC characteristics constants\n */\n\n#pragma once\n\n/* SoC construction constants */",
                        "definition": "#define PROJ_MAX_SOCKETS_SUPPORTED      1",
                        "implementation": "#define PROJ_MAX_SOCKETS_SUPPORTED      1",
                        "range": [
                          { "line": 12, "character": 2 },
                          { "line": 12, "character": 43 }
                        ],
                        "selectionRange": [
                          { "line": 12, "character": 10 },
                          { "line": 12, "character": 36 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "PROJ_MAX_HOST_BRIDGES_PER_SOCKET",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xSIM/SoC/F19M70/F19M70Charz.h",
                        "documentation": "/**\n * @file F19M70Charz.h\n * @brief SoC characteristics constants\n */\n\n#pragma once\n\n/* SoC construction constants */\n#if      (PROJ_MAX_SOCKETS_SUPPORTED < 1)\n  #undef  PROJ_MAX_SOCKETS_SUPPORTED\n  #define PROJ_MAX_SOCKETS_SUPPORTED      1\n#endif\n#if      (PROJ_MAX_CCD_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_CCD_DIES_PER_SOCKET\n  #define PROJ_MAX_CCD_DIES_PER_SOCKET      1\n#endif\n#if      (PROJ_MAX_MEM_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_MEM_DIES_PER_SOCKET\n  #define PROJ_MAX_MEM_DIES_PER_SOCKET      1\n#endif\n#if      (PROJ_MAX_IO_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_IO_DIES_PER_SOCKET\n  #define PROJ_MAX_IO_DIES_PER_SOCKET      1\n#endif\n\n/* Processor Cores sub-system constants */\n#if      (PROJ_MAX_COMPLEXES_PER_CCD < 1)\n  #undef  PROJ_MAX_COMPLEXES_PER_CCD\n  #define PROJ_MAX_COMPLEXES_PER_CCD      1\n#endif\n#if      (PROJ_MAX_CCX_CORES_PER_COMPLEX < 8)\n  #undef  PROJ_MAX_CCX_CORES_PER_COMPLEX\n  #define PROJ_MAX_CCX_CORES_PER_COMPLEX      8\n#endif\n#if      (PROJ_MAX_CCX_THREADS_PER_CORE < 2)\n  #undef  PROJ_MAX_CCX_THREADS_PER_CORE\n  #define PROJ_MAX_CCX_THREADS_PER_CORE      2\n#endif\n#if      (PROJ_CCX_MAX_DIES_PER_SOCKET < 1)\n  #undef  PROJ_CCX_MAX_DIES_PER_SOCKET\n  #define PROJ_CCX_MAX_DIES_PER_SOCKET      1\n#endif\n\n/* Memory sub-system constants */\n#if      (PROJ_MAX_UMCS_PER_MEM_DIE < 2)\n  #undef  PROJ_MAX_UMCS_PER_MEM_DIE\n  #define PROJ_MAX_UMCS_PER_MEM_DIE      2\n#endif\n#if      (PROJ_MAX_CHANNELS_PER_UMC < 1)\n  #undef  PROJ_MAX_CHANNELS_PER_UMC\n  #define PROJ_MAX_CHANNELS_PER_UMC      1\n#endif\n#if      (PROJ_MAX_DIMMS_PER_CHANNEL < 2)\n  #undef  PROJ_MAX_DIMMS_PER_CHANNEL\n  #define PROJ_MAX_DIMMS_PER_CHANNEL      2\n#endif\n\n/* IO Hub sub-system constants */",
                        "definition": "#define PROJ_MAX_HOST_BRIDGES_PER_SOCKET      1",
                        "implementation": "#define PROJ_MAX_HOST_BRIDGES_PER_SOCKET      1",
                        "range": [
                          { "line": 66, "character": 2 },
                          { "line": 66, "character": 49 }
                        ],
                        "selectionRange": [
                          { "line": 66, "character": 10 },
                          { "line": 66, "character": 42 }
                        ],
                        "dependencies": { "callTree": [] }
                      }
                    ]
                  }
                },
                {
                  "name": "SilTryThisCombination",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                  "documentation": "/**\n * SilTryThisCombination\n *\n * @brief This function tries the given combination of MMIO resources.\n *\n * @details If successful, it may be requested to program DF MMIO registers.\n *\n * @param   SilContext                  A context structure through which host firmware defined data\n *                                      can be passed to openSIL. The host firmware is responsible\n *                                      for initializing the SIL_CONTEXT structure.\n * @param   SilData                     IP input block data\n * @param   MmioBaseAddrAbovePcieCfg    MmioBaseAddrAbovePcieCfg\n * @param   MmioBaseAddrBelowPcieCfg    MmioBaseAddrBelowPcieCfg\n * @param   MmioIsAbovePcieCfg          An bool array, indicate which RootBridge's MMIO is above Pcie Cfg\n * @param   SetDfRegisters              true  - Set DF MMIO registers\n *                                      false - Do Not set DF MMIO registers, just calculate if\n *                                              user's requirement could be satisfied.\n * @param   OverSizeBelowPcieMin        OverSizeBelowPcieMin\n * @param   AlignmentMask               AlignmentMask\n *\n * @retval            true                        Successful resource combination\n *                    false                       Unsuccessful resource combination\n */",
                  "definition": "static\r\nbool\r\nSilTryThisCombination (\r\n  SIL_CONTEXT          *SilContext,\r\n  DFX_RCMGR_INPUT_BLK  *SilData,\r\n  uint64_t             MmioBaseAddrAbovePcieCfg,\r\n  uint64_t             MmioBaseAddrBelowPcieCfg,\r\n  bool                 *MmioIsAbovePcieCfg,\r\n  bool                 SetDfRegisters,\r\n  uint32_t             *OverSizeBelowPcieMin,\r\n  uint32_t             *AlignmentMask\r\n  )",
                  "implementation": "static\r\nbool\r\nSilTryThisCombination (\r\n  SIL_CONTEXT          *SilContext,\r\n  DFX_RCMGR_INPUT_BLK  *SilData,\r\n  uint64_t             MmioBaseAddrAbovePcieCfg,\r\n  uint64_t             MmioBaseAddrBelowPcieCfg,\r\n  bool                 *MmioIsAbovePcieCfg,\r\n  bool                 SetDfRegisters,\r\n  uint32_t             *OverSizeBelowPcieMin,\r\n  uint32_t             *AlignmentMask\r\n  )\r\n{\r\n  uint8_t              i;\r\n  uint8_t              j;\r\n  uint8_t              SocketLoop;\r\n  uint8_t              RbLoop;\r\n  uint32_t             PrimarySocket;\r\n  uint32_t             PrimaryDie;\r\n  uint32_t             PrimaryRootBridge;\r\n  uint64_t             MmioBaseAddr;\r\n  // To calculate oversize, we must use uint64_t here for all address, size\r\n  uint64_t             MmioCeiling;\r\n  uint64_t             MmioBaseAddrPrefetchable;\r\n  uint64_t             MmioBaseAddrNonPrefetchable;\r\n  uint64_t             MmioBaseAddrNonPci;\r\n  uint64_t             PrimaryRbSecondMmioSize;\r\n  uint64_t             SizePrefetchable;\r\n  uint64_t             SizeNonPrefetchable;\r\n  uint64_t             SizeNonPci;\r\n  uint64_t             AlignMask;\r\n  uint64_t             AlignMaskP;\r\n  uint64_t             AlignMaskNonPci;\r\n  uint64_t             BottomOfCompat;\r\n  uint64_t             OverSizeAbovePcieCfg;\r\n  uint64_t             OverSizeBelowPcieCfg;\r\n  uint64_t             AlignForFirstMmioRegionAbovePcieCfg;\r\n  uint64_t             AlignForFirstMmioRegionBelowPcieCfg;\r\n  uint64_t             DeltaSize;\r\n  // this variable keeps the data how much size would be reduced if there's no NON-PCI MMIO\r\n  bool                 AlreadyGotAlignForFirstMmioRegionAbovePcieCfg;\r\n  bool                 AlreadyGotAlignForFirstMmioRegionBelowPcieCfg;\r\n  bool                 BigAlignFirstAbovePcieCfg;\r\n  bool                 BigAlignFirstBelowPcieCfg;\r\n  bool                 BigAlignFirst;\r\n  bool                 ReservedRegionAlreadySet;\r\n  bool                 OverSizeFlag;\r\n  bool                 PrimaryRbNonPciMmioAt2ndRegion;\r\n  bool                 HasSpaceBelowPcie;\r\n  uint32_t             MaxSystemRbCount;\r\n  SIL_STATUS           Status;\r\n  DF_IP2IP_API         *DfIp2IpApi;\r\n  APOB_IP2IP_API       *ApobIp2IpApi;\r\n  APOB_SOC_DIE_INFO    SocMaxDieInfo;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  assert(Status == SilPass);\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_ApobClass, (void **) &ApobIp2IpApi);\r\n  if ((Status != SilPass) || (ApobIp2IpApi == NULL)) {\r\n    assert(Status == SilPass);\r\n    return 0;\r\n  }\r\n\r\n  ApobIp2IpApi->ApobGetMaxDieInfo(SilContext, &SocMaxDieInfo);\r\n\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB *MmioSizeForEachRb = &SilData->ResourceSizeForEachRb;\r\n  uint64_t MmioLimitAbovePcieCfg;\r\n  uint64_t MmioLimitBelowPcieCfg;\r\n  DFX_FABRIC_MMIO_MANAGER *FabricMmioManager = &SilData->MmioRcMgr;\r\n\r\n  MmioLimitAbovePcieCfg = SilData->MmioLimitAbovePcieCfg;\r\n  MmioLimitBelowPcieCfg = SilData->MmioLimitBelowPcieCfg;\r\n  HasSpaceBelowPcie = (MmioLimitBelowPcieCfg > MmioBaseAddrBelowPcieCfg);\r\n  BigAlignFirstAbovePcieCfg = true;\r\n  BigAlignFirstBelowPcieCfg = true;\r\n  OverSizeFlag = false;\r\n  DeltaSize = 0;\r\n  PrimaryRbNonPciMmioAt2ndRegion = false;\r\n  AlreadyGotAlignForFirstMmioRegionAbovePcieCfg = false;\r\n  AlreadyGotAlignForFirstMmioRegionBelowPcieCfg = false;\r\n  SizeNonPci = SilData->MmioSizePerRbForNonPciDevice;\r\n  AlignMaskNonPci = RCMGR_NON_PCI_MMIO_ALIGN_MASK;\r\n  AlignForFirstMmioRegionAbovePcieCfg = 0;\r\n  AlignForFirstMmioRegionBelowPcieCfg = 0;\r\n\r\n  MaxSystemRbCount = DfIp2IpApi->DfGetNumberOfSystemRootBridges(SilContext);\r\n\r\n  SilGetPrimaryRb(SilContext, &PrimarySocket, &PrimaryDie, &PrimaryRootBridge);\r\n  BottomOfCompat = BOTTOM_OF_COMPAT;\r\n  ReservedRegionAlreadySet = false;  // Indicate if AmdBottomMmioReservedForPrimaryRb ~ BottomOfCompat is set\r\n\r\n  for (i = 0; i <= (SilData->SocketNumber * SilData->RbsPerSocket); i++) {\r\n    SocketLoop = (SilData->SocketNumber * SilData->RbsPerSocket - i - 1) / SilData->RbsPerSocket;\r\n    RbLoop = (SilData->SocketNumber * SilData->RbsPerSocket - i - 1) % SilData->RbsPerSocket;\r\n\r\n    // Skip allocating MMIO for primary RootBridge, and will allocate later\r\n    if ((SocketLoop == PrimarySocket) && (RbLoop == PrimaryRootBridge)) {\r\n      continue;\r\n    }\r\n\r\n    // This is the last loop, now try to allocate MMIO for primary RootBridge\r\n    if (i == (SilData->SocketNumber * SilData->RbsPerSocket)) {\r\n      SocketLoop = (uint8_t) PrimarySocket;\r\n      RbLoop = (uint8_t) PrimaryRootBridge;\r\n    }\r\n\r\n    if ((MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size +\r\n      MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + SizeNonPci) == 0) {\r\n      continue;\r\n    }\r\n\r\n    AlignMask = MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment;\r\n    AlignMaskP = MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment;\r\n\r\n    if (*(MmioIsAbovePcieCfg + SocketLoop * SilData->RbsPerSocket + RbLoop)) {\r\n      // Mmio is above PcieCfg\r\n      BigAlignFirst = BigAlignFirstAbovePcieCfg;\r\n      MmioBaseAddr = MmioBaseAddrAbovePcieCfg;\r\n      BigAlignFirstAbovePcieCfg = !BigAlignFirstAbovePcieCfg;\r\n\r\n      if (!AlreadyGotAlignForFirstMmioRegionAbovePcieCfg) {\r\n        // Save alignment for the first MMIO region, it will be used for calculate oversize\r\n        AlignForFirstMmioRegionAbovePcieCfg = (AlignMask > AlignMaskP) ? AlignMask : AlignMaskP;\r\n        AlreadyGotAlignForFirstMmioRegionAbovePcieCfg = true;\r\n      }\r\n    } else {\r\n      // Mmio is below PcieCfg\r\n      BigAlignFirst = BigAlignFirstBelowPcieCfg;\r\n      MmioBaseAddr = MmioBaseAddrBelowPcieCfg;\r\n      BigAlignFirstBelowPcieCfg = !BigAlignFirstBelowPcieCfg;\r\n\r\n      if (!AlreadyGotAlignForFirstMmioRegionBelowPcieCfg) {\r\n        // Save alignment for the first MMIO region, it will be used for calculate oversize\r\n        AlignForFirstMmioRegionBelowPcieCfg = (AlignMask > AlignMaskP) ? AlignMask: AlignMaskP;\r\n        AlreadyGotAlignForFirstMmioRegionBelowPcieCfg = true;\r\n      }\r\n    }\r\n\r\n    if (BigAlignFirst) {\r\n      if (MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment >=\r\n        MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment) {\r\n        // Prefetchable -> Non Prefetchable -> Non Pci\r\n        MmioBaseAddrPrefetchable = (MmioBaseAddr + AlignMaskP) & (~AlignMaskP);\r\n        MmioBaseAddrNonPrefetchable = (MmioBaseAddrPrefetchable +\r\n          MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + AlignMask) &\r\n          (~AlignMask);\r\n        MmioBaseAddrNonPci = (MmioBaseAddrNonPrefetchable +\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + AlignMaskNonPci) &\r\n          (~AlignMaskNonPci);\r\n        SizePrefetchable = MmioBaseAddrNonPrefetchable - MmioBaseAddrPrefetchable;\r\n        SizeNonPrefetchable = MmioBaseAddrNonPci - MmioBaseAddrNonPrefetchable;\r\n        MmioCeiling = MmioBaseAddrNonPci + SizeNonPci;\r\n        DeltaSize = MmioBaseAddrNonPci - MmioBaseAddrNonPrefetchable -\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + SizeNonPci;\r\n      } else {\r\n        // Non Prefetchable -> Prefetchable -> Non Pci\r\n        MmioBaseAddrNonPrefetchable = (MmioBaseAddr + AlignMask) & (~AlignMask);\r\n        MmioBaseAddrPrefetchable = (MmioBaseAddrNonPrefetchable +\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + AlignMaskP) &\r\n          (~AlignMaskP);\r\n        MmioBaseAddrNonPci = (MmioBaseAddrPrefetchable +\r\n          MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + AlignMaskNonPci) &\r\n          (~AlignMaskNonPci);\r\n        SizeNonPrefetchable = MmioBaseAddrPrefetchable - MmioBaseAddrNonPrefetchable;\r\n        SizePrefetchable = MmioBaseAddrNonPci - MmioBaseAddrPrefetchable;\r\n        MmioCeiling = MmioBaseAddrNonPci + SizeNonPci;\r\n        DeltaSize = MmioBaseAddrNonPci - MmioBaseAddrPrefetchable -\r\n          MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + SizeNonPci;\r\n      }\r\n    } else {\r\n      if (MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment <=\r\n        MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment) {\r\n        // Non Pci -> Prefetchable -> Non Prefetchable\r\n        MmioBaseAddrNonPci = (MmioBaseAddr + AlignMaskNonPci) & (~AlignMaskNonPci);\r\n        MmioBaseAddrPrefetchable = (MmioBaseAddrNonPci + SizeNonPci + AlignMaskP) & (~AlignMaskP);\r\n        MmioBaseAddrNonPrefetchable = (MmioBaseAddrPrefetchable +\r\n          MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + AlignMask) & (~AlignMask);\r\n        SizePrefetchable = MmioBaseAddrNonPrefetchable - MmioBaseAddrPrefetchable;\r\n        SizeNonPrefetchable = MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size;\r\n        MmioCeiling = MmioBaseAddrNonPrefetchable + SizeNonPrefetchable;\r\n        DeltaSize = MmioBaseAddrPrefetchable - ((MmioBaseAddr + AlignMaskP) & (~AlignMaskP));\r\n      } else {\r\n        // Non Pci -> Non Prefetchable -> Prefetchable\r\n        MmioBaseAddrNonPci = (MmioBaseAddr + AlignMaskNonPci) & (~AlignMaskNonPci);\r\n        MmioBaseAddrNonPrefetchable = (MmioBaseAddrNonPci + SizeNonPci + AlignMask) & (~AlignMask);\r\n        MmioBaseAddrPrefetchable = (MmioBaseAddrNonPrefetchable +\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + AlignMaskP) & (~AlignMaskP);\r\n        SizeNonPrefetchable = MmioBaseAddrPrefetchable - MmioBaseAddrNonPrefetchable;\r\n        SizePrefetchable = MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size;\r\n        MmioCeiling = MmioBaseAddrPrefetchable + SizePrefetchable;\r\n        DeltaSize = MmioBaseAddrNonPrefetchable - ((MmioBaseAddr + AlignMask) & (~AlignMask));\r\n      }\r\n    }\r\n\r\n    if (SizeNonPrefetchable == 0) {\r\n\r\n      MmioBaseAddrNonPrefetchable = 0;\r\n    }\r\n    if (SizePrefetchable == 0) {\r\n\r\n      MmioBaseAddrPrefetchable = 0;\r\n    }\r\n\r\n    // Check if space is enough\r\n    if (*(MmioIsAbovePcieCfg + SocketLoop * SilData->RbsPerSocket + RbLoop)) {\r\n      // Mmio is above PcieCfg\r\n      MmioBaseAddrAbovePcieCfg = MmioCeiling;\r\n      if (MmioBaseAddrAbovePcieCfg > MmioLimitAbovePcieCfg) {\r\n        OverSizeFlag = true;\r\n      }\r\n    } else {\r\n      // Mmio is below PcieCfg\r\n      MmioBaseAddrBelowPcieCfg = MmioCeiling;\r\n      if (MmioBaseAddrBelowPcieCfg > MmioLimitBelowPcieCfg) {\r\n        OverSizeFlag = true;\r\n      }\r\n    }\r\n\r\n    // (OverSize) && (Primary RootBridge has 2nd MMIO), try to see if moving primary RootBridge's Non-Pci MMIO\r\n    // from 1st region to 2nd region could work\r\n    // Always put Non-Pci at top of 2nd MMIO\r\n    if ((OverSizeFlag) && (SocketLoop == PrimarySocket) && (RbLoop == PrimaryRootBridge) &&\r\n      ((uint32_t)(SilData->SocketNumber * SilData->RbsPerSocket) < MaxSystemRbCount)) {\r\n      if (*(MmioIsAbovePcieCfg + SocketLoop * SilData->RbsPerSocket + RbLoop)) {\r\n        if (((MmioBaseAddrAbovePcieCfg - DeltaSize) <= MmioLimitAbovePcieCfg) &&\r\n          (MmioBaseAddrBelowPcieCfg <= ((MmioLimitBelowPcieCfg - SizeNonPci) & (~AlignMaskNonPci)))) {\r\n          OverSizeFlag = false;\r\n          PrimaryRbNonPciMmioAt2ndRegion = true;\r\n          MmioBaseAddrAbovePcieCfg -= DeltaSize;\r\n          MmioCeiling -= DeltaSize;\r\n        }\r\n      } else {\r\n        if (((MmioBaseAddrBelowPcieCfg - DeltaSize) <= MmioLimitBelowPcieCfg) &&\r\n          (MmioBaseAddrAbovePcieCfg <= ((MmioLimitAbovePcieCfg - SizeNonPci) & (~AlignMaskNonPci)))) {\r\n          OverSizeFlag = false;\r\n          PrimaryRbNonPciMmioAt2ndRegion = true;\r\n          MmioBaseAddrBelowPcieCfg -= DeltaSize;\r\n          MmioCeiling -= DeltaSize;\r\n        }\r\n      }\r\n\r\n      // Adjust MmioBaseAddrNonPrefetchable & MmioBaseAddrPrefetchable if we move primary RootBridge's NON-PCI\r\n      // from 1st region to 2nd region and NON-PCI is at lower address\r\n      if (PrimaryRbNonPciMmioAt2ndRegion && (!BigAlignFirst)) {\r\n        MmioBaseAddrNonPrefetchable -= DeltaSize;\r\n        MmioBaseAddrPrefetchable -= DeltaSize;\r\n      }\r\n    }\r\n\r\n    // Set DF MMIO registers\r\n    if ((!OverSizeFlag) && SetDfRegisters && (FabricMmioManager != NULL)) {\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"---Socket%x RootBridge%x---\\n\", SocketLoop, RbLoop);\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n        \"  Request below 4G\\n        Prefetch Size 0x%llX, AlignBit 0x%X\\n\",\r\n        MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size,\r\n        MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment\r\n        );\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n        \"    Non Prefetch Size 0x%llX, AlignBit 0x%X\\n\\n\",\r\n        MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size,\r\n        MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment\r\n        );\r\n      assert(BottomOfCompat >= SilData->BottomMmioReservedForPrimaryRb);\r\n\r\n      if ((SocketLoop == PrimarySocket) && (RbLoop == PrimaryRootBridge)) {\r\n        if (*(MmioIsAbovePcieCfg + SocketLoop * SilData->RbsPerSocket + RbLoop)) {\r\n          Status = SilSetMmioReg4(SilContext,\r\n            DfIp2IpApi,\r\n            SilData->SocketNumber,\r\n            ((SocketLoop * SilData->RbsPerSocket + RbLoop) * 2),\r\n            SocketLoop,\r\n            RbLoop,\r\n            MmioBaseAddr,\r\n            (BottomOfCompat - MmioBaseAddr)\r\n            );\r\n          MmioBaseAddrAbovePcieCfg = BottomOfCompat;\r\n          ReservedRegionAlreadySet = true;\r\n        } else {\r\n          Status = SilSetMmioReg4(SilContext,\r\n            DfIp2IpApi,\r\n            SilData->SocketNumber,\r\n            ((SocketLoop * SilData->RbsPerSocket + RbLoop) * 2),\r\n            SocketLoop,\r\n            RbLoop,\r\n            MmioBaseAddr,\r\n            (MmioLimitBelowPcieCfg - MmioBaseAddr)\r\n            );\r\n          MmioBaseAddrBelowPcieCfg = MmioLimitBelowPcieCfg;\r\n        }\r\n      } else {\r\n        Status = SilSetMmioReg4(SilContext,\r\n          DfIp2IpApi,\r\n          SilData->SocketNumber,\r\n          ((SocketLoop * SilData->RbsPerSocket + RbLoop) * 2),\r\n          SocketLoop,\r\n          RbLoop,\r\n          MmioBaseAddr,\r\n          (MmioCeiling - MmioBaseAddr)\r\n          );\r\n      }\r\n\r\n      FabricMmioManager->AllocateMmioBelow4GOnThisRb[SocketLoop][RbLoop] = true;\r\n      if ((SocketLoop == PrimarySocket) && (RbLoop == PrimaryRootBridge) && PrimaryRbNonPciMmioAt2ndRegion) {\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"    NON-PCI MMIO of Primary RootBridge has been moved to its 2nd region\\n\");\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPci = 0;\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPci = 0;\r\n      } else {\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPci = MmioBaseAddrNonPci;\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPci = SizeNonPci;\r\n      }\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BasePrefetch = MmioBaseAddrPrefetchable;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPrefetch = MmioBaseAddrNonPrefetchable;\r\n\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizePrefetch = SizePrefetchable;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPrefetch = SizeNonPrefetchable;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].UsedSizeNonPci = 0;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].UsedSizePrefetch = 0;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].UsedSizeNonPrefetch = 0;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].AlignNonPrefetch =\r\n        MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].AlignPrefetch =\r\n        MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment;\r\n\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n        \"    Prefetch    0x%llX ~ 0x%llX, Size 0x%llX\\n\",\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BasePrefetch,\r\n        (FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BasePrefetch +\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizePrefetch),\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizePrefetch\r\n        );\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n        \"    NonPrefetch 0x%llX ~ 0x%llX, Size 0x%llX\\n\",\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPrefetch,\r\n        (FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPrefetch +\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPrefetch),\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPrefetch\r\n        );\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n        \"    NonPci      0x%llX ~ 0x%llX, Size 0x%llX\\n\\n\",\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPci,\r\n        (FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPci +\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPci),\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPci\r\n        );\r\n    }\r\n  }\r\n\r\n  // If SetDfRegisters if FALSE, this function is called by FabricReallocateResourceForEachRb\r\n  // And we should record which combination has the minimum gap\r\n  if (!SetDfRegisters) {\r\n    if (OverSizeFlag) {\r\n      if (MmioBaseAddrAbovePcieCfg > MmioLimitAbovePcieCfg) {\r\n        OverSizeAbovePcieCfg = MmioBaseAddrAbovePcieCfg - MmioLimitAbovePcieCfg;\r\n      } else {\r\n        OverSizeAbovePcieCfg = 0;\r\n      }\r\n      if (MmioBaseAddrBelowPcieCfg > MmioLimitBelowPcieCfg) {\r\n        OverSizeBelowPcieCfg = MmioBaseAddrBelowPcieCfg - MmioLimitBelowPcieCfg;\r\n      } else {\r\n        OverSizeBelowPcieCfg = 0;\r\n      }\r\n      if (OverSizeAbovePcieCfg == 0) {\r\n        // Since user would not change PcieCfg space location, they would only change TOM,\r\n        // so we should make sure there's no oversize above PcieCfg\r\n        if (OverSizeBelowPcieCfg < *OverSizeBelowPcieMin) {\r\n          *OverSizeBelowPcieMin = (uint32_t) OverSizeBelowPcieCfg;\r\n          *AlignmentMask = (uint32_t) AlignForFirstMmioRegionBelowPcieCfg;\r\n        }\r\n      } else if (!HasSpaceBelowPcie) {\r\n        // If there's no space below PcieCfg, then OverSizeAbovePcieCfg is the size we need\r\n        *OverSizeBelowPcieMin = (uint32_t) OverSizeAbovePcieCfg;\r\n        *AlignmentMask = (uint32_t) AlignForFirstMmioRegionAbovePcieCfg;\r\n      }\r\n    } else {\r\n      *OverSizeBelowPcieMin = 0;\r\n    }\r\n  }\r\n\r\n  // Primary RootBridge's 2nd MMIO\r\n  if ((!OverSizeFlag) && SetDfRegisters && (FabricMmioManager != NULL)) {\r\n    if (((MmioBaseAddrAbovePcieCfg + RCMGR_MMIO_MIN_SIZE) <= MmioLimitAbovePcieCfg) ||\r\n      ((MmioBaseAddrBelowPcieCfg + RCMGR_MMIO_MIN_SIZE) <= MmioLimitBelowPcieCfg)) {\r\n      if ((MmioSizeForEachRb->PrimaryRbSecondNonPrefetchableMmioSizeBelow4G.Size != 0) ||\r\n        (MmioSizeForEachRb->PrimaryRbSecondPrefetchableMmioSizeBelow4G.Size != 0) || PrimaryRbNonPciMmioAt2ndRegion) {\r\n        if ((uint32_t)(SilData->SocketNumber * SilData->RbsPerSocket) < MaxSystemRbCount) {\r\n          for (i = 0; i < SocMaxDieInfo.MaxSocSocketsSupportedValue; i++) {\r\n            for (j = 0; j < SilData->RbsPerSocket; j++) {\r\n              if (FabricMmioManager->AllocateMmioBelow4GOnThisRb[i][j] == false) {\r\n                RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"  Primary RB has 2nd MMIO below 4G\\n\");\r\n                FabricMmioManager->PrimaryRb2ndMmioPairBelow4G = (uint8_t) ((i << 4) | j);\r\n                if (MmioBaseAddrAbovePcieCfg < MmioLimitAbovePcieCfg) {\r\n                  Status = SilSetMmioReg4(SilContext,\r\n                    DfIp2IpApi,\r\n                    SilData->SocketNumber,\r\n                    ((i * SilData->RbsPerSocket + j) * 2),\r\n                    PrimarySocket,\r\n                    PrimaryRootBridge,\r\n                    MmioBaseAddrAbovePcieCfg,\r\n                    (BottomOfCompat - MmioBaseAddrAbovePcieCfg)\r\n                    );\r\n                  MmioBaseAddr = MmioBaseAddrAbovePcieCfg;\r\n                  PrimaryRbSecondMmioSize = MmioLimitAbovePcieCfg - MmioBaseAddrAbovePcieCfg;\r\n                  ReservedRegionAlreadySet = true;\r\n                } else {\r\n                  Status = SilSetMmioReg4(SilContext,\r\n                    DfIp2IpApi,\r\n                    SilData->SocketNumber,\r\n                    ((i * SilData->RbsPerSocket + j) * 2),\r\n                    PrimarySocket,\r\n                    PrimaryRootBridge,\r\n                    MmioBaseAddrBelowPcieCfg,\r\n                    (MmioLimitBelowPcieCfg - MmioBaseAddrBelowPcieCfg)\r\n                    );\r\n                  MmioBaseAddr = MmioBaseAddrBelowPcieCfg;\r\n                  PrimaryRbSecondMmioSize = MmioLimitBelowPcieCfg - MmioBaseAddrBelowPcieCfg;\r\n                }\r\n                if (PrimaryRbNonPciMmioAt2ndRegion) {\r\n                  // Always put Non-Pci at top of 2nd MMIO\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPci =\r\n                    (MmioBaseAddr + PrimaryRbSecondMmioSize - SizeNonPci) & (~AlignMaskNonPci);\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPci = SizeNonPci;\r\n                  PrimaryRbSecondMmioSize = FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPci - MmioBaseAddr;\r\n                } else {\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPci = 0;\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPci = 0;\r\n                }\r\n                // Distribute Primary RB's 2nd MMIO base on user request\r\n                AlignMask = MmioSizeForEachRb->PrimaryRbSecondNonPrefetchableMmioSizeBelow4G.Alignment;\r\n                AlignMaskP = MmioSizeForEachRb->PrimaryRbSecondPrefetchableMmioSizeBelow4G.Alignment;\r\n                if (MmioSizeForEachRb->PrimaryRbSecondNonPrefetchableMmioSizeBelow4G.Size == 0) {\r\n                  SizePrefetchable = PrimaryRbSecondMmioSize;\r\n                  SizeNonPrefetchable = 0;\r\n                } else if (MmioSizeForEachRb->PrimaryRbSecondPrefetchableMmioSizeBelow4G.Size == 0) {\r\n                  SizePrefetchable = 0;\r\n                  SizeNonPrefetchable = PrimaryRbSecondMmioSize;\r\n                } else {\r\n                  SizePrefetchable = (PrimaryRbSecondMmioSize /\r\n                    ((uint32_t) (MmioSizeForEachRb->PrimaryRbSecondPrefetchableMmioSizeBelow4G.Size +\r\n                    MmioSizeForEachRb->PrimaryRbSecondNonPrefetchableMmioSizeBelow4G.Size))) *\r\n                    MmioSizeForEachRb->PrimaryRbSecondPrefetchableMmioSizeBelow4G.Size;\r\n                  SizeNonPrefetchable = PrimaryRbSecondMmioSize - SizePrefetchable;\r\n                }\r\n\r\n                if (SizePrefetchable != 0) {\r\n                  MmioBaseAddrPrefetchable = (MmioBaseAddr + AlignMaskP) & (~AlignMaskP);\r\n                } else {\r\n                  MmioBaseAddrPrefetchable = MmioBaseAddr;\r\n                  SizePrefetchable = 0;\r\n                }\r\n\r\n                if (SizeNonPrefetchable != 0) {\r\n                  MmioBaseAddrNonPrefetchable = (MmioBaseAddrPrefetchable + SizePrefetchable + AlignMask) &\r\n                    (~AlignMask);\r\n                  SizeNonPrefetchable = MmioBaseAddr + PrimaryRbSecondMmioSize - MmioBaseAddrNonPrefetchable;\r\n                } else {\r\n                  MmioBaseAddrNonPrefetchable = MmioBaseAddrPrefetchable + SizePrefetchable;\r\n                  SizeNonPrefetchable = 0;\r\n                }\r\n\r\n                if (SizeNonPrefetchable == 0) {\r\n\r\n                  MmioBaseAddrNonPrefetchable = 0;\r\n                }\r\n                if (SizePrefetchable == 0) {\r\n\r\n                  MmioBaseAddrPrefetchable = 0;\r\n                }\r\n\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].BasePrefetch = MmioBaseAddrPrefetchable;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPrefetch = MmioBaseAddrNonPrefetchable;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].SizePrefetch = SizePrefetchable;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPrefetch = SizeNonPrefetchable;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].UsedSizePrefetch = 0;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].UsedSizeNonPrefetch = 0;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].UsedSizeNonPci = 0;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].AlignNonPrefetch =\r\n                  MmioSizeForEachRb->PrimaryRbSecondNonPrefetchableMmioSizeBelow4G.Alignment;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].AlignPrefetch =\r\n                  MmioSizeForEachRb->PrimaryRbSecondPrefetchableMmioSizeBelow4G.Alignment;\r\n\r\n                RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n                  \"    Prefetch    0x%llX ~ 0x%llX, Size 0x%llX\\n\",\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].BasePrefetch,\r\n                  (FabricMmioManager->MmioRegionBelow4G[i][j].BasePrefetch +\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizePrefetch),\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizePrefetch\r\n                  );\r\n                RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n                  \"    NonPrefetch 0x%llX ~ 0x%llX, Size 0x%llX\\n\",\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPrefetch,\r\n                  (FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPrefetch +\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPrefetch),\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPrefetch\r\n                  );\r\n                RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n                  \"    NonPci      0x%llX ~ 0x%llX, Size 0x%llX\\n\\n\",\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPci,\r\n                  (FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPci +\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPci),\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPci\r\n                  );\r\n\r\n                FabricMmioManager->PrimaryRbHas2ndMmioBelow4G = true;\r\n                break;\r\n              }\r\n            }\r\n            if (FabricMmioManager->PrimaryRbHas2ndMmioBelow4G) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // If there's a spare MMIO register pair, set 0xFED0_0000 ~ 0xFED0_FFFF as posted\r\n    SilAdditionalMmioSetting4(SilContext, SilData, BottomOfCompat, ReservedRegionAlreadySet);\r\n  }\r\n\r\n  return (!OverSizeFlag);\r\n}",
                  "range": [
                    { "line": 315, "character": 0 },
                    { "line": 835, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 317, "character": 0 },
                    { "line": 317, "character": 21 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "SIL_CONTEXT",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                        "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                        "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "range": [
                          { "line": 131, "character": 0 },
                          { "line": 135, "character": 14 }
                        ],
                        "selectionRange": [
                          { "line": 135, "character": 2 },
                          { "line": 135, "character": 13 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DFX_RCMGR_INPUT_BLK",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                        "documentation": "",
                        "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                        "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                        "range": [
                          { "line": 124, "character": 0 },
                          { "line": 143, "character": 22 }
                        ],
                        "selectionRange": [
                          { "line": 143, "character": 2 },
                          { "line": 143, "character": 21 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_STATUS",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                        "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                        "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "range": [
                          { "line": 49, "character": 0 },
                          { "line": 74, "character": 13 }
                        ],
                        "selectionRange": [
                          { "line": 74, "character": 2 },
                          { "line": 74, "character": 12 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DF_IP2IP_API",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                        "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                        "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                        "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                        "range": [
                          { "line": 199, "character": 0 },
                          { "line": 226, "character": 15 }
                        ],
                        "selectionRange": [
                          { "line": 226, "character": 2 },
                          { "line": 226, "character": 14 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "APOB_IP2IP_API",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/ApobIp2Ip.h",
                        "documentation": "",
                        "definition": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                        "implementation": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                        "range": [
                          { "line": 105, "character": 0 },
                          { "line": 119, "character": 17 }
                        ],
                        "selectionRange": [
                          { "line": 119, "character": 2 },
                          { "line": 119, "character": 16 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "APOB_SOC_DIE_INFO",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/Common/ApobCmn.h",
                        "documentation": "/**\n * @brief AMD APOB_SOC_DIE_INFO\n *\n */",
                        "definition": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                        "implementation": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                        "range": [
                          { "line": 544, "character": 0 },
                          { "line": 552, "character": 20 }
                        ],
                        "selectionRange": [
                          { "line": 552, "character": 2 },
                          { "line": 552, "character": 19 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DFX_FABRIC_RESOURCE_FOR_EACH_RB",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                        "documentation": "/// Resource for each RootBridge",
                        "definition": "typedef struct {\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondNonPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  IO[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  uint16_t              PciBusNumber[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n} DFX_FABRIC_RESOURCE_FOR_EACH_RB;",
                        "implementation": "typedef struct {\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondNonPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  IO[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  uint16_t              PciBusNumber[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n} DFX_FABRIC_RESOURCE_FOR_EACH_RB;",
                        "range": [
                          { "line": 74, "character": 0 },
                          { "line": 83, "character": 34 }
                        ],
                        "selectionRange": [
                          { "line": 83, "character": 2 },
                          { "line": 83, "character": 33 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DFX_FABRIC_MMIO_MANAGER",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                        "documentation": "",
                        "definition": "typedef struct {\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  bool    AllocateMmioAbove4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO above 4G?\r\n  bool    AllocateMmioBelow4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO below 4G?\r\n  bool    PrimaryRbHas2ndMmioBelow4G;                                               ///< Indicate if RootBridge 0 has a 2nd MMIO which is below 4G\r\n  bool    ReportToGcd;                                                              ///< TRUE - Need to report GCD if user call FabricAllocateMmio\r\n  uint8_t PrimaryRb2ndMmioPairBelow4G;                                              ///< Since AllocateMmioOnThisRootBridge[i][j] is FALSE, use this one for\r\n                                                                                    ///< RootBridge0's 2nd MMIO, RootBridge02ndMmioPair = (i << 4) | j\r\n  uint64_t  Reserved;                                                               ///< compatibility (ImageHandle)\r\n} DFX_FABRIC_MMIO_MANAGER;",
                        "implementation": "typedef struct {\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  bool    AllocateMmioAbove4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO above 4G?\r\n  bool    AllocateMmioBelow4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO below 4G?\r\n  bool    PrimaryRbHas2ndMmioBelow4G;                                               ///< Indicate if RootBridge 0 has a 2nd MMIO which is below 4G\r\n  bool    ReportToGcd;                                                              ///< TRUE - Need to report GCD if user call FabricAllocateMmio\r\n  uint8_t PrimaryRb2ndMmioPairBelow4G;                                              ///< Since AllocateMmioOnThisRootBridge[i][j] is FALSE, use this one for\r\n                                                                                    ///< RootBridge0's 2nd MMIO, RootBridge02ndMmioPair = (i << 4) | j\r\n  uint64_t  Reserved;                                                               ///< compatibility (ImageHandle)\r\n} DFX_FABRIC_MMIO_MANAGER;",
                        "range": [
                          { "line": 100, "character": 0 },
                          { "line": 110, "character": 26 }
                        ],
                        "selectionRange": [
                          { "line": 110, "character": 2 },
                          { "line": 110, "character": 25 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "RCMGR_NON_PCI_MMIO_ALIGN_MASK",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                        "documentation": "",
                        "definition": "#define RCMGR_NON_PCI_MMIO_ALIGN_MASK       0xFFFFull       // MMIO for non-PCI devices should be 16 bit aligned",
                        "implementation": "#define RCMGR_NON_PCI_MMIO_ALIGN_MASK       0xFFFFull       // MMIO for non-PCI devices should be 16 bit aligned",
                        "range": [
                          { "line": 26, "character": 0 },
                          { "line": 26, "character": 112 }
                        ],
                        "selectionRange": [
                          { "line": 26, "character": 8 },
                          { "line": 26, "character": 37 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "BOTTOM_OF_COMPAT",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                        "documentation": "",
                        "definition": "#define BOTTOM_OF_COMPAT           0xFEC00000ul // From BOTTOM_OF_COMPAT to 4G would be leaved as undescribed (COMPAT)",
                        "implementation": "#define BOTTOM_OF_COMPAT           0xFEC00000ul // From BOTTOM_OF_COMPAT to 4G would be leaved as undescribed (COMPAT)",
                        "range": [
                          { "line": 37, "character": 0 },
                          { "line": 37, "character": 118 }
                        ],
                        "selectionRange": [
                          { "line": 37, "character": 8 },
                          { "line": 37, "character": 24 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "RCMGR_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                        "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
                        "definition": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                        "implementation": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                        "range": [
                          { "line": 18, "character": 0 },
                          { "line": 23, "character": 19 }
                        ],
                        "selectionRange": [
                          { "line": 18, "character": 8 },
                          { "line": 18, "character": 24 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_TRACE_INFO",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                        "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                        "definition": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                        "implementation": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                        "range": [
                          { "line": 104, "character": 0 },
                          { "line": 104, "character": 118 }
                        ],
                        "selectionRange": [
                          { "line": 104, "character": 8 },
                          { "line": 104, "character": 22 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "RCMGR_MMIO_MIN_SIZE",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                        "documentation": "",
                        "definition": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                        "implementation": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                        "range": [
                          { "line": 25, "character": 0 },
                          { "line": 25, "character": 53 }
                        ],
                        "selectionRange": [
                          { "line": 25, "character": 8 },
                          { "line": 25, "character": 27 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SilGetIp2IpApi",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                        "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                        "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                        "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                        "range": [
                          { "line": 190, "character": 0 },
                          { "line": 219, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 191, "character": 0 },
                          { "line": 191, "character": 14 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "SIL_STATUS",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                              "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                              "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "range": [
                                { "line": 49, "character": 0 },
                                { "line": 74, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 74, "character": 2 },
                                { "line": 74, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_CONTEXT",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                              "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "range": [
                                { "line": 131, "character": 0 },
                                { "line": 135, "character": 14 }
                              ],
                              "selectionRange": [
                                { "line": 135, "character": 2 },
                                { "line": 135, "character": 13 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_DATA_BLOCK_ID",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                              "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                              "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                              "range": [
                                { "line": 48, "character": 0 },
                                { "line": 73, "character": 20 }
                              ],
                              "selectionRange": [
                                { "line": 73, "character": 2 },
                                { "line": 73, "character": 19 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_BLOCK_VARIABLES",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                              "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                              "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                              "range": [
                                { "line": 182, "character": 0 },
                                { "line": 193, "character": 22 }
                              ],
                              "selectionRange": [
                                { "line": 193, "character": 2 },
                                { "line": 193, "character": 21 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_TRACE_ERROR",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                              "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                              "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                              "range": [
                                { "line": 100, "character": 0 },
                                { "line": 100, "character": 87 }
                              ],
                              "selectionRange": [
                                { "line": 100, "character": 8 },
                                { "line": 100, "character": 23 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "__disable_tail_calls",
                              "kind": 12,
                              "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                              "documentation": "",
                              "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "range": [
                                { "line": 59, "character": 0 },
                                { "line": 59, "character": 101 }
                              ],
                              "selectionRange": [
                                { "line": 59, "character": 80 },
                                { "line": 59, "character": 100 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      },
                      {
                        "name": "__disable_tail_calls",
                        "kind": 12,
                        "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                        "documentation": "",
                        "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "range": [
                          { "line": 59, "character": 0 },
                          { "line": 59, "character": 101 }
                        ],
                        "selectionRange": [
                          { "line": 59, "character": 80 },
                          { "line": 59, "character": 100 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SilGetPrimaryRb",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricRcInit.c",
                        "documentation": "/**\n * SilGetPrimaryRb\n *\n * @brief Returns primary RB socket number and RB number\n *\n * @param   SilContext          A context structure through which host firmware defined data\n *                              can be passed to openSIL. The host firmware is responsible\n *                              for initializing the SIL_CONTEXT structure.\n * @param   SocketNum           Primary RB socket number\n * @param   RootBridgeNum       Primary RB number\n *\n */",
                        "definition": "void\r\nSilGetPrimaryRb (\r\n  SIL_CONTEXT      *SilContext,\r\n  uint32_t         *SocketNum,\r\n  uint32_t         *DieNum,\r\n  uint32_t         *RootBridgeNum\r\n  )",
                        "implementation": "void\r\nSilGetPrimaryRb (\r\n  SIL_CONTEXT      *SilContext,\r\n  uint32_t         *SocketNum,\r\n  uint32_t         *DieNum,\r\n  uint32_t         *RootBridgeNum\r\n  )\r\n{\r\n  ROOT_BRIDGE_LOCATION Location;\r\n  DF_IP2IP_API *DfIp2IpApi;\r\n  SIL_STATUS           Status;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  if (Status != SilPass) {\r\n    assert(Status == SilPass);\r\n    return;\r\n  }\r\n\r\n  if (DfIp2IpApi->DfGetSystemComponentRootBridgeLocation(SilContext, PrimaryFch, &Location)) {\r\n    *SocketNum = Location.Socket;\r\n    *DieNum = Location.Die;\r\n    *RootBridgeNum = Location.Index;\r\n  } else {\r\n    *SocketNum = 0;\r\n    *DieNum = 0;\r\n    *RootBridgeNum = 0;\r\n  }\r\n}",
                        "range": [
                          { "line": 25, "character": 0 },
                          { "line": 52, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 26, "character": 0 },
                          { "line": 26, "character": 15 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "SIL_CONTEXT",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                              "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "range": [
                                { "line": 131, "character": 0 },
                                { "line": 135, "character": 14 }
                              ],
                              "selectionRange": [
                                { "line": 135, "character": 2 },
                                { "line": 135, "character": 13 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "ROOT_BRIDGE_LOCATION",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/SilBaseFabricTopologyLib.h",
                              "documentation": "/// Root Bridge location",
                              "definition": "typedef struct {\r\n  uint32_t       Socket;\r\n  uint32_t       Die;\r\n  uint32_t       Index;\r\n} ROOT_BRIDGE_LOCATION;",
                              "implementation": "typedef struct {\r\n  uint32_t       Socket;\r\n  uint32_t       Die;\r\n  uint32_t       Index;\r\n} ROOT_BRIDGE_LOCATION;",
                              "range": [
                                { "line": 24, "character": 0 },
                                { "line": 28, "character": 23 }
                              ],
                              "selectionRange": [
                                { "line": 28, "character": 2 },
                                { "line": 28, "character": 22 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "DF_IP2IP_API",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                              "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                              "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                              "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                              "range": [
                                { "line": 199, "character": 0 },
                                { "line": 226, "character": 15 }
                              ],
                              "selectionRange": [
                                { "line": 226, "character": 2 },
                                { "line": 226, "character": 14 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_STATUS",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                              "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                              "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "range": [
                                { "line": 49, "character": 0 },
                                { "line": 74, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 74, "character": 2 },
                                { "line": 74, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SilGetIp2IpApi",
                              "kind": 11,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                              "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                              "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                              "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                              "range": [
                                { "line": 190, "character": 0 },
                                { "line": 219, "character": 1 }
                              ],
                              "selectionRange": [
                                { "line": 191, "character": 0 },
                                { "line": 191, "character": 14 }
                              ],
                              "dependencies": {
                                "callTree": [
                                  {
                                    "name": "SIL_STATUS",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                    "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                    "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "range": [
                                      { "line": 49, "character": 0 },
                                      { "line": 74, "character": 13 }
                                    ],
                                    "selectionRange": [
                                      { "line": 74, "character": 2 },
                                      { "line": 74, "character": 12 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_CONTEXT",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                    "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "range": [
                                      { "line": 131, "character": 0 },
                                      { "line": 135, "character": 14 }
                                    ],
                                    "selectionRange": [
                                      { "line": 135, "character": 2 },
                                      { "line": 135, "character": 13 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_DATA_BLOCK_ID",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                                    "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                    "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                    "range": [
                                      { "line": 48, "character": 0 },
                                      { "line": 73, "character": 20 }
                                    ],
                                    "selectionRange": [
                                      { "line": 73, "character": 2 },
                                      { "line": 73, "character": 19 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_BLOCK_VARIABLES",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                    "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                                    "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                    "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                    "range": [
                                      { "line": 182, "character": 0 },
                                      { "line": 193, "character": 22 }
                                    ],
                                    "selectionRange": [
                                      { "line": 193, "character": 2 },
                                      { "line": 193, "character": 21 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_TRACE_ERROR",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                    "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                                    "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                    "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                    "range": [
                                      { "line": 100, "character": 0 },
                                      { "line": 100, "character": 87 }
                                    ],
                                    "selectionRange": [
                                      { "line": 100, "character": 8 },
                                      { "line": 100, "character": 23 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "__disable_tail_calls",
                                    "kind": 12,
                                    "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                    "documentation": "",
                                    "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "range": [
                                      { "line": 59, "character": 0 },
                                      { "line": 59, "character": 101 }
                                    ],
                                    "selectionRange": [
                                      { "line": 59, "character": 80 },
                                      { "line": 59, "character": 100 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "__disable_tail_calls",
                              "kind": 12,
                              "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                              "documentation": "",
                              "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "range": [
                                { "line": 59, "character": 0 },
                                { "line": 59, "character": 101 }
                              ],
                              "selectionRange": [
                                { "line": 59, "character": 80 },
                                { "line": 59, "character": 100 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      },
                      {
                        "name": "SilSetMmioReg4",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                        "documentation": "/**\n * SilSetMmioReg4\n *\n * @brief Set MMIO register pairs according to input parameters\n *\n * @param   SilContext      A context structure through which host firmware defined data\n *                          can be passed to openSIL. The host firmware is responsible\n *                          for initializing the SIL_CONTEXT structure.\n * @param   DfIp2IpApi      A pointer to the data fabric I2I api\n * @param   TotalSocket     System socket count\n * @param   MmioPairIndex   Which MMIO register pair should be set\n * @param   SktNum          Socket number\n * @param   RbNum           Root bridge number\n * @param   BaseAddress     Base address of MMIO region\n * @param   Length          Length of MMIO region\n *\n */",
                        "definition": "SIL_STATUS\r\nSilSetMmioReg4 (\r\n  SIL_CONTEXT                   *SilContext,\r\n  DF_IP2IP_API                  *DfIp2IpApi,\r\n  uint8_t                       TotalSocket,\r\n  uint8_t                       MmioPairIndex,\r\n  uint32_t                      SktNum,\r\n  uint32_t                      RbNum,\r\n  uint64_t                      BaseAddress,\r\n  uint64_t                      Length\r\n  )",
                        "implementation": "SIL_STATUS\r\nSilSetMmioReg4 (\r\n  SIL_CONTEXT                   *SilContext,\r\n  DF_IP2IP_API                  *DfIp2IpApi,\r\n  uint8_t                       TotalSocket,\r\n  uint8_t                       MmioPairIndex,\r\n  uint32_t                      SktNum,\r\n  uint32_t                      RbNum,\r\n  uint64_t                      BaseAddress,\r\n  uint64_t                      Length\r\n  )\r\n{\r\n  uint32_t            DiePerSkt;\r\n  SIL_STATUS          Status;\r\n  APOB_SOC_DIE_INFO   SocMaxDieInfo;\r\n  APOB_IP2IP_API      *ApobIp2IpApi;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_ApobClass, (void **) &ApobIp2IpApi);\r\n  if ((Status != SilPass) || (ApobIp2IpApi == NULL)) {\r\n    assert(Status == SilPass);\r\n  } else {\r\n    ApobIp2IpApi->ApobGetMaxDieInfo(SilContext, &SocMaxDieInfo);\r\n    assert(Length >= RCMGR_MMIO_MIN_SIZE);\r\n    BaseAddress = (BaseAddress + 0xFFFF) & 0xFFFFFFFFFFFF0000;\r\n\r\n    DiePerSkt = DfIp2IpApi->DfGetNumberOfDiesOnSocket(SilContext, SktNum);\r\n    if (DiePerSkt <= SocMaxDieInfo.MaxSocDiesPerSocketValue) {\r\n      for (uint32_t i = 0; i < TotalSocket; i++) {\r\n        for (uint32_t j = 0; j < DiePerSkt; j++) {\r\n          DfIp2IpApi->DfFabricRegisterAccWrite(SilContext,\r\n            i,\r\n            j,\r\n            MMIOBASEADDRESS_0_FUNC,\r\n            (MMIOBASEADDRESS_0_REG + MmioPairIndex * (MMIOBASEADDRESS_1_REG - MMIOBASEADDRESS_0_REG)),\r\n            FABRIC_REG_ACC_BC,\r\n            (uint32_t) (BaseAddress >> 16)\r\n            );\r\n          DfIp2IpApi->DfFabricRegisterAccWrite(SilContext,\r\n            i,\r\n            j,\r\n            MMIOLIMITADDRESS_0_FUNC,\r\n            (MMIOLIMITADDRESS_0_REG + MmioPairIndex * (MMIOLIMITADDRESS_1_REG - MMIOLIMITADDRESS_0_REG)),\r\n            FABRIC_REG_ACC_BC,\r\n            (uint32_t) ((BaseAddress + Length - 1) >> 16)\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_RE,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            1,\r\n            0\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_WE,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            1,\r\n            0\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_DstFabricID,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            (uint32_t) DfIp2IpApi->DfGetHostBridgeSystemFabricID(SilContext, SktNum, 0, RbNum),\r\n            0\r\n            );\r\n        }\r\n      }\r\n    }\r\n\r\n    Status = SilPass;\r\n  }\r\n\r\n  return Status;\r\n}",
                        "range": [
                          { "line": 1594, "character": 0 },
                          { "line": 1680, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 1595, "character": 0 },
                          { "line": 1595, "character": 14 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "SIL_STATUS",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                              "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                              "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "range": [
                                { "line": 49, "character": 0 },
                                { "line": 74, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 74, "character": 2 },
                                { "line": 74, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_CONTEXT",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                              "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "range": [
                                { "line": 131, "character": 0 },
                                { "line": 135, "character": 14 }
                              ],
                              "selectionRange": [
                                { "line": 135, "character": 2 },
                                { "line": 135, "character": 13 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "DF_IP2IP_API",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                              "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                              "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                              "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                              "range": [
                                { "line": 199, "character": 0 },
                                { "line": 226, "character": 15 }
                              ],
                              "selectionRange": [
                                { "line": 226, "character": 2 },
                                { "line": 226, "character": 14 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "APOB_SOC_DIE_INFO",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/Common/ApobCmn.h",
                              "documentation": "/**\n * @brief AMD APOB_SOC_DIE_INFO\n *\n */",
                              "definition": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                              "implementation": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                              "range": [
                                { "line": 544, "character": 0 },
                                { "line": 552, "character": 20 }
                              ],
                              "selectionRange": [
                                { "line": 552, "character": 2 },
                                { "line": 552, "character": 19 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "APOB_IP2IP_API",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/ApobIp2Ip.h",
                              "documentation": "",
                              "definition": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                              "implementation": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                              "range": [
                                { "line": 105, "character": 0 },
                                { "line": 119, "character": 17 }
                              ],
                              "selectionRange": [
                                { "line": 119, "character": 2 },
                                { "line": 119, "character": 16 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "RCMGR_MMIO_MIN_SIZE",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                              "documentation": "",
                              "definition": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                              "implementation": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                              "range": [
                                { "line": 25, "character": 0 },
                                { "line": 25, "character": 53 }
                              ],
                              "selectionRange": [
                                { "line": 25, "character": 8 },
                                { "line": 25, "character": 27 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "MMIOBASEADDRESS_0_FUNC",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "",
                              "definition": "#define MMIOBASEADDRESS_0_FUNC 0x0",
                              "implementation": "#define MMIOBASEADDRESS_0_FUNC 0x0",
                              "range": [
                                { "line": 149, "character": 0 },
                                { "line": 149, "character": 34 }
                              ],
                              "selectionRange": [
                                { "line": 149, "character": 8 },
                                { "line": 149, "character": 30 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "MMIOBASEADDRESS_0_REG",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "",
                              "definition": "#define MMIOBASEADDRESS_0_REG  0xD80",
                              "implementation": "#define MMIOBASEADDRESS_0_REG  0xD80",
                              "range": [
                                { "line": 150, "character": 0 },
                                { "line": 150, "character": 36 }
                              ],
                              "selectionRange": [
                                { "line": 150, "character": 8 },
                                { "line": 150, "character": 29 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "MMIOBASEADDRESS_1_REG",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "",
                              "definition": "#define MMIOBASEADDRESS_1_REG  0xD90",
                              "implementation": "#define MMIOBASEADDRESS_1_REG  0xD90",
                              "range": [
                                { "line": 152, "character": 0 },
                                { "line": 152, "character": 36 }
                              ],
                              "selectionRange": [
                                { "line": 152, "character": 8 },
                                { "line": 152, "character": 29 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "FABRIC_REG_ACC_BC",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/FabricRegisterAccCmn.h",
                              "documentation": "/**\n * @file  FabricRegisterAccCmn.h\n * @brief Common definitions for Df fabric register access\n *\n */",
                              "definition": "#define FABRIC_REG_ACC_BC    (0xFFFFFFFF)",
                              "implementation": "#define FABRIC_REG_ACC_BC    (0xFFFFFFFF)",
                              "range": [
                                { "line": 12, "character": 0 },
                                { "line": 12, "character": 41 }
                              ],
                              "selectionRange": [
                                { "line": 12, "character": 8 },
                                { "line": 12, "character": 25 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "MMIOLIMITADDRESS_0_FUNC",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "",
                              "definition": "#define MMIOLIMITADDRESS_0_FUNC 0x0",
                              "implementation": "#define MMIOLIMITADDRESS_0_FUNC 0x0",
                              "range": [
                                { "line": 154, "character": 0 },
                                { "line": 154, "character": 35 }
                              ],
                              "selectionRange": [
                                { "line": 154, "character": 8 },
                                { "line": 154, "character": 31 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "MMIOLIMITADDRESS_0_REG",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "",
                              "definition": "#define MMIOLIMITADDRESS_0_REG  0xD84",
                              "implementation": "#define MMIOLIMITADDRESS_0_REG  0xD84",
                              "range": [
                                { "line": 155, "character": 0 },
                                { "line": 155, "character": 37 }
                              ],
                              "selectionRange": [
                                { "line": 155, "character": 8 },
                                { "line": 155, "character": 30 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "MMIOLIMITADDRESS_1_REG",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "",
                              "definition": "#define MMIOLIMITADDRESS_1_REG  0xD94",
                              "implementation": "#define MMIOLIMITADDRESS_1_REG  0xD94",
                              "range": [
                                { "line": 157, "character": 0 },
                                { "line": 157, "character": 37 }
                              ],
                              "selectionRange": [
                                { "line": 157, "character": 8 },
                                { "line": 157, "character": 30 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "DF_ABSTRACT_REG_WRITE",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                              "documentation": "// Registers that are not supported in a specific program in register abstraction",
                              "definition": "#define DF_ABSTRACT_REG_WRITE  1",
                              "implementation": "#define DF_ABSTRACT_REG_WRITE  1",
                              "range": [
                                { "line": 90, "character": 0 },
                                { "line": 90, "character": 32 }
                              ],
                              "selectionRange": [
                                { "line": 90, "character": 8 },
                                { "line": 90, "character": 29 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SilGetIp2IpApi",
                              "kind": 11,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                              "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                              "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                              "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                              "range": [
                                { "line": 190, "character": 0 },
                                { "line": 219, "character": 1 }
                              ],
                              "selectionRange": [
                                { "line": 191, "character": 0 },
                                { "line": 191, "character": 14 }
                              ],
                              "dependencies": {
                                "callTree": [
                                  {
                                    "name": "SIL_STATUS",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                    "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                    "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "range": [
                                      { "line": 49, "character": 0 },
                                      { "line": 74, "character": 13 }
                                    ],
                                    "selectionRange": [
                                      { "line": 74, "character": 2 },
                                      { "line": 74, "character": 12 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_CONTEXT",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                    "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "range": [
                                      { "line": 131, "character": 0 },
                                      { "line": 135, "character": 14 }
                                    ],
                                    "selectionRange": [
                                      { "line": 135, "character": 2 },
                                      { "line": 135, "character": 13 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_DATA_BLOCK_ID",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                                    "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                    "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                    "range": [
                                      { "line": 48, "character": 0 },
                                      { "line": 73, "character": 20 }
                                    ],
                                    "selectionRange": [
                                      { "line": 73, "character": 2 },
                                      { "line": 73, "character": 19 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_BLOCK_VARIABLES",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                    "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                                    "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                    "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                    "range": [
                                      { "line": 182, "character": 0 },
                                      { "line": 193, "character": 22 }
                                    ],
                                    "selectionRange": [
                                      { "line": 193, "character": 2 },
                                      { "line": 193, "character": 21 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_TRACE_ERROR",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                    "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                                    "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                    "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                    "range": [
                                      { "line": 100, "character": 0 },
                                      { "line": 100, "character": 87 }
                                    ],
                                    "selectionRange": [
                                      { "line": 100, "character": 8 },
                                      { "line": 100, "character": 23 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "__disable_tail_calls",
                                    "kind": 12,
                                    "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                    "documentation": "",
                                    "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "range": [
                                      { "line": 59, "character": 0 },
                                      { "line": 59, "character": 101 }
                                    ],
                                    "selectionRange": [
                                      { "line": 59, "character": 80 },
                                      { "line": 59, "character": 100 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "__disable_tail_calls",
                              "kind": 12,
                              "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                              "documentation": "",
                              "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "range": [
                                { "line": 59, "character": 0 },
                                { "line": 59, "character": 101 }
                              ],
                              "selectionRange": [
                                { "line": 59, "character": 80 },
                                { "line": 59, "character": 100 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      },
                      {
                        "name": "SilAdditionalMmioSetting4",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                        "documentation": "/**\n * SilAdditionalMmioSetting4\n *\n * @brief Additional MMIO settings\n *\n * @details If reserved region for primary RB (AmdBottomMmioReservedForPrimaryRb ~ BottomOfCompat) has not been set,\n * or that region doesn't include\n * ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START ~ ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END,\n * set ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START ~ ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END as POSTED\n *\n * @param   SilContext                  A context structure through which host firmware defined data\n *                                      can be passed to openSIL. The host firmware is responsible\n *                                      for initializing the SIL_CONTEXT structure.\n * @param   SilData                     IP input block data\n * @param   BottomOfCompat              From BottomOfCompat to 4G is COMPAT region\n * @param   ReservedRegionAlreadySet    AmdBottomMmioReservedForPrimaryRb ~ BottomOfCompat has been set or not\n *\n */",
                        "definition": "void\r\nSilAdditionalMmioSetting4 (\r\n  SIL_CONTEXT             *SilContext,\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  uint64_t                BottomOfCompat,\r\n  bool                    ReservedRegionAlreadySet\r\n  )",
                        "implementation": "void\r\nSilAdditionalMmioSetting4 (\r\n  SIL_CONTEXT             *SilContext,\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  uint64_t                BottomOfCompat,\r\n  bool                    ReservedRegionAlreadySet\r\n  )\r\n{\r\n  uint8_t                 i;\r\n  uint8_t                 j;\r\n  uint64_t                Base;\r\n  uint64_t                Size;\r\n  uint32_t                PrimarySocket;\r\n  uint32_t                PrimaryDie;\r\n  uint32_t                PrimaryRootBridge;\r\n  bool                    AlreadySet;\r\n  DFX_FABRIC_MMIO_MANAGER *FabricMmioManager = &SilData->MmioRcMgr;\r\n  DF_IP2IP_API            *DfIp2IpApi;\r\n  SIL_STATUS              Status;\r\n  APOB_IP2IP_API          *ApobIp2IpApi;\r\n  APOB_SOC_DIE_INFO       SocMaxDieInfo;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  assert(Status == SilPass);\r\n  Status = SilGetIp2IpApi(SilContext, SilId_ApobClass, (void **) &ApobIp2IpApi);\r\n  if ((Status != SilPass) || (ApobIp2IpApi == NULL)) {\r\n    assert(Status == SilPass);\r\n    return;\r\n  }\r\n\r\n  ApobIp2IpApi->ApobGetMaxDieInfo(SilContext, &SocMaxDieInfo);\r\n\r\n  SilGetPrimaryRb(SilContext, &PrimarySocket, &PrimaryDie, &PrimaryRootBridge);\r\n\r\n  AlreadySet = false;\r\n  Base = ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START;\r\n  Size = ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END - ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START + 1;\r\n\r\n  // If reserved region for primary root bridge (AmdBottomMmioReservedForPrimaryRb ~ BottomOfCompat) has not been set\r\n  // or that region does not include\r\n  // ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START ~ ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END\r\n  if ((!ReservedRegionAlreadySet) ||\r\n    ((ReservedRegionAlreadySet) && (BottomOfCompat <= ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END))) {\r\n    if (Size >= RCMGR_MMIO_MIN_SIZE) {\r\n      for (i = 0; i < SocMaxDieInfo.MaxSocSocketsSupportedValue; i++) {\r\n        for (j = 0; j < SilData->RbsPerSocket; j++) {\r\n          // Find out a spare MMIO register pair\r\n          if (FabricMmioManager->AllocateMmioBelow4GOnThisRb[i][j] == false) {\r\n            if ((FabricMmioManager->PrimaryRbHas2ndMmioBelow4G) &&\r\n              (((FabricMmioManager->PrimaryRb2ndMmioPairBelow4G >> 4) & 0xF) == i) &&\r\n              ((FabricMmioManager->PrimaryRb2ndMmioPairBelow4G & 0xF) == j)) {\r\n              continue;\r\n            }\r\n            Status = SilSetMmioReg4(SilContext,\r\n              DfIp2IpApi,\r\n              SilData->SocketNumber,\r\n              ((i * SilData->RbsPerSocket + j) * 2),\r\n              PrimarySocket,\r\n              PrimaryRootBridge,\r\n              Base,\r\n              Size\r\n              );\r\n            AlreadySet = true;\r\n            break;\r\n          }\r\n\r\n          if (FabricMmioManager->AllocateMmioAbove4GOnThisRb[i][j] == false) {\r\n            Status = SilSetMmioReg4(SilContext,\r\n              DfIp2IpApi,\r\n              SilData->SocketNumber,\r\n              ((i * SilData->RbsPerSocket + j) * 2 + 1),\r\n              PrimarySocket,\r\n              PrimaryRootBridge,\r\n              Base,\r\n              Size\r\n              );\r\n            AlreadySet = true;\r\n            break;\r\n          }\r\n        }\r\n        if (AlreadySet) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}",
                        "range": [
                          { "line": 1489, "character": 0 },
                          { "line": 1575, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 1490, "character": 0 },
                          { "line": 1490, "character": 25 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "SIL_CONTEXT",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                              "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "range": [
                                { "line": 131, "character": 0 },
                                { "line": 135, "character": 14 }
                              ],
                              "selectionRange": [
                                { "line": 135, "character": 2 },
                                { "line": 135, "character": 13 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "DFX_RCMGR_INPUT_BLK",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                              "documentation": "",
                              "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                              "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                              "range": [
                                { "line": 124, "character": 0 },
                                { "line": 143, "character": 22 }
                              ],
                              "selectionRange": [
                                { "line": 143, "character": 2 },
                                { "line": 143, "character": 21 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "DFX_FABRIC_MMIO_MANAGER",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                              "documentation": "",
                              "definition": "typedef struct {\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  bool    AllocateMmioAbove4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO above 4G?\r\n  bool    AllocateMmioBelow4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO below 4G?\r\n  bool    PrimaryRbHas2ndMmioBelow4G;                                               ///< Indicate if RootBridge 0 has a 2nd MMIO which is below 4G\r\n  bool    ReportToGcd;                                                              ///< TRUE - Need to report GCD if user call FabricAllocateMmio\r\n  uint8_t PrimaryRb2ndMmioPairBelow4G;                                              ///< Since AllocateMmioOnThisRootBridge[i][j] is FALSE, use this one for\r\n                                                                                    ///< RootBridge0's 2nd MMIO, RootBridge02ndMmioPair = (i << 4) | j\r\n  uint64_t  Reserved;                                                               ///< compatibility (ImageHandle)\r\n} DFX_FABRIC_MMIO_MANAGER;",
                              "implementation": "typedef struct {\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  bool    AllocateMmioAbove4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO above 4G?\r\n  bool    AllocateMmioBelow4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO below 4G?\r\n  bool    PrimaryRbHas2ndMmioBelow4G;                                               ///< Indicate if RootBridge 0 has a 2nd MMIO which is below 4G\r\n  bool    ReportToGcd;                                                              ///< TRUE - Need to report GCD if user call FabricAllocateMmio\r\n  uint8_t PrimaryRb2ndMmioPairBelow4G;                                              ///< Since AllocateMmioOnThisRootBridge[i][j] is FALSE, use this one for\r\n                                                                                    ///< RootBridge0's 2nd MMIO, RootBridge02ndMmioPair = (i << 4) | j\r\n  uint64_t  Reserved;                                                               ///< compatibility (ImageHandle)\r\n} DFX_FABRIC_MMIO_MANAGER;",
                              "range": [
                                { "line": 100, "character": 0 },
                                { "line": 110, "character": 26 }
                              ],
                              "selectionRange": [
                                { "line": 110, "character": 2 },
                                { "line": 110, "character": 25 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "DF_IP2IP_API",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                              "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                              "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                              "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                              "range": [
                                { "line": 199, "character": 0 },
                                { "line": 226, "character": 15 }
                              ],
                              "selectionRange": [
                                { "line": 226, "character": 2 },
                                { "line": 226, "character": 14 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_STATUS",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                              "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                              "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "range": [
                                { "line": 49, "character": 0 },
                                { "line": 74, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 74, "character": 2 },
                                { "line": 74, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "APOB_IP2IP_API",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/ApobIp2Ip.h",
                              "documentation": "",
                              "definition": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                              "implementation": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                              "range": [
                                { "line": 105, "character": 0 },
                                { "line": 119, "character": 17 }
                              ],
                              "selectionRange": [
                                { "line": 119, "character": 2 },
                                { "line": 119, "character": 16 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "APOB_SOC_DIE_INFO",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/Common/ApobCmn.h",
                              "documentation": "/**\n * @brief AMD APOB_SOC_DIE_INFO\n *\n */",
                              "definition": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                              "implementation": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                              "range": [
                                { "line": 544, "character": 0 },
                                { "line": 552, "character": 20 }
                              ],
                              "selectionRange": [
                                { "line": 552, "character": 2 },
                                { "line": 552, "character": 19 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                              "documentation": "",
                              "definition": "#define ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START 0xFED00000ul",
                              "implementation": "#define ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START 0xFED00000ul",
                              "range": [
                                { "line": 39, "character": 0 },
                                { "line": 39, "character": 68 }
                              ],
                              "selectionRange": [
                                { "line": 39, "character": 8 },
                                { "line": 39, "character": 55 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                              "documentation": "",
                              "definition": "#define ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END   0xFED0FFFFul",
                              "implementation": "#define ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END   0xFED0FFFFul",
                              "range": [
                                { "line": 40, "character": 0 },
                                { "line": 40, "character": 68 }
                              ],
                              "selectionRange": [
                                { "line": 40, "character": 8 },
                                { "line": 40, "character": 53 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "RCMGR_MMIO_MIN_SIZE",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                              "documentation": "",
                              "definition": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                              "implementation": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                              "range": [
                                { "line": 25, "character": 0 },
                                { "line": 25, "character": 53 }
                              ],
                              "selectionRange": [
                                { "line": 25, "character": 8 },
                                { "line": 25, "character": 27 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SilGetIp2IpApi",
                              "kind": 11,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                              "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                              "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                              "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                              "range": [
                                { "line": 190, "character": 0 },
                                { "line": 219, "character": 1 }
                              ],
                              "selectionRange": [
                                { "line": 191, "character": 0 },
                                { "line": 191, "character": 14 }
                              ],
                              "dependencies": {
                                "callTree": [
                                  {
                                    "name": "SIL_STATUS",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                    "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                    "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "range": [
                                      { "line": 49, "character": 0 },
                                      { "line": 74, "character": 13 }
                                    ],
                                    "selectionRange": [
                                      { "line": 74, "character": 2 },
                                      { "line": 74, "character": 12 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_CONTEXT",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                    "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "range": [
                                      { "line": 131, "character": 0 },
                                      { "line": 135, "character": 14 }
                                    ],
                                    "selectionRange": [
                                      { "line": 135, "character": 2 },
                                      { "line": 135, "character": 13 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_DATA_BLOCK_ID",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                                    "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                    "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                    "range": [
                                      { "line": 48, "character": 0 },
                                      { "line": 73, "character": 20 }
                                    ],
                                    "selectionRange": [
                                      { "line": 73, "character": 2 },
                                      { "line": 73, "character": 19 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_BLOCK_VARIABLES",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                    "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                                    "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                    "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                    "range": [
                                      { "line": 182, "character": 0 },
                                      { "line": 193, "character": 22 }
                                    ],
                                    "selectionRange": [
                                      { "line": 193, "character": 2 },
                                      { "line": 193, "character": 21 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_TRACE_ERROR",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                    "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                                    "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                    "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                    "range": [
                                      { "line": 100, "character": 0 },
                                      { "line": 100, "character": 87 }
                                    ],
                                    "selectionRange": [
                                      { "line": 100, "character": 8 },
                                      { "line": 100, "character": 23 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "__disable_tail_calls",
                                    "kind": 12,
                                    "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                    "documentation": "",
                                    "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "range": [
                                      { "line": 59, "character": 0 },
                                      { "line": 59, "character": 101 }
                                    ],
                                    "selectionRange": [
                                      { "line": 59, "character": 80 },
                                      { "line": 59, "character": 100 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "__disable_tail_calls",
                              "kind": 12,
                              "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                              "documentation": "",
                              "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "range": [
                                { "line": 59, "character": 0 },
                                { "line": 59, "character": 101 }
                              ],
                              "selectionRange": [
                                { "line": 59, "character": 80 },
                                { "line": 59, "character": 100 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SilGetPrimaryRb",
                              "kind": 11,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricRcInit.c",
                              "documentation": "/**\n * SilGetPrimaryRb\n *\n * @brief Returns primary RB socket number and RB number\n *\n * @param   SilContext          A context structure through which host firmware defined data\n *                              can be passed to openSIL. The host firmware is responsible\n *                              for initializing the SIL_CONTEXT structure.\n * @param   SocketNum           Primary RB socket number\n * @param   RootBridgeNum       Primary RB number\n *\n */",
                              "definition": "void\r\nSilGetPrimaryRb (\r\n  SIL_CONTEXT      *SilContext,\r\n  uint32_t         *SocketNum,\r\n  uint32_t         *DieNum,\r\n  uint32_t         *RootBridgeNum\r\n  )",
                              "implementation": "void\r\nSilGetPrimaryRb (\r\n  SIL_CONTEXT      *SilContext,\r\n  uint32_t         *SocketNum,\r\n  uint32_t         *DieNum,\r\n  uint32_t         *RootBridgeNum\r\n  )\r\n{\r\n  ROOT_BRIDGE_LOCATION Location;\r\n  DF_IP2IP_API *DfIp2IpApi;\r\n  SIL_STATUS           Status;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  if (Status != SilPass) {\r\n    assert(Status == SilPass);\r\n    return;\r\n  }\r\n\r\n  if (DfIp2IpApi->DfGetSystemComponentRootBridgeLocation(SilContext, PrimaryFch, &Location)) {\r\n    *SocketNum = Location.Socket;\r\n    *DieNum = Location.Die;\r\n    *RootBridgeNum = Location.Index;\r\n  } else {\r\n    *SocketNum = 0;\r\n    *DieNum = 0;\r\n    *RootBridgeNum = 0;\r\n  }\r\n}",
                              "range": [
                                { "line": 25, "character": 0 },
                                { "line": 52, "character": 1 }
                              ],
                              "selectionRange": [
                                { "line": 26, "character": 0 },
                                { "line": 26, "character": 15 }
                              ],
                              "dependencies": {
                                "callTree": [
                                  {
                                    "name": "SIL_CONTEXT",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                    "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "range": [
                                      { "line": 131, "character": 0 },
                                      { "line": 135, "character": 14 }
                                    ],
                                    "selectionRange": [
                                      { "line": 135, "character": 2 },
                                      { "line": 135, "character": 13 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "ROOT_BRIDGE_LOCATION",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/SilBaseFabricTopologyLib.h",
                                    "documentation": "/// Root Bridge location",
                                    "definition": "typedef struct {\r\n  uint32_t       Socket;\r\n  uint32_t       Die;\r\n  uint32_t       Index;\r\n} ROOT_BRIDGE_LOCATION;",
                                    "implementation": "typedef struct {\r\n  uint32_t       Socket;\r\n  uint32_t       Die;\r\n  uint32_t       Index;\r\n} ROOT_BRIDGE_LOCATION;",
                                    "range": [
                                      { "line": 24, "character": 0 },
                                      { "line": 28, "character": 23 }
                                    ],
                                    "selectionRange": [
                                      { "line": 28, "character": 2 },
                                      { "line": 28, "character": 22 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "DF_IP2IP_API",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                                    "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                                    "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                    "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                    "range": [
                                      { "line": 199, "character": 0 },
                                      { "line": 226, "character": 15 }
                                    ],
                                    "selectionRange": [
                                      { "line": 226, "character": 2 },
                                      { "line": 226, "character": 14 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_STATUS",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                    "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                    "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "range": [
                                      { "line": 49, "character": 0 },
                                      { "line": 74, "character": 13 }
                                    ],
                                    "selectionRange": [
                                      { "line": 74, "character": 2 },
                                      { "line": 74, "character": 12 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SilGetIp2IpApi",
                                    "kind": 11,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                                    "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                                    "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                                    "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                                    "range": [
                                      { "line": 190, "character": 0 },
                                      { "line": 219, "character": 1 }
                                    ],
                                    "selectionRange": [
                                      { "line": 191, "character": 0 },
                                      { "line": 191, "character": 14 }
                                    ],
                                    "dependencies": {
                                      "callTree": [
                                        {
                                          "name": "SIL_STATUS",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                          "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                          "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "range": [
                                            { "line": 49, "character": 0 },
                                            { "line": 74, "character": 13 }
                                          ],
                                          "selectionRange": [
                                            { "line": 74, "character": 2 },
                                            { "line": 74, "character": 12 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_CONTEXT",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                          "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                          "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "range": [
                                            { "line": 131, "character": 0 },
                                            { "line": 135, "character": 14 }
                                          ],
                                          "selectionRange": [
                                            { "line": 135, "character": 2 },
                                            { "line": 135, "character": 13 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_DATA_BLOCK_ID",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                          "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                                          "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                          "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                          "range": [
                                            { "line": 48, "character": 0 },
                                            { "line": 73, "character": 20 }
                                          ],
                                          "selectionRange": [
                                            { "line": 73, "character": 2 },
                                            { "line": 73, "character": 19 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_BLOCK_VARIABLES",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                          "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                                          "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                          "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                          "range": [
                                            { "line": 182, "character": 0 },
                                            { "line": 193, "character": 22 }
                                          ],
                                          "selectionRange": [
                                            { "line": 193, "character": 2 },
                                            { "line": 193, "character": 21 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_TRACE_ERROR",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                          "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                                          "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                          "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                          "range": [
                                            { "line": 100, "character": 0 },
                                            { "line": 100, "character": 87 }
                                          ],
                                          "selectionRange": [
                                            { "line": 100, "character": 8 },
                                            { "line": 100, "character": 23 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "__disable_tail_calls",
                                          "kind": 12,
                                          "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                          "documentation": "",
                                          "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "range": [
                                            { "line": 59, "character": 0 },
                                            { "line": 59, "character": 101 }
                                          ],
                                          "selectionRange": [
                                            { "line": 59, "character": 80 },
                                            { "line": 59, "character": 100 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "__disable_tail_calls",
                                    "kind": 12,
                                    "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                    "documentation": "",
                                    "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "range": [
                                      { "line": 59, "character": 0 },
                                      { "line": 59, "character": 101 }
                                    ],
                                    "selectionRange": [
                                      { "line": 59, "character": 80 },
                                      { "line": 59, "character": 100 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "SilSetMmioReg4",
                              "kind": 11,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                              "documentation": "/**\n * SilSetMmioReg4\n *\n * @brief Set MMIO register pairs according to input parameters\n *\n * @param   SilContext      A context structure through which host firmware defined data\n *                          can be passed to openSIL. The host firmware is responsible\n *                          for initializing the SIL_CONTEXT structure.\n * @param   DfIp2IpApi      A pointer to the data fabric I2I api\n * @param   TotalSocket     System socket count\n * @param   MmioPairIndex   Which MMIO register pair should be set\n * @param   SktNum          Socket number\n * @param   RbNum           Root bridge number\n * @param   BaseAddress     Base address of MMIO region\n * @param   Length          Length of MMIO region\n *\n */",
                              "definition": "SIL_STATUS\r\nSilSetMmioReg4 (\r\n  SIL_CONTEXT                   *SilContext,\r\n  DF_IP2IP_API                  *DfIp2IpApi,\r\n  uint8_t                       TotalSocket,\r\n  uint8_t                       MmioPairIndex,\r\n  uint32_t                      SktNum,\r\n  uint32_t                      RbNum,\r\n  uint64_t                      BaseAddress,\r\n  uint64_t                      Length\r\n  )",
                              "implementation": "SIL_STATUS\r\nSilSetMmioReg4 (\r\n  SIL_CONTEXT                   *SilContext,\r\n  DF_IP2IP_API                  *DfIp2IpApi,\r\n  uint8_t                       TotalSocket,\r\n  uint8_t                       MmioPairIndex,\r\n  uint32_t                      SktNum,\r\n  uint32_t                      RbNum,\r\n  uint64_t                      BaseAddress,\r\n  uint64_t                      Length\r\n  )\r\n{\r\n  uint32_t            DiePerSkt;\r\n  SIL_STATUS          Status;\r\n  APOB_SOC_DIE_INFO   SocMaxDieInfo;\r\n  APOB_IP2IP_API      *ApobIp2IpApi;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_ApobClass, (void **) &ApobIp2IpApi);\r\n  if ((Status != SilPass) || (ApobIp2IpApi == NULL)) {\r\n    assert(Status == SilPass);\r\n  } else {\r\n    ApobIp2IpApi->ApobGetMaxDieInfo(SilContext, &SocMaxDieInfo);\r\n    assert(Length >= RCMGR_MMIO_MIN_SIZE);\r\n    BaseAddress = (BaseAddress + 0xFFFF) & 0xFFFFFFFFFFFF0000;\r\n\r\n    DiePerSkt = DfIp2IpApi->DfGetNumberOfDiesOnSocket(SilContext, SktNum);\r\n    if (DiePerSkt <= SocMaxDieInfo.MaxSocDiesPerSocketValue) {\r\n      for (uint32_t i = 0; i < TotalSocket; i++) {\r\n        for (uint32_t j = 0; j < DiePerSkt; j++) {\r\n          DfIp2IpApi->DfFabricRegisterAccWrite(SilContext,\r\n            i,\r\n            j,\r\n            MMIOBASEADDRESS_0_FUNC,\r\n            (MMIOBASEADDRESS_0_REG + MmioPairIndex * (MMIOBASEADDRESS_1_REG - MMIOBASEADDRESS_0_REG)),\r\n            FABRIC_REG_ACC_BC,\r\n            (uint32_t) (BaseAddress >> 16)\r\n            );\r\n          DfIp2IpApi->DfFabricRegisterAccWrite(SilContext,\r\n            i,\r\n            j,\r\n            MMIOLIMITADDRESS_0_FUNC,\r\n            (MMIOLIMITADDRESS_0_REG + MmioPairIndex * (MMIOLIMITADDRESS_1_REG - MMIOLIMITADDRESS_0_REG)),\r\n            FABRIC_REG_ACC_BC,\r\n            (uint32_t) ((BaseAddress + Length - 1) >> 16)\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_RE,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            1,\r\n            0\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_WE,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            1,\r\n            0\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_DstFabricID,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            (uint32_t) DfIp2IpApi->DfGetHostBridgeSystemFabricID(SilContext, SktNum, 0, RbNum),\r\n            0\r\n            );\r\n        }\r\n      }\r\n    }\r\n\r\n    Status = SilPass;\r\n  }\r\n\r\n  return Status;\r\n}",
                              "range": [
                                { "line": 1594, "character": 0 },
                                { "line": 1680, "character": 1 }
                              ],
                              "selectionRange": [
                                { "line": 1595, "character": 0 },
                                { "line": 1595, "character": 14 }
                              ],
                              "dependencies": {
                                "callTree": [
                                  {
                                    "name": "SIL_STATUS",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                    "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                    "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "range": [
                                      { "line": 49, "character": 0 },
                                      { "line": 74, "character": 13 }
                                    ],
                                    "selectionRange": [
                                      { "line": 74, "character": 2 },
                                      { "line": 74, "character": 12 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_CONTEXT",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                    "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "range": [
                                      { "line": 131, "character": 0 },
                                      { "line": 135, "character": 14 }
                                    ],
                                    "selectionRange": [
                                      { "line": 135, "character": 2 },
                                      { "line": 135, "character": 13 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "DF_IP2IP_API",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                                    "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                                    "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                    "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                    "range": [
                                      { "line": 199, "character": 0 },
                                      { "line": 226, "character": 15 }
                                    ],
                                    "selectionRange": [
                                      { "line": 226, "character": 2 },
                                      { "line": 226, "character": 14 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "APOB_SOC_DIE_INFO",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/Common/ApobCmn.h",
                                    "documentation": "/**\n * @brief AMD APOB_SOC_DIE_INFO\n *\n */",
                                    "definition": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                                    "implementation": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                                    "range": [
                                      { "line": 544, "character": 0 },
                                      { "line": 552, "character": 20 }
                                    ],
                                    "selectionRange": [
                                      { "line": 552, "character": 2 },
                                      { "line": 552, "character": 19 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "APOB_IP2IP_API",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/ApobIp2Ip.h",
                                    "documentation": "",
                                    "definition": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                                    "implementation": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                                    "range": [
                                      { "line": 105, "character": 0 },
                                      { "line": 119, "character": 17 }
                                    ],
                                    "selectionRange": [
                                      { "line": 119, "character": 2 },
                                      { "line": 119, "character": 16 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "RCMGR_MMIO_MIN_SIZE",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                                    "documentation": "",
                                    "definition": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                                    "implementation": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                                    "range": [
                                      { "line": 25, "character": 0 },
                                      { "line": 25, "character": 53 }
                                    ],
                                    "selectionRange": [
                                      { "line": 25, "character": 8 },
                                      { "line": 25, "character": 27 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "MMIOBASEADDRESS_0_FUNC",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "",
                                    "definition": "#define MMIOBASEADDRESS_0_FUNC 0x0",
                                    "implementation": "#define MMIOBASEADDRESS_0_FUNC 0x0",
                                    "range": [
                                      { "line": 149, "character": 0 },
                                      { "line": 149, "character": 34 }
                                    ],
                                    "selectionRange": [
                                      { "line": 149, "character": 8 },
                                      { "line": 149, "character": 30 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "MMIOBASEADDRESS_0_REG",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "",
                                    "definition": "#define MMIOBASEADDRESS_0_REG  0xD80",
                                    "implementation": "#define MMIOBASEADDRESS_0_REG  0xD80",
                                    "range": [
                                      { "line": 150, "character": 0 },
                                      { "line": 150, "character": 36 }
                                    ],
                                    "selectionRange": [
                                      { "line": 150, "character": 8 },
                                      { "line": 150, "character": 29 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "MMIOBASEADDRESS_1_REG",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "",
                                    "definition": "#define MMIOBASEADDRESS_1_REG  0xD90",
                                    "implementation": "#define MMIOBASEADDRESS_1_REG  0xD90",
                                    "range": [
                                      { "line": 152, "character": 0 },
                                      { "line": 152, "character": 36 }
                                    ],
                                    "selectionRange": [
                                      { "line": 152, "character": 8 },
                                      { "line": 152, "character": 29 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "FABRIC_REG_ACC_BC",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/FabricRegisterAccCmn.h",
                                    "documentation": "/**\n * @file  FabricRegisterAccCmn.h\n * @brief Common definitions for Df fabric register access\n *\n */",
                                    "definition": "#define FABRIC_REG_ACC_BC    (0xFFFFFFFF)",
                                    "implementation": "#define FABRIC_REG_ACC_BC    (0xFFFFFFFF)",
                                    "range": [
                                      { "line": 12, "character": 0 },
                                      { "line": 12, "character": 41 }
                                    ],
                                    "selectionRange": [
                                      { "line": 12, "character": 8 },
                                      { "line": 12, "character": 25 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "MMIOLIMITADDRESS_0_FUNC",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "",
                                    "definition": "#define MMIOLIMITADDRESS_0_FUNC 0x0",
                                    "implementation": "#define MMIOLIMITADDRESS_0_FUNC 0x0",
                                    "range": [
                                      { "line": 154, "character": 0 },
                                      { "line": 154, "character": 35 }
                                    ],
                                    "selectionRange": [
                                      { "line": 154, "character": 8 },
                                      { "line": 154, "character": 31 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "MMIOLIMITADDRESS_0_REG",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "",
                                    "definition": "#define MMIOLIMITADDRESS_0_REG  0xD84",
                                    "implementation": "#define MMIOLIMITADDRESS_0_REG  0xD84",
                                    "range": [
                                      { "line": 155, "character": 0 },
                                      { "line": 155, "character": 37 }
                                    ],
                                    "selectionRange": [
                                      { "line": 155, "character": 8 },
                                      { "line": 155, "character": 30 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "MMIOLIMITADDRESS_1_REG",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "",
                                    "definition": "#define MMIOLIMITADDRESS_1_REG  0xD94",
                                    "implementation": "#define MMIOLIMITADDRESS_1_REG  0xD94",
                                    "range": [
                                      { "line": 157, "character": 0 },
                                      { "line": 157, "character": 37 }
                                    ],
                                    "selectionRange": [
                                      { "line": 157, "character": 8 },
                                      { "line": 157, "character": 30 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "DF_ABSTRACT_REG_WRITE",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "// Registers that are not supported in a specific program in register abstraction",
                                    "definition": "#define DF_ABSTRACT_REG_WRITE  1",
                                    "implementation": "#define DF_ABSTRACT_REG_WRITE  1",
                                    "range": [
                                      { "line": 90, "character": 0 },
                                      { "line": 90, "character": 32 }
                                    ],
                                    "selectionRange": [
                                      { "line": 90, "character": 8 },
                                      { "line": 90, "character": 29 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SilGetIp2IpApi",
                                    "kind": 11,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                                    "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                                    "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                                    "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                                    "range": [
                                      { "line": 190, "character": 0 },
                                      { "line": 219, "character": 1 }
                                    ],
                                    "selectionRange": [
                                      { "line": 191, "character": 0 },
                                      { "line": 191, "character": 14 }
                                    ],
                                    "dependencies": {
                                      "callTree": [
                                        {
                                          "name": "SIL_STATUS",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                          "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                          "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "range": [
                                            { "line": 49, "character": 0 },
                                            { "line": 74, "character": 13 }
                                          ],
                                          "selectionRange": [
                                            { "line": 74, "character": 2 },
                                            { "line": 74, "character": 12 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_CONTEXT",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                          "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                          "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "range": [
                                            { "line": 131, "character": 0 },
                                            { "line": 135, "character": 14 }
                                          ],
                                          "selectionRange": [
                                            { "line": 135, "character": 2 },
                                            { "line": 135, "character": 13 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_DATA_BLOCK_ID",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                          "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                                          "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                          "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                          "range": [
                                            { "line": 48, "character": 0 },
                                            { "line": 73, "character": 20 }
                                          ],
                                          "selectionRange": [
                                            { "line": 73, "character": 2 },
                                            { "line": 73, "character": 19 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_BLOCK_VARIABLES",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                          "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                                          "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                          "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                          "range": [
                                            { "line": 182, "character": 0 },
                                            { "line": 193, "character": 22 }
                                          ],
                                          "selectionRange": [
                                            { "line": 193, "character": 2 },
                                            { "line": 193, "character": 21 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_TRACE_ERROR",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                          "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                                          "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                          "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                          "range": [
                                            { "line": 100, "character": 0 },
                                            { "line": 100, "character": 87 }
                                          ],
                                          "selectionRange": [
                                            { "line": 100, "character": 8 },
                                            { "line": 100, "character": 23 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "__disable_tail_calls",
                                          "kind": 12,
                                          "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                          "documentation": "",
                                          "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "range": [
                                            { "line": 59, "character": 0 },
                                            { "line": 59, "character": 101 }
                                          ],
                                          "selectionRange": [
                                            { "line": 59, "character": 80 },
                                            { "line": 59, "character": 100 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "__disable_tail_calls",
                                    "kind": 12,
                                    "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                    "documentation": "",
                                    "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "range": [
                                      { "line": 59, "character": 0 },
                                      { "line": 59, "character": 101 }
                                    ],
                                    "selectionRange": [
                                      { "line": 59, "character": 80 },
                                      { "line": 59, "character": 100 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "SilArrangeMmioBelow4G",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                  "documentation": "/**\n * SilArrangeMmioBelow4G\n *\n * @brief Try to arrange MMIO below 4G\n *\n *\n * @param   SilContext                  A context structure through which host firmware defined data\n *                                      can be passed to openSIL. The host firmware is responsible\n *                                      for initializing the SIL_CONTEXT structure.\n * @param   SilData                     openSIL input block structure for RC manager\n * @param   MmioBaseAddrAbovePcieCfg    MmioBaseAddrAbovePcieCfg\n * @param   MmioBaseAddrBelowPcieCfg    MmioBaseAddrBelowPcieCfg\n * @param   MmioIsAbovePcieCfg          An bool array, indicate which RootBridge's MMIO is above Pcie Cfg\n * @param   PrimarySocket               Which socket has the primary root bridge\n * @param   PrimaryRootBridge           Primary root bridge index\n * @param   SetDfRegisters              true  - Set DF MMIO registers\n *                                      false - Do Not set DF MMIO registers, just calculate if\n *                                              user's requirement could be satisfied.\n * @param   OverSizeBelowPcieMin        OverSizeBelowPcieMin\n * @param   AlignmentMask               AlignmentMask\n * @param   EnoughAbovePcieSpaceForPrimaryRb  There's enough space above PCIE for primary root bridge\n *\n * @retval            true\n *                    false\n *\n */",
                  "definition": "static\r\nbool\r\nSilArrangeMmioBelow4G (\r\n  SIL_CONTEXT             *SilContext,\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  uint64_t                MmioBaseAddrAbovePcieCfg,\r\n  uint64_t                MmioBaseAddrBelowPcieCfg,\r\n  bool                    *MmioIsAbovePcieCfg,\r\n  uint8_t                 PrimarySocket,\r\n  uint8_t                 PrimaryRootBridge,\r\n  bool                    SetDfRegisters,\r\n  uint32_t                *OverSizeBelowPcieMin,\r\n  uint32_t                *AlignmentMask,\r\n  bool                    *EnoughAbovePcieSpaceForPrimaryRb\r\n  )",
                  "implementation": "static\r\nbool\r\nSilArrangeMmioBelow4G (\r\n  SIL_CONTEXT             *SilContext,\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  uint64_t                MmioBaseAddrAbovePcieCfg,\r\n  uint64_t                MmioBaseAddrBelowPcieCfg,\r\n  bool                    *MmioIsAbovePcieCfg,\r\n  uint8_t                 PrimarySocket,\r\n  uint8_t                 PrimaryRootBridge,\r\n  bool                    SetDfRegisters,\r\n  uint32_t                *OverSizeBelowPcieMin,\r\n  uint32_t                *AlignmentMask,\r\n  bool                    *EnoughAbovePcieSpaceForPrimaryRb\r\n  )\r\n{\r\n  uint8_t                 NumberOfRbBelowPcieCfg;\r\n  bool                    GetAnCombination;\r\n  bool                    NextCombination;\r\n  uint64_t                MmioLimitBelowPcieCfg;\r\n  APOB_IP2IP_API          *ApobIp2IpApi;\r\n  APOB_SOC_DIE_INFO       SocMaxDieInfo;\r\n  SIL_STATUS              Status;\r\n\r\n  GetAnCombination = false;\r\n  MmioLimitBelowPcieCfg = SilData->MmioLimitBelowPcieCfg;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_ApobClass, (void **) &ApobIp2IpApi);\r\n  if ((Status != SilPass) || (ApobIp2IpApi == NULL)) {\r\n    assert(Status == SilPass);\r\n    return 0;\r\n  }\r\n\r\n  ApobIp2IpApi->ApobGetMaxDieInfo(SilContext, &SocMaxDieInfo);\r\n\r\n  // Try to put 0 RootBridge, 1 RootBridge, 2 RootBridges... MAX_SYSTEM_RB_COUNT RootBridges below Pcie Cfg\r\n  for (NumberOfRbBelowPcieCfg = 0;\r\n    NumberOfRbBelowPcieCfg <= (SilData->SocketNumber * SilData->RbsPerSocket); NumberOfRbBelowPcieCfg++) {\r\n    // 1. Default, all RootBridges are above Pcie Cfg\r\n    memset(MmioIsAbovePcieCfg,\r\n      true,\r\n      (sizeof (bool) * (SocMaxDieInfo.MaxSocSocketsSupportedValue * PROJ_MAX_HOST_BRIDGES_PER_SOCKET))\r\n      );\r\n    NextCombination = true;\r\n\r\n    // 2. First, try to put RootBridge 7 to RootBridge (VH_MAX_SYSTEM_RB_COUNT - NumberOfRbBelowPcieCfg) below Pcie Cfg\r\n    if (NumberOfRbBelowPcieCfg > 0 ) {\r\n      memset((MmioIsAbovePcieCfg + (SilData->SocketNumber * SilData->RbsPerSocket) - NumberOfRbBelowPcieCfg),\r\n        false,\r\n        (sizeof (bool) * NumberOfRbBelowPcieCfg)\r\n        );\r\n    }\r\n\r\n    while (NextCombination) {\r\n      if (((*EnoughAbovePcieSpaceForPrimaryRb) &&\r\n        (*(MmioIsAbovePcieCfg + PrimarySocket * SilData->RbsPerSocket + PrimaryRootBridge))) ||\r\n        ((!(*EnoughAbovePcieSpaceForPrimaryRb)) &&\r\n        (!*(MmioIsAbovePcieCfg + PrimarySocket * SilData->RbsPerSocket + PrimaryRootBridge)))) {\r\n        // 3. Try this combination\r\n        GetAnCombination = SilTryThisCombination(SilContext,\r\n          SilData,\r\n          MmioBaseAddrAbovePcieCfg,\r\n          MmioBaseAddrBelowPcieCfg,\r\n          MmioIsAbovePcieCfg,\r\n          false,\r\n          OverSizeBelowPcieMin,\r\n          AlignmentMask\r\n          );\r\n        if (GetAnCombination) {\r\n          break;\r\n        }\r\n      }\r\n      // 4. If we can't make it, try to another combination\r\n      NextCombination = SilGetNextCombination(NumberOfRbBelowPcieCfg,\r\n        MmioIsAbovePcieCfg,\r\n        SilData->SocketNumber,\r\n        SilData->RbsPerSocket\r\n        );\r\n    }\r\n    if ((GetAnCombination) || (MmioLimitBelowPcieCfg == MmioBaseAddrBelowPcieCfg)) {\r\n      // If we already got a combination or there's no space above Pcie Cfg, then break\r\n      break;\r\n    }\r\n\r\n  }\r\n\r\n  if (GetAnCombination) {\r\n    SilTryThisCombination(SilContext,\r\n      SilData,\r\n      MmioBaseAddrAbovePcieCfg,\r\n      MmioBaseAddrBelowPcieCfg,\r\n      MmioIsAbovePcieCfg,\r\n      SetDfRegisters,\r\n      OverSizeBelowPcieMin,\r\n      AlignmentMask\r\n      );\r\n  }\r\n\r\n  return GetAnCombination;\r\n}",
                  "range": [
                    { "line": 863, "character": 0 },
                    { "line": 962, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 865, "character": 0 },
                    { "line": 865, "character": 21 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "SIL_CONTEXT",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                        "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                        "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "range": [
                          { "line": 131, "character": 0 },
                          { "line": 135, "character": 14 }
                        ],
                        "selectionRange": [
                          { "line": 135, "character": 2 },
                          { "line": 135, "character": 13 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DFX_RCMGR_INPUT_BLK",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                        "documentation": "",
                        "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                        "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                        "range": [
                          { "line": 124, "character": 0 },
                          { "line": 143, "character": 22 }
                        ],
                        "selectionRange": [
                          { "line": 143, "character": 2 },
                          { "line": 143, "character": 21 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "APOB_IP2IP_API",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/ApobIp2Ip.h",
                        "documentation": "",
                        "definition": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                        "implementation": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                        "range": [
                          { "line": 105, "character": 0 },
                          { "line": 119, "character": 17 }
                        ],
                        "selectionRange": [
                          { "line": 119, "character": 2 },
                          { "line": 119, "character": 16 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "APOB_SOC_DIE_INFO",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/Common/ApobCmn.h",
                        "documentation": "/**\n * @brief AMD APOB_SOC_DIE_INFO\n *\n */",
                        "definition": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                        "implementation": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                        "range": [
                          { "line": 544, "character": 0 },
                          { "line": 552, "character": 20 }
                        ],
                        "selectionRange": [
                          { "line": 552, "character": 2 },
                          { "line": 552, "character": 19 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_STATUS",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                        "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                        "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "range": [
                          { "line": 49, "character": 0 },
                          { "line": 74, "character": 13 }
                        ],
                        "selectionRange": [
                          { "line": 74, "character": 2 },
                          { "line": 74, "character": 12 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "PROJ_MAX_HOST_BRIDGES_PER_SOCKET",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xSIM/SoC/F19M70/F19M70Charz.h",
                        "documentation": "/**\n * @file F19M70Charz.h\n * @brief SoC characteristics constants\n */\n\n#pragma once\n\n/* SoC construction constants */\n#if      (PROJ_MAX_SOCKETS_SUPPORTED < 1)\n  #undef  PROJ_MAX_SOCKETS_SUPPORTED\n  #define PROJ_MAX_SOCKETS_SUPPORTED      1\n#endif\n#if      (PROJ_MAX_CCD_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_CCD_DIES_PER_SOCKET\n  #define PROJ_MAX_CCD_DIES_PER_SOCKET      1\n#endif\n#if      (PROJ_MAX_MEM_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_MEM_DIES_PER_SOCKET\n  #define PROJ_MAX_MEM_DIES_PER_SOCKET      1\n#endif\n#if      (PROJ_MAX_IO_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_IO_DIES_PER_SOCKET\n  #define PROJ_MAX_IO_DIES_PER_SOCKET      1\n#endif\n\n/* Processor Cores sub-system constants */\n#if      (PROJ_MAX_COMPLEXES_PER_CCD < 1)\n  #undef  PROJ_MAX_COMPLEXES_PER_CCD\n  #define PROJ_MAX_COMPLEXES_PER_CCD      1\n#endif\n#if      (PROJ_MAX_CCX_CORES_PER_COMPLEX < 8)\n  #undef  PROJ_MAX_CCX_CORES_PER_COMPLEX\n  #define PROJ_MAX_CCX_CORES_PER_COMPLEX      8\n#endif\n#if      (PROJ_MAX_CCX_THREADS_PER_CORE < 2)\n  #undef  PROJ_MAX_CCX_THREADS_PER_CORE\n  #define PROJ_MAX_CCX_THREADS_PER_CORE      2\n#endif\n#if      (PROJ_CCX_MAX_DIES_PER_SOCKET < 1)\n  #undef  PROJ_CCX_MAX_DIES_PER_SOCKET\n  #define PROJ_CCX_MAX_DIES_PER_SOCKET      1\n#endif\n\n/* Memory sub-system constants */\n#if      (PROJ_MAX_UMCS_PER_MEM_DIE < 2)\n  #undef  PROJ_MAX_UMCS_PER_MEM_DIE\n  #define PROJ_MAX_UMCS_PER_MEM_DIE      2\n#endif\n#if      (PROJ_MAX_CHANNELS_PER_UMC < 1)\n  #undef  PROJ_MAX_CHANNELS_PER_UMC\n  #define PROJ_MAX_CHANNELS_PER_UMC      1\n#endif\n#if      (PROJ_MAX_DIMMS_PER_CHANNEL < 2)\n  #undef  PROJ_MAX_DIMMS_PER_CHANNEL\n  #define PROJ_MAX_DIMMS_PER_CHANNEL      2\n#endif\n\n/* IO Hub sub-system constants */",
                        "definition": "#define PROJ_MAX_HOST_BRIDGES_PER_SOCKET      1",
                        "implementation": "#define PROJ_MAX_HOST_BRIDGES_PER_SOCKET      1",
                        "range": [
                          { "line": 66, "character": 2 },
                          { "line": 66, "character": 49 }
                        ],
                        "selectionRange": [
                          { "line": 66, "character": 10 },
                          { "line": 66, "character": 42 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SilGetIp2IpApi",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                        "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                        "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                        "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                        "range": [
                          { "line": 190, "character": 0 },
                          { "line": 219, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 191, "character": 0 },
                          { "line": 191, "character": 14 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "SIL_STATUS",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                              "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                              "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "range": [
                                { "line": 49, "character": 0 },
                                { "line": 74, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 74, "character": 2 },
                                { "line": 74, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_CONTEXT",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                              "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "range": [
                                { "line": 131, "character": 0 },
                                { "line": 135, "character": 14 }
                              ],
                              "selectionRange": [
                                { "line": 135, "character": 2 },
                                { "line": 135, "character": 13 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_DATA_BLOCK_ID",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                              "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                              "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                              "range": [
                                { "line": 48, "character": 0 },
                                { "line": 73, "character": 20 }
                              ],
                              "selectionRange": [
                                { "line": 73, "character": 2 },
                                { "line": 73, "character": 19 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_BLOCK_VARIABLES",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                              "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                              "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                              "range": [
                                { "line": 182, "character": 0 },
                                { "line": 193, "character": 22 }
                              ],
                              "selectionRange": [
                                { "line": 193, "character": 2 },
                                { "line": 193, "character": 21 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_TRACE_ERROR",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                              "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                              "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                              "range": [
                                { "line": 100, "character": 0 },
                                { "line": 100, "character": 87 }
                              ],
                              "selectionRange": [
                                { "line": 100, "character": 8 },
                                { "line": 100, "character": 23 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "__disable_tail_calls",
                              "kind": 12,
                              "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                              "documentation": "",
                              "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "range": [
                                { "line": 59, "character": 0 },
                                { "line": 59, "character": 101 }
                              ],
                              "selectionRange": [
                                { "line": 59, "character": 80 },
                                { "line": 59, "character": 100 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      },
                      {
                        "name": "__disable_tail_calls",
                        "kind": 12,
                        "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                        "documentation": "",
                        "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "range": [
                          { "line": 59, "character": 0 },
                          { "line": 59, "character": 101 }
                        ],
                        "selectionRange": [
                          { "line": 59, "character": 80 },
                          { "line": 59, "character": 100 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SilTryThisCombination",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                        "documentation": "/**\n * SilTryThisCombination\n *\n * @brief This function tries the given combination of MMIO resources.\n *\n * @details If successful, it may be requested to program DF MMIO registers.\n *\n * @param   SilContext                  A context structure through which host firmware defined data\n *                                      can be passed to openSIL. The host firmware is responsible\n *                                      for initializing the SIL_CONTEXT structure.\n * @param   SilData                     IP input block data\n * @param   MmioBaseAddrAbovePcieCfg    MmioBaseAddrAbovePcieCfg\n * @param   MmioBaseAddrBelowPcieCfg    MmioBaseAddrBelowPcieCfg\n * @param   MmioIsAbovePcieCfg          An bool array, indicate which RootBridge's MMIO is above Pcie Cfg\n * @param   SetDfRegisters              true  - Set DF MMIO registers\n *                                      false - Do Not set DF MMIO registers, just calculate if\n *                                              user's requirement could be satisfied.\n * @param   OverSizeBelowPcieMin        OverSizeBelowPcieMin\n * @param   AlignmentMask               AlignmentMask\n *\n * @retval            true                        Successful resource combination\n *                    false                       Unsuccessful resource combination\n */",
                        "definition": "static\r\nbool\r\nSilTryThisCombination (\r\n  SIL_CONTEXT          *SilContext,\r\n  DFX_RCMGR_INPUT_BLK  *SilData,\r\n  uint64_t             MmioBaseAddrAbovePcieCfg,\r\n  uint64_t             MmioBaseAddrBelowPcieCfg,\r\n  bool                 *MmioIsAbovePcieCfg,\r\n  bool                 SetDfRegisters,\r\n  uint32_t             *OverSizeBelowPcieMin,\r\n  uint32_t             *AlignmentMask\r\n  )",
                        "implementation": "static\r\nbool\r\nSilTryThisCombination (\r\n  SIL_CONTEXT          *SilContext,\r\n  DFX_RCMGR_INPUT_BLK  *SilData,\r\n  uint64_t             MmioBaseAddrAbovePcieCfg,\r\n  uint64_t             MmioBaseAddrBelowPcieCfg,\r\n  bool                 *MmioIsAbovePcieCfg,\r\n  bool                 SetDfRegisters,\r\n  uint32_t             *OverSizeBelowPcieMin,\r\n  uint32_t             *AlignmentMask\r\n  )\r\n{\r\n  uint8_t              i;\r\n  uint8_t              j;\r\n  uint8_t              SocketLoop;\r\n  uint8_t              RbLoop;\r\n  uint32_t             PrimarySocket;\r\n  uint32_t             PrimaryDie;\r\n  uint32_t             PrimaryRootBridge;\r\n  uint64_t             MmioBaseAddr;\r\n  // To calculate oversize, we must use uint64_t here for all address, size\r\n  uint64_t             MmioCeiling;\r\n  uint64_t             MmioBaseAddrPrefetchable;\r\n  uint64_t             MmioBaseAddrNonPrefetchable;\r\n  uint64_t             MmioBaseAddrNonPci;\r\n  uint64_t             PrimaryRbSecondMmioSize;\r\n  uint64_t             SizePrefetchable;\r\n  uint64_t             SizeNonPrefetchable;\r\n  uint64_t             SizeNonPci;\r\n  uint64_t             AlignMask;\r\n  uint64_t             AlignMaskP;\r\n  uint64_t             AlignMaskNonPci;\r\n  uint64_t             BottomOfCompat;\r\n  uint64_t             OverSizeAbovePcieCfg;\r\n  uint64_t             OverSizeBelowPcieCfg;\r\n  uint64_t             AlignForFirstMmioRegionAbovePcieCfg;\r\n  uint64_t             AlignForFirstMmioRegionBelowPcieCfg;\r\n  uint64_t             DeltaSize;\r\n  // this variable keeps the data how much size would be reduced if there's no NON-PCI MMIO\r\n  bool                 AlreadyGotAlignForFirstMmioRegionAbovePcieCfg;\r\n  bool                 AlreadyGotAlignForFirstMmioRegionBelowPcieCfg;\r\n  bool                 BigAlignFirstAbovePcieCfg;\r\n  bool                 BigAlignFirstBelowPcieCfg;\r\n  bool                 BigAlignFirst;\r\n  bool                 ReservedRegionAlreadySet;\r\n  bool                 OverSizeFlag;\r\n  bool                 PrimaryRbNonPciMmioAt2ndRegion;\r\n  bool                 HasSpaceBelowPcie;\r\n  uint32_t             MaxSystemRbCount;\r\n  SIL_STATUS           Status;\r\n  DF_IP2IP_API         *DfIp2IpApi;\r\n  APOB_IP2IP_API       *ApobIp2IpApi;\r\n  APOB_SOC_DIE_INFO    SocMaxDieInfo;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  assert(Status == SilPass);\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_ApobClass, (void **) &ApobIp2IpApi);\r\n  if ((Status != SilPass) || (ApobIp2IpApi == NULL)) {\r\n    assert(Status == SilPass);\r\n    return 0;\r\n  }\r\n\r\n  ApobIp2IpApi->ApobGetMaxDieInfo(SilContext, &SocMaxDieInfo);\r\n\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB *MmioSizeForEachRb = &SilData->ResourceSizeForEachRb;\r\n  uint64_t MmioLimitAbovePcieCfg;\r\n  uint64_t MmioLimitBelowPcieCfg;\r\n  DFX_FABRIC_MMIO_MANAGER *FabricMmioManager = &SilData->MmioRcMgr;\r\n\r\n  MmioLimitAbovePcieCfg = SilData->MmioLimitAbovePcieCfg;\r\n  MmioLimitBelowPcieCfg = SilData->MmioLimitBelowPcieCfg;\r\n  HasSpaceBelowPcie = (MmioLimitBelowPcieCfg > MmioBaseAddrBelowPcieCfg);\r\n  BigAlignFirstAbovePcieCfg = true;\r\n  BigAlignFirstBelowPcieCfg = true;\r\n  OverSizeFlag = false;\r\n  DeltaSize = 0;\r\n  PrimaryRbNonPciMmioAt2ndRegion = false;\r\n  AlreadyGotAlignForFirstMmioRegionAbovePcieCfg = false;\r\n  AlreadyGotAlignForFirstMmioRegionBelowPcieCfg = false;\r\n  SizeNonPci = SilData->MmioSizePerRbForNonPciDevice;\r\n  AlignMaskNonPci = RCMGR_NON_PCI_MMIO_ALIGN_MASK;\r\n  AlignForFirstMmioRegionAbovePcieCfg = 0;\r\n  AlignForFirstMmioRegionBelowPcieCfg = 0;\r\n\r\n  MaxSystemRbCount = DfIp2IpApi->DfGetNumberOfSystemRootBridges(SilContext);\r\n\r\n  SilGetPrimaryRb(SilContext, &PrimarySocket, &PrimaryDie, &PrimaryRootBridge);\r\n  BottomOfCompat = BOTTOM_OF_COMPAT;\r\n  ReservedRegionAlreadySet = false;  // Indicate if AmdBottomMmioReservedForPrimaryRb ~ BottomOfCompat is set\r\n\r\n  for (i = 0; i <= (SilData->SocketNumber * SilData->RbsPerSocket); i++) {\r\n    SocketLoop = (SilData->SocketNumber * SilData->RbsPerSocket - i - 1) / SilData->RbsPerSocket;\r\n    RbLoop = (SilData->SocketNumber * SilData->RbsPerSocket - i - 1) % SilData->RbsPerSocket;\r\n\r\n    // Skip allocating MMIO for primary RootBridge, and will allocate later\r\n    if ((SocketLoop == PrimarySocket) && (RbLoop == PrimaryRootBridge)) {\r\n      continue;\r\n    }\r\n\r\n    // This is the last loop, now try to allocate MMIO for primary RootBridge\r\n    if (i == (SilData->SocketNumber * SilData->RbsPerSocket)) {\r\n      SocketLoop = (uint8_t) PrimarySocket;\r\n      RbLoop = (uint8_t) PrimaryRootBridge;\r\n    }\r\n\r\n    if ((MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size +\r\n      MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + SizeNonPci) == 0) {\r\n      continue;\r\n    }\r\n\r\n    AlignMask = MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment;\r\n    AlignMaskP = MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment;\r\n\r\n    if (*(MmioIsAbovePcieCfg + SocketLoop * SilData->RbsPerSocket + RbLoop)) {\r\n      // Mmio is above PcieCfg\r\n      BigAlignFirst = BigAlignFirstAbovePcieCfg;\r\n      MmioBaseAddr = MmioBaseAddrAbovePcieCfg;\r\n      BigAlignFirstAbovePcieCfg = !BigAlignFirstAbovePcieCfg;\r\n\r\n      if (!AlreadyGotAlignForFirstMmioRegionAbovePcieCfg) {\r\n        // Save alignment for the first MMIO region, it will be used for calculate oversize\r\n        AlignForFirstMmioRegionAbovePcieCfg = (AlignMask > AlignMaskP) ? AlignMask : AlignMaskP;\r\n        AlreadyGotAlignForFirstMmioRegionAbovePcieCfg = true;\r\n      }\r\n    } else {\r\n      // Mmio is below PcieCfg\r\n      BigAlignFirst = BigAlignFirstBelowPcieCfg;\r\n      MmioBaseAddr = MmioBaseAddrBelowPcieCfg;\r\n      BigAlignFirstBelowPcieCfg = !BigAlignFirstBelowPcieCfg;\r\n\r\n      if (!AlreadyGotAlignForFirstMmioRegionBelowPcieCfg) {\r\n        // Save alignment for the first MMIO region, it will be used for calculate oversize\r\n        AlignForFirstMmioRegionBelowPcieCfg = (AlignMask > AlignMaskP) ? AlignMask: AlignMaskP;\r\n        AlreadyGotAlignForFirstMmioRegionBelowPcieCfg = true;\r\n      }\r\n    }\r\n\r\n    if (BigAlignFirst) {\r\n      if (MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment >=\r\n        MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment) {\r\n        // Prefetchable -> Non Prefetchable -> Non Pci\r\n        MmioBaseAddrPrefetchable = (MmioBaseAddr + AlignMaskP) & (~AlignMaskP);\r\n        MmioBaseAddrNonPrefetchable = (MmioBaseAddrPrefetchable +\r\n          MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + AlignMask) &\r\n          (~AlignMask);\r\n        MmioBaseAddrNonPci = (MmioBaseAddrNonPrefetchable +\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + AlignMaskNonPci) &\r\n          (~AlignMaskNonPci);\r\n        SizePrefetchable = MmioBaseAddrNonPrefetchable - MmioBaseAddrPrefetchable;\r\n        SizeNonPrefetchable = MmioBaseAddrNonPci - MmioBaseAddrNonPrefetchable;\r\n        MmioCeiling = MmioBaseAddrNonPci + SizeNonPci;\r\n        DeltaSize = MmioBaseAddrNonPci - MmioBaseAddrNonPrefetchable -\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + SizeNonPci;\r\n      } else {\r\n        // Non Prefetchable -> Prefetchable -> Non Pci\r\n        MmioBaseAddrNonPrefetchable = (MmioBaseAddr + AlignMask) & (~AlignMask);\r\n        MmioBaseAddrPrefetchable = (MmioBaseAddrNonPrefetchable +\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + AlignMaskP) &\r\n          (~AlignMaskP);\r\n        MmioBaseAddrNonPci = (MmioBaseAddrPrefetchable +\r\n          MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + AlignMaskNonPci) &\r\n          (~AlignMaskNonPci);\r\n        SizeNonPrefetchable = MmioBaseAddrPrefetchable - MmioBaseAddrNonPrefetchable;\r\n        SizePrefetchable = MmioBaseAddrNonPci - MmioBaseAddrPrefetchable;\r\n        MmioCeiling = MmioBaseAddrNonPci + SizeNonPci;\r\n        DeltaSize = MmioBaseAddrNonPci - MmioBaseAddrPrefetchable -\r\n          MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + SizeNonPci;\r\n      }\r\n    } else {\r\n      if (MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment <=\r\n        MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment) {\r\n        // Non Pci -> Prefetchable -> Non Prefetchable\r\n        MmioBaseAddrNonPci = (MmioBaseAddr + AlignMaskNonPci) & (~AlignMaskNonPci);\r\n        MmioBaseAddrPrefetchable = (MmioBaseAddrNonPci + SizeNonPci + AlignMaskP) & (~AlignMaskP);\r\n        MmioBaseAddrNonPrefetchable = (MmioBaseAddrPrefetchable +\r\n          MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + AlignMask) & (~AlignMask);\r\n        SizePrefetchable = MmioBaseAddrNonPrefetchable - MmioBaseAddrPrefetchable;\r\n        SizeNonPrefetchable = MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size;\r\n        MmioCeiling = MmioBaseAddrNonPrefetchable + SizeNonPrefetchable;\r\n        DeltaSize = MmioBaseAddrPrefetchable - ((MmioBaseAddr + AlignMaskP) & (~AlignMaskP));\r\n      } else {\r\n        // Non Pci -> Non Prefetchable -> Prefetchable\r\n        MmioBaseAddrNonPci = (MmioBaseAddr + AlignMaskNonPci) & (~AlignMaskNonPci);\r\n        MmioBaseAddrNonPrefetchable = (MmioBaseAddrNonPci + SizeNonPci + AlignMask) & (~AlignMask);\r\n        MmioBaseAddrPrefetchable = (MmioBaseAddrNonPrefetchable +\r\n          MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size + AlignMaskP) & (~AlignMaskP);\r\n        SizeNonPrefetchable = MmioBaseAddrPrefetchable - MmioBaseAddrNonPrefetchable;\r\n        SizePrefetchable = MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size;\r\n        MmioCeiling = MmioBaseAddrPrefetchable + SizePrefetchable;\r\n        DeltaSize = MmioBaseAddrNonPrefetchable - ((MmioBaseAddr + AlignMask) & (~AlignMask));\r\n      }\r\n    }\r\n\r\n    if (SizeNonPrefetchable == 0) {\r\n\r\n      MmioBaseAddrNonPrefetchable = 0;\r\n    }\r\n    if (SizePrefetchable == 0) {\r\n\r\n      MmioBaseAddrPrefetchable = 0;\r\n    }\r\n\r\n    // Check if space is enough\r\n    if (*(MmioIsAbovePcieCfg + SocketLoop * SilData->RbsPerSocket + RbLoop)) {\r\n      // Mmio is above PcieCfg\r\n      MmioBaseAddrAbovePcieCfg = MmioCeiling;\r\n      if (MmioBaseAddrAbovePcieCfg > MmioLimitAbovePcieCfg) {\r\n        OverSizeFlag = true;\r\n      }\r\n    } else {\r\n      // Mmio is below PcieCfg\r\n      MmioBaseAddrBelowPcieCfg = MmioCeiling;\r\n      if (MmioBaseAddrBelowPcieCfg > MmioLimitBelowPcieCfg) {\r\n        OverSizeFlag = true;\r\n      }\r\n    }\r\n\r\n    // (OverSize) && (Primary RootBridge has 2nd MMIO), try to see if moving primary RootBridge's Non-Pci MMIO\r\n    // from 1st region to 2nd region could work\r\n    // Always put Non-Pci at top of 2nd MMIO\r\n    if ((OverSizeFlag) && (SocketLoop == PrimarySocket) && (RbLoop == PrimaryRootBridge) &&\r\n      ((uint32_t)(SilData->SocketNumber * SilData->RbsPerSocket) < MaxSystemRbCount)) {\r\n      if (*(MmioIsAbovePcieCfg + SocketLoop * SilData->RbsPerSocket + RbLoop)) {\r\n        if (((MmioBaseAddrAbovePcieCfg - DeltaSize) <= MmioLimitAbovePcieCfg) &&\r\n          (MmioBaseAddrBelowPcieCfg <= ((MmioLimitBelowPcieCfg - SizeNonPci) & (~AlignMaskNonPci)))) {\r\n          OverSizeFlag = false;\r\n          PrimaryRbNonPciMmioAt2ndRegion = true;\r\n          MmioBaseAddrAbovePcieCfg -= DeltaSize;\r\n          MmioCeiling -= DeltaSize;\r\n        }\r\n      } else {\r\n        if (((MmioBaseAddrBelowPcieCfg - DeltaSize) <= MmioLimitBelowPcieCfg) &&\r\n          (MmioBaseAddrAbovePcieCfg <= ((MmioLimitAbovePcieCfg - SizeNonPci) & (~AlignMaskNonPci)))) {\r\n          OverSizeFlag = false;\r\n          PrimaryRbNonPciMmioAt2ndRegion = true;\r\n          MmioBaseAddrBelowPcieCfg -= DeltaSize;\r\n          MmioCeiling -= DeltaSize;\r\n        }\r\n      }\r\n\r\n      // Adjust MmioBaseAddrNonPrefetchable & MmioBaseAddrPrefetchable if we move primary RootBridge's NON-PCI\r\n      // from 1st region to 2nd region and NON-PCI is at lower address\r\n      if (PrimaryRbNonPciMmioAt2ndRegion && (!BigAlignFirst)) {\r\n        MmioBaseAddrNonPrefetchable -= DeltaSize;\r\n        MmioBaseAddrPrefetchable -= DeltaSize;\r\n      }\r\n    }\r\n\r\n    // Set DF MMIO registers\r\n    if ((!OverSizeFlag) && SetDfRegisters && (FabricMmioManager != NULL)) {\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"---Socket%x RootBridge%x---\\n\", SocketLoop, RbLoop);\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n        \"  Request below 4G\\n        Prefetch Size 0x%llX, AlignBit 0x%X\\n\",\r\n        MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size,\r\n        MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment\r\n        );\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n        \"    Non Prefetch Size 0x%llX, AlignBit 0x%X\\n\\n\",\r\n        MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Size,\r\n        MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment\r\n        );\r\n      assert(BottomOfCompat >= SilData->BottomMmioReservedForPrimaryRb);\r\n\r\n      if ((SocketLoop == PrimarySocket) && (RbLoop == PrimaryRootBridge)) {\r\n        if (*(MmioIsAbovePcieCfg + SocketLoop * SilData->RbsPerSocket + RbLoop)) {\r\n          Status = SilSetMmioReg4(SilContext,\r\n            DfIp2IpApi,\r\n            SilData->SocketNumber,\r\n            ((SocketLoop * SilData->RbsPerSocket + RbLoop) * 2),\r\n            SocketLoop,\r\n            RbLoop,\r\n            MmioBaseAddr,\r\n            (BottomOfCompat - MmioBaseAddr)\r\n            );\r\n          MmioBaseAddrAbovePcieCfg = BottomOfCompat;\r\n          ReservedRegionAlreadySet = true;\r\n        } else {\r\n          Status = SilSetMmioReg4(SilContext,\r\n            DfIp2IpApi,\r\n            SilData->SocketNumber,\r\n            ((SocketLoop * SilData->RbsPerSocket + RbLoop) * 2),\r\n            SocketLoop,\r\n            RbLoop,\r\n            MmioBaseAddr,\r\n            (MmioLimitBelowPcieCfg - MmioBaseAddr)\r\n            );\r\n          MmioBaseAddrBelowPcieCfg = MmioLimitBelowPcieCfg;\r\n        }\r\n      } else {\r\n        Status = SilSetMmioReg4(SilContext,\r\n          DfIp2IpApi,\r\n          SilData->SocketNumber,\r\n          ((SocketLoop * SilData->RbsPerSocket + RbLoop) * 2),\r\n          SocketLoop,\r\n          RbLoop,\r\n          MmioBaseAddr,\r\n          (MmioCeiling - MmioBaseAddr)\r\n          );\r\n      }\r\n\r\n      FabricMmioManager->AllocateMmioBelow4GOnThisRb[SocketLoop][RbLoop] = true;\r\n      if ((SocketLoop == PrimarySocket) && (RbLoop == PrimaryRootBridge) && PrimaryRbNonPciMmioAt2ndRegion) {\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"    NON-PCI MMIO of Primary RootBridge has been moved to its 2nd region\\n\");\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPci = 0;\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPci = 0;\r\n      } else {\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPci = MmioBaseAddrNonPci;\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPci = SizeNonPci;\r\n      }\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BasePrefetch = MmioBaseAddrPrefetchable;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPrefetch = MmioBaseAddrNonPrefetchable;\r\n\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizePrefetch = SizePrefetchable;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPrefetch = SizeNonPrefetchable;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].UsedSizeNonPci = 0;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].UsedSizePrefetch = 0;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].UsedSizeNonPrefetch = 0;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].AlignNonPrefetch =\r\n        MmioSizeForEachRb->NonPrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment;\r\n      FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].AlignPrefetch =\r\n        MmioSizeForEachRb->PrefetchableMmioSizeBelow4G[SocketLoop][RbLoop].Alignment;\r\n\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n        \"    Prefetch    0x%llX ~ 0x%llX, Size 0x%llX\\n\",\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BasePrefetch,\r\n        (FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BasePrefetch +\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizePrefetch),\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizePrefetch\r\n        );\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n        \"    NonPrefetch 0x%llX ~ 0x%llX, Size 0x%llX\\n\",\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPrefetch,\r\n        (FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPrefetch +\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPrefetch),\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPrefetch\r\n        );\r\n      RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n        \"    NonPci      0x%llX ~ 0x%llX, Size 0x%llX\\n\\n\",\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPci,\r\n        (FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].BaseNonPci +\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPci),\r\n        FabricMmioManager->MmioRegionBelow4G[SocketLoop][RbLoop].SizeNonPci\r\n        );\r\n    }\r\n  }\r\n\r\n  // If SetDfRegisters if FALSE, this function is called by FabricReallocateResourceForEachRb\r\n  // And we should record which combination has the minimum gap\r\n  if (!SetDfRegisters) {\r\n    if (OverSizeFlag) {\r\n      if (MmioBaseAddrAbovePcieCfg > MmioLimitAbovePcieCfg) {\r\n        OverSizeAbovePcieCfg = MmioBaseAddrAbovePcieCfg - MmioLimitAbovePcieCfg;\r\n      } else {\r\n        OverSizeAbovePcieCfg = 0;\r\n      }\r\n      if (MmioBaseAddrBelowPcieCfg > MmioLimitBelowPcieCfg) {\r\n        OverSizeBelowPcieCfg = MmioBaseAddrBelowPcieCfg - MmioLimitBelowPcieCfg;\r\n      } else {\r\n        OverSizeBelowPcieCfg = 0;\r\n      }\r\n      if (OverSizeAbovePcieCfg == 0) {\r\n        // Since user would not change PcieCfg space location, they would only change TOM,\r\n        // so we should make sure there's no oversize above PcieCfg\r\n        if (OverSizeBelowPcieCfg < *OverSizeBelowPcieMin) {\r\n          *OverSizeBelowPcieMin = (uint32_t) OverSizeBelowPcieCfg;\r\n          *AlignmentMask = (uint32_t) AlignForFirstMmioRegionBelowPcieCfg;\r\n        }\r\n      } else if (!HasSpaceBelowPcie) {\r\n        // If there's no space below PcieCfg, then OverSizeAbovePcieCfg is the size we need\r\n        *OverSizeBelowPcieMin = (uint32_t) OverSizeAbovePcieCfg;\r\n        *AlignmentMask = (uint32_t) AlignForFirstMmioRegionAbovePcieCfg;\r\n      }\r\n    } else {\r\n      *OverSizeBelowPcieMin = 0;\r\n    }\r\n  }\r\n\r\n  // Primary RootBridge's 2nd MMIO\r\n  if ((!OverSizeFlag) && SetDfRegisters && (FabricMmioManager != NULL)) {\r\n    if (((MmioBaseAddrAbovePcieCfg + RCMGR_MMIO_MIN_SIZE) <= MmioLimitAbovePcieCfg) ||\r\n      ((MmioBaseAddrBelowPcieCfg + RCMGR_MMIO_MIN_SIZE) <= MmioLimitBelowPcieCfg)) {\r\n      if ((MmioSizeForEachRb->PrimaryRbSecondNonPrefetchableMmioSizeBelow4G.Size != 0) ||\r\n        (MmioSizeForEachRb->PrimaryRbSecondPrefetchableMmioSizeBelow4G.Size != 0) || PrimaryRbNonPciMmioAt2ndRegion) {\r\n        if ((uint32_t)(SilData->SocketNumber * SilData->RbsPerSocket) < MaxSystemRbCount) {\r\n          for (i = 0; i < SocMaxDieInfo.MaxSocSocketsSupportedValue; i++) {\r\n            for (j = 0; j < SilData->RbsPerSocket; j++) {\r\n              if (FabricMmioManager->AllocateMmioBelow4GOnThisRb[i][j] == false) {\r\n                RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"  Primary RB has 2nd MMIO below 4G\\n\");\r\n                FabricMmioManager->PrimaryRb2ndMmioPairBelow4G = (uint8_t) ((i << 4) | j);\r\n                if (MmioBaseAddrAbovePcieCfg < MmioLimitAbovePcieCfg) {\r\n                  Status = SilSetMmioReg4(SilContext,\r\n                    DfIp2IpApi,\r\n                    SilData->SocketNumber,\r\n                    ((i * SilData->RbsPerSocket + j) * 2),\r\n                    PrimarySocket,\r\n                    PrimaryRootBridge,\r\n                    MmioBaseAddrAbovePcieCfg,\r\n                    (BottomOfCompat - MmioBaseAddrAbovePcieCfg)\r\n                    );\r\n                  MmioBaseAddr = MmioBaseAddrAbovePcieCfg;\r\n                  PrimaryRbSecondMmioSize = MmioLimitAbovePcieCfg - MmioBaseAddrAbovePcieCfg;\r\n                  ReservedRegionAlreadySet = true;\r\n                } else {\r\n                  Status = SilSetMmioReg4(SilContext,\r\n                    DfIp2IpApi,\r\n                    SilData->SocketNumber,\r\n                    ((i * SilData->RbsPerSocket + j) * 2),\r\n                    PrimarySocket,\r\n                    PrimaryRootBridge,\r\n                    MmioBaseAddrBelowPcieCfg,\r\n                    (MmioLimitBelowPcieCfg - MmioBaseAddrBelowPcieCfg)\r\n                    );\r\n                  MmioBaseAddr = MmioBaseAddrBelowPcieCfg;\r\n                  PrimaryRbSecondMmioSize = MmioLimitBelowPcieCfg - MmioBaseAddrBelowPcieCfg;\r\n                }\r\n                if (PrimaryRbNonPciMmioAt2ndRegion) {\r\n                  // Always put Non-Pci at top of 2nd MMIO\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPci =\r\n                    (MmioBaseAddr + PrimaryRbSecondMmioSize - SizeNonPci) & (~AlignMaskNonPci);\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPci = SizeNonPci;\r\n                  PrimaryRbSecondMmioSize = FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPci - MmioBaseAddr;\r\n                } else {\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPci = 0;\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPci = 0;\r\n                }\r\n                // Distribute Primary RB's 2nd MMIO base on user request\r\n                AlignMask = MmioSizeForEachRb->PrimaryRbSecondNonPrefetchableMmioSizeBelow4G.Alignment;\r\n                AlignMaskP = MmioSizeForEachRb->PrimaryRbSecondPrefetchableMmioSizeBelow4G.Alignment;\r\n                if (MmioSizeForEachRb->PrimaryRbSecondNonPrefetchableMmioSizeBelow4G.Size == 0) {\r\n                  SizePrefetchable = PrimaryRbSecondMmioSize;\r\n                  SizeNonPrefetchable = 0;\r\n                } else if (MmioSizeForEachRb->PrimaryRbSecondPrefetchableMmioSizeBelow4G.Size == 0) {\r\n                  SizePrefetchable = 0;\r\n                  SizeNonPrefetchable = PrimaryRbSecondMmioSize;\r\n                } else {\r\n                  SizePrefetchable = (PrimaryRbSecondMmioSize /\r\n                    ((uint32_t) (MmioSizeForEachRb->PrimaryRbSecondPrefetchableMmioSizeBelow4G.Size +\r\n                    MmioSizeForEachRb->PrimaryRbSecondNonPrefetchableMmioSizeBelow4G.Size))) *\r\n                    MmioSizeForEachRb->PrimaryRbSecondPrefetchableMmioSizeBelow4G.Size;\r\n                  SizeNonPrefetchable = PrimaryRbSecondMmioSize - SizePrefetchable;\r\n                }\r\n\r\n                if (SizePrefetchable != 0) {\r\n                  MmioBaseAddrPrefetchable = (MmioBaseAddr + AlignMaskP) & (~AlignMaskP);\r\n                } else {\r\n                  MmioBaseAddrPrefetchable = MmioBaseAddr;\r\n                  SizePrefetchable = 0;\r\n                }\r\n\r\n                if (SizeNonPrefetchable != 0) {\r\n                  MmioBaseAddrNonPrefetchable = (MmioBaseAddrPrefetchable + SizePrefetchable + AlignMask) &\r\n                    (~AlignMask);\r\n                  SizeNonPrefetchable = MmioBaseAddr + PrimaryRbSecondMmioSize - MmioBaseAddrNonPrefetchable;\r\n                } else {\r\n                  MmioBaseAddrNonPrefetchable = MmioBaseAddrPrefetchable + SizePrefetchable;\r\n                  SizeNonPrefetchable = 0;\r\n                }\r\n\r\n                if (SizeNonPrefetchable == 0) {\r\n\r\n                  MmioBaseAddrNonPrefetchable = 0;\r\n                }\r\n                if (SizePrefetchable == 0) {\r\n\r\n                  MmioBaseAddrPrefetchable = 0;\r\n                }\r\n\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].BasePrefetch = MmioBaseAddrPrefetchable;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPrefetch = MmioBaseAddrNonPrefetchable;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].SizePrefetch = SizePrefetchable;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPrefetch = SizeNonPrefetchable;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].UsedSizePrefetch = 0;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].UsedSizeNonPrefetch = 0;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].UsedSizeNonPci = 0;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].AlignNonPrefetch =\r\n                  MmioSizeForEachRb->PrimaryRbSecondNonPrefetchableMmioSizeBelow4G.Alignment;\r\n                FabricMmioManager->MmioRegionBelow4G[i][j].AlignPrefetch =\r\n                  MmioSizeForEachRb->PrimaryRbSecondPrefetchableMmioSizeBelow4G.Alignment;\r\n\r\n                RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n                  \"    Prefetch    0x%llX ~ 0x%llX, Size 0x%llX\\n\",\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].BasePrefetch,\r\n                  (FabricMmioManager->MmioRegionBelow4G[i][j].BasePrefetch +\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizePrefetch),\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizePrefetch\r\n                  );\r\n                RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n                  \"    NonPrefetch 0x%llX ~ 0x%llX, Size 0x%llX\\n\",\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPrefetch,\r\n                  (FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPrefetch +\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPrefetch),\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPrefetch\r\n                  );\r\n                RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n                  \"    NonPci      0x%llX ~ 0x%llX, Size 0x%llX\\n\\n\",\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPci,\r\n                  (FabricMmioManager->MmioRegionBelow4G[i][j].BaseNonPci +\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPci),\r\n                  FabricMmioManager->MmioRegionBelow4G[i][j].SizeNonPci\r\n                  );\r\n\r\n                FabricMmioManager->PrimaryRbHas2ndMmioBelow4G = true;\r\n                break;\r\n              }\r\n            }\r\n            if (FabricMmioManager->PrimaryRbHas2ndMmioBelow4G) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // If there's a spare MMIO register pair, set 0xFED0_0000 ~ 0xFED0_FFFF as posted\r\n    SilAdditionalMmioSetting4(SilContext, SilData, BottomOfCompat, ReservedRegionAlreadySet);\r\n  }\r\n\r\n  return (!OverSizeFlag);\r\n}",
                        "range": [
                          { "line": 315, "character": 0 },
                          { "line": 835, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 317, "character": 0 },
                          { "line": 317, "character": 21 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "SIL_CONTEXT",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                              "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "range": [
                                { "line": 131, "character": 0 },
                                { "line": 135, "character": 14 }
                              ],
                              "selectionRange": [
                                { "line": 135, "character": 2 },
                                { "line": 135, "character": 13 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "DFX_RCMGR_INPUT_BLK",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                              "documentation": "",
                              "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                              "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                              "range": [
                                { "line": 124, "character": 0 },
                                { "line": 143, "character": 22 }
                              ],
                              "selectionRange": [
                                { "line": 143, "character": 2 },
                                { "line": 143, "character": 21 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_STATUS",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                              "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                              "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "range": [
                                { "line": 49, "character": 0 },
                                { "line": 74, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 74, "character": 2 },
                                { "line": 74, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "DF_IP2IP_API",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                              "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                              "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                              "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                              "range": [
                                { "line": 199, "character": 0 },
                                { "line": 226, "character": 15 }
                              ],
                              "selectionRange": [
                                { "line": 226, "character": 2 },
                                { "line": 226, "character": 14 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "APOB_IP2IP_API",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/ApobIp2Ip.h",
                              "documentation": "",
                              "definition": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                              "implementation": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                              "range": [
                                { "line": 105, "character": 0 },
                                { "line": 119, "character": 17 }
                              ],
                              "selectionRange": [
                                { "line": 119, "character": 2 },
                                { "line": 119, "character": 16 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "APOB_SOC_DIE_INFO",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/Common/ApobCmn.h",
                              "documentation": "/**\n * @brief AMD APOB_SOC_DIE_INFO\n *\n */",
                              "definition": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                              "implementation": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                              "range": [
                                { "line": 544, "character": 0 },
                                { "line": 552, "character": 20 }
                              ],
                              "selectionRange": [
                                { "line": 552, "character": 2 },
                                { "line": 552, "character": 19 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "DFX_FABRIC_RESOURCE_FOR_EACH_RB",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                              "documentation": "/// Resource for each RootBridge",
                              "definition": "typedef struct {\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondNonPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  IO[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  uint16_t              PciBusNumber[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n} DFX_FABRIC_RESOURCE_FOR_EACH_RB;",
                              "implementation": "typedef struct {\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondNonPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  IO[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  uint16_t              PciBusNumber[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n} DFX_FABRIC_RESOURCE_FOR_EACH_RB;",
                              "range": [
                                { "line": 74, "character": 0 },
                                { "line": 83, "character": 34 }
                              ],
                              "selectionRange": [
                                { "line": 83, "character": 2 },
                                { "line": 83, "character": 33 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "DFX_FABRIC_MMIO_MANAGER",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                              "documentation": "",
                              "definition": "typedef struct {\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  bool    AllocateMmioAbove4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO above 4G?\r\n  bool    AllocateMmioBelow4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO below 4G?\r\n  bool    PrimaryRbHas2ndMmioBelow4G;                                               ///< Indicate if RootBridge 0 has a 2nd MMIO which is below 4G\r\n  bool    ReportToGcd;                                                              ///< TRUE - Need to report GCD if user call FabricAllocateMmio\r\n  uint8_t PrimaryRb2ndMmioPairBelow4G;                                              ///< Since AllocateMmioOnThisRootBridge[i][j] is FALSE, use this one for\r\n                                                                                    ///< RootBridge0's 2nd MMIO, RootBridge02ndMmioPair = (i << 4) | j\r\n  uint64_t  Reserved;                                                               ///< compatibility (ImageHandle)\r\n} DFX_FABRIC_MMIO_MANAGER;",
                              "implementation": "typedef struct {\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  bool    AllocateMmioAbove4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO above 4G?\r\n  bool    AllocateMmioBelow4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO below 4G?\r\n  bool    PrimaryRbHas2ndMmioBelow4G;                                               ///< Indicate if RootBridge 0 has a 2nd MMIO which is below 4G\r\n  bool    ReportToGcd;                                                              ///< TRUE - Need to report GCD if user call FabricAllocateMmio\r\n  uint8_t PrimaryRb2ndMmioPairBelow4G;                                              ///< Since AllocateMmioOnThisRootBridge[i][j] is FALSE, use this one for\r\n                                                                                    ///< RootBridge0's 2nd MMIO, RootBridge02ndMmioPair = (i << 4) | j\r\n  uint64_t  Reserved;                                                               ///< compatibility (ImageHandle)\r\n} DFX_FABRIC_MMIO_MANAGER;",
                              "range": [
                                { "line": 100, "character": 0 },
                                { "line": 110, "character": 26 }
                              ],
                              "selectionRange": [
                                { "line": 110, "character": 2 },
                                { "line": 110, "character": 25 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "RCMGR_NON_PCI_MMIO_ALIGN_MASK",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                              "documentation": "",
                              "definition": "#define RCMGR_NON_PCI_MMIO_ALIGN_MASK       0xFFFFull       // MMIO for non-PCI devices should be 16 bit aligned",
                              "implementation": "#define RCMGR_NON_PCI_MMIO_ALIGN_MASK       0xFFFFull       // MMIO for non-PCI devices should be 16 bit aligned",
                              "range": [
                                { "line": 26, "character": 0 },
                                { "line": 26, "character": 112 }
                              ],
                              "selectionRange": [
                                { "line": 26, "character": 8 },
                                { "line": 26, "character": 37 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "BOTTOM_OF_COMPAT",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                              "documentation": "",
                              "definition": "#define BOTTOM_OF_COMPAT           0xFEC00000ul // From BOTTOM_OF_COMPAT to 4G would be leaved as undescribed (COMPAT)",
                              "implementation": "#define BOTTOM_OF_COMPAT           0xFEC00000ul // From BOTTOM_OF_COMPAT to 4G would be leaved as undescribed (COMPAT)",
                              "range": [
                                { "line": 37, "character": 0 },
                                { "line": 37, "character": 118 }
                              ],
                              "selectionRange": [
                                { "line": 37, "character": 8 },
                                { "line": 37, "character": 24 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "RCMGR_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                              "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
                              "definition": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                              "implementation": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                              "range": [
                                { "line": 18, "character": 0 },
                                { "line": 23, "character": 19 }
                              ],
                              "selectionRange": [
                                { "line": 18, "character": 8 },
                                { "line": 18, "character": 24 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_TRACE_INFO",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                              "definition": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                              "implementation": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                              "range": [
                                { "line": 104, "character": 0 },
                                { "line": 104, "character": 118 }
                              ],
                              "selectionRange": [
                                { "line": 104, "character": 8 },
                                { "line": 104, "character": 22 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "RCMGR_MMIO_MIN_SIZE",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                              "documentation": "",
                              "definition": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                              "implementation": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                              "range": [
                                { "line": 25, "character": 0 },
                                { "line": 25, "character": 53 }
                              ],
                              "selectionRange": [
                                { "line": 25, "character": 8 },
                                { "line": 25, "character": 27 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SilGetIp2IpApi",
                              "kind": 11,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                              "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                              "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                              "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                              "range": [
                                { "line": 190, "character": 0 },
                                { "line": 219, "character": 1 }
                              ],
                              "selectionRange": [
                                { "line": 191, "character": 0 },
                                { "line": 191, "character": 14 }
                              ],
                              "dependencies": {
                                "callTree": [
                                  {
                                    "name": "SIL_STATUS",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                    "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                    "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "range": [
                                      { "line": 49, "character": 0 },
                                      { "line": 74, "character": 13 }
                                    ],
                                    "selectionRange": [
                                      { "line": 74, "character": 2 },
                                      { "line": 74, "character": 12 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_CONTEXT",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                    "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "range": [
                                      { "line": 131, "character": 0 },
                                      { "line": 135, "character": 14 }
                                    ],
                                    "selectionRange": [
                                      { "line": 135, "character": 2 },
                                      { "line": 135, "character": 13 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_DATA_BLOCK_ID",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                                    "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                    "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                    "range": [
                                      { "line": 48, "character": 0 },
                                      { "line": 73, "character": 20 }
                                    ],
                                    "selectionRange": [
                                      { "line": 73, "character": 2 },
                                      { "line": 73, "character": 19 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_BLOCK_VARIABLES",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                    "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                                    "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                    "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                    "range": [
                                      { "line": 182, "character": 0 },
                                      { "line": 193, "character": 22 }
                                    ],
                                    "selectionRange": [
                                      { "line": 193, "character": 2 },
                                      { "line": 193, "character": 21 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_TRACE_ERROR",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                    "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                                    "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                    "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                    "range": [
                                      { "line": 100, "character": 0 },
                                      { "line": 100, "character": 87 }
                                    ],
                                    "selectionRange": [
                                      { "line": 100, "character": 8 },
                                      { "line": 100, "character": 23 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "__disable_tail_calls",
                                    "kind": 12,
                                    "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                    "documentation": "",
                                    "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "range": [
                                      { "line": 59, "character": 0 },
                                      { "line": 59, "character": 101 }
                                    ],
                                    "selectionRange": [
                                      { "line": 59, "character": 80 },
                                      { "line": 59, "character": 100 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "__disable_tail_calls",
                              "kind": 12,
                              "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                              "documentation": "",
                              "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "range": [
                                { "line": 59, "character": 0 },
                                { "line": 59, "character": 101 }
                              ],
                              "selectionRange": [
                                { "line": 59, "character": 80 },
                                { "line": 59, "character": 100 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SilGetPrimaryRb",
                              "kind": 11,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricRcInit.c",
                              "documentation": "/**\n * SilGetPrimaryRb\n *\n * @brief Returns primary RB socket number and RB number\n *\n * @param   SilContext          A context structure through which host firmware defined data\n *                              can be passed to openSIL. The host firmware is responsible\n *                              for initializing the SIL_CONTEXT structure.\n * @param   SocketNum           Primary RB socket number\n * @param   RootBridgeNum       Primary RB number\n *\n */",
                              "definition": "void\r\nSilGetPrimaryRb (\r\n  SIL_CONTEXT      *SilContext,\r\n  uint32_t         *SocketNum,\r\n  uint32_t         *DieNum,\r\n  uint32_t         *RootBridgeNum\r\n  )",
                              "implementation": "void\r\nSilGetPrimaryRb (\r\n  SIL_CONTEXT      *SilContext,\r\n  uint32_t         *SocketNum,\r\n  uint32_t         *DieNum,\r\n  uint32_t         *RootBridgeNum\r\n  )\r\n{\r\n  ROOT_BRIDGE_LOCATION Location;\r\n  DF_IP2IP_API *DfIp2IpApi;\r\n  SIL_STATUS           Status;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  if (Status != SilPass) {\r\n    assert(Status == SilPass);\r\n    return;\r\n  }\r\n\r\n  if (DfIp2IpApi->DfGetSystemComponentRootBridgeLocation(SilContext, PrimaryFch, &Location)) {\r\n    *SocketNum = Location.Socket;\r\n    *DieNum = Location.Die;\r\n    *RootBridgeNum = Location.Index;\r\n  } else {\r\n    *SocketNum = 0;\r\n    *DieNum = 0;\r\n    *RootBridgeNum = 0;\r\n  }\r\n}",
                              "range": [
                                { "line": 25, "character": 0 },
                                { "line": 52, "character": 1 }
                              ],
                              "selectionRange": [
                                { "line": 26, "character": 0 },
                                { "line": 26, "character": 15 }
                              ],
                              "dependencies": {
                                "callTree": [
                                  {
                                    "name": "SIL_CONTEXT",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                    "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "range": [
                                      { "line": 131, "character": 0 },
                                      { "line": 135, "character": 14 }
                                    ],
                                    "selectionRange": [
                                      { "line": 135, "character": 2 },
                                      { "line": 135, "character": 13 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "ROOT_BRIDGE_LOCATION",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/SilBaseFabricTopologyLib.h",
                                    "documentation": "/// Root Bridge location",
                                    "definition": "typedef struct {\r\n  uint32_t       Socket;\r\n  uint32_t       Die;\r\n  uint32_t       Index;\r\n} ROOT_BRIDGE_LOCATION;",
                                    "implementation": "typedef struct {\r\n  uint32_t       Socket;\r\n  uint32_t       Die;\r\n  uint32_t       Index;\r\n} ROOT_BRIDGE_LOCATION;",
                                    "range": [
                                      { "line": 24, "character": 0 },
                                      { "line": 28, "character": 23 }
                                    ],
                                    "selectionRange": [
                                      { "line": 28, "character": 2 },
                                      { "line": 28, "character": 22 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "DF_IP2IP_API",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                                    "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                                    "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                    "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                    "range": [
                                      { "line": 199, "character": 0 },
                                      { "line": 226, "character": 15 }
                                    ],
                                    "selectionRange": [
                                      { "line": 226, "character": 2 },
                                      { "line": 226, "character": 14 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_STATUS",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                    "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                    "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "range": [
                                      { "line": 49, "character": 0 },
                                      { "line": 74, "character": 13 }
                                    ],
                                    "selectionRange": [
                                      { "line": 74, "character": 2 },
                                      { "line": 74, "character": 12 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SilGetIp2IpApi",
                                    "kind": 11,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                                    "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                                    "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                                    "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                                    "range": [
                                      { "line": 190, "character": 0 },
                                      { "line": 219, "character": 1 }
                                    ],
                                    "selectionRange": [
                                      { "line": 191, "character": 0 },
                                      { "line": 191, "character": 14 }
                                    ],
                                    "dependencies": {
                                      "callTree": [
                                        {
                                          "name": "SIL_STATUS",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                          "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                          "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "range": [
                                            { "line": 49, "character": 0 },
                                            { "line": 74, "character": 13 }
                                          ],
                                          "selectionRange": [
                                            { "line": 74, "character": 2 },
                                            { "line": 74, "character": 12 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_CONTEXT",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                          "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                          "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "range": [
                                            { "line": 131, "character": 0 },
                                            { "line": 135, "character": 14 }
                                          ],
                                          "selectionRange": [
                                            { "line": 135, "character": 2 },
                                            { "line": 135, "character": 13 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_DATA_BLOCK_ID",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                          "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                                          "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                          "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                          "range": [
                                            { "line": 48, "character": 0 },
                                            { "line": 73, "character": 20 }
                                          ],
                                          "selectionRange": [
                                            { "line": 73, "character": 2 },
                                            { "line": 73, "character": 19 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_BLOCK_VARIABLES",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                          "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                                          "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                          "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                          "range": [
                                            { "line": 182, "character": 0 },
                                            { "line": 193, "character": 22 }
                                          ],
                                          "selectionRange": [
                                            { "line": 193, "character": 2 },
                                            { "line": 193, "character": 21 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_TRACE_ERROR",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                          "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                                          "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                          "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                          "range": [
                                            { "line": 100, "character": 0 },
                                            { "line": 100, "character": 87 }
                                          ],
                                          "selectionRange": [
                                            { "line": 100, "character": 8 },
                                            { "line": 100, "character": 23 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "__disable_tail_calls",
                                          "kind": 12,
                                          "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                          "documentation": "",
                                          "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "range": [
                                            { "line": 59, "character": 0 },
                                            { "line": 59, "character": 101 }
                                          ],
                                          "selectionRange": [
                                            { "line": 59, "character": 80 },
                                            { "line": 59, "character": 100 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "__disable_tail_calls",
                                    "kind": 12,
                                    "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                    "documentation": "",
                                    "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "range": [
                                      { "line": 59, "character": 0 },
                                      { "line": 59, "character": 101 }
                                    ],
                                    "selectionRange": [
                                      { "line": 59, "character": 80 },
                                      { "line": 59, "character": 100 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "SilSetMmioReg4",
                              "kind": 11,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                              "documentation": "/**\n * SilSetMmioReg4\n *\n * @brief Set MMIO register pairs according to input parameters\n *\n * @param   SilContext      A context structure through which host firmware defined data\n *                          can be passed to openSIL. The host firmware is responsible\n *                          for initializing the SIL_CONTEXT structure.\n * @param   DfIp2IpApi      A pointer to the data fabric I2I api\n * @param   TotalSocket     System socket count\n * @param   MmioPairIndex   Which MMIO register pair should be set\n * @param   SktNum          Socket number\n * @param   RbNum           Root bridge number\n * @param   BaseAddress     Base address of MMIO region\n * @param   Length          Length of MMIO region\n *\n */",
                              "definition": "SIL_STATUS\r\nSilSetMmioReg4 (\r\n  SIL_CONTEXT                   *SilContext,\r\n  DF_IP2IP_API                  *DfIp2IpApi,\r\n  uint8_t                       TotalSocket,\r\n  uint8_t                       MmioPairIndex,\r\n  uint32_t                      SktNum,\r\n  uint32_t                      RbNum,\r\n  uint64_t                      BaseAddress,\r\n  uint64_t                      Length\r\n  )",
                              "implementation": "SIL_STATUS\r\nSilSetMmioReg4 (\r\n  SIL_CONTEXT                   *SilContext,\r\n  DF_IP2IP_API                  *DfIp2IpApi,\r\n  uint8_t                       TotalSocket,\r\n  uint8_t                       MmioPairIndex,\r\n  uint32_t                      SktNum,\r\n  uint32_t                      RbNum,\r\n  uint64_t                      BaseAddress,\r\n  uint64_t                      Length\r\n  )\r\n{\r\n  uint32_t            DiePerSkt;\r\n  SIL_STATUS          Status;\r\n  APOB_SOC_DIE_INFO   SocMaxDieInfo;\r\n  APOB_IP2IP_API      *ApobIp2IpApi;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_ApobClass, (void **) &ApobIp2IpApi);\r\n  if ((Status != SilPass) || (ApobIp2IpApi == NULL)) {\r\n    assert(Status == SilPass);\r\n  } else {\r\n    ApobIp2IpApi->ApobGetMaxDieInfo(SilContext, &SocMaxDieInfo);\r\n    assert(Length >= RCMGR_MMIO_MIN_SIZE);\r\n    BaseAddress = (BaseAddress + 0xFFFF) & 0xFFFFFFFFFFFF0000;\r\n\r\n    DiePerSkt = DfIp2IpApi->DfGetNumberOfDiesOnSocket(SilContext, SktNum);\r\n    if (DiePerSkt <= SocMaxDieInfo.MaxSocDiesPerSocketValue) {\r\n      for (uint32_t i = 0; i < TotalSocket; i++) {\r\n        for (uint32_t j = 0; j < DiePerSkt; j++) {\r\n          DfIp2IpApi->DfFabricRegisterAccWrite(SilContext,\r\n            i,\r\n            j,\r\n            MMIOBASEADDRESS_0_FUNC,\r\n            (MMIOBASEADDRESS_0_REG + MmioPairIndex * (MMIOBASEADDRESS_1_REG - MMIOBASEADDRESS_0_REG)),\r\n            FABRIC_REG_ACC_BC,\r\n            (uint32_t) (BaseAddress >> 16)\r\n            );\r\n          DfIp2IpApi->DfFabricRegisterAccWrite(SilContext,\r\n            i,\r\n            j,\r\n            MMIOLIMITADDRESS_0_FUNC,\r\n            (MMIOLIMITADDRESS_0_REG + MmioPairIndex * (MMIOLIMITADDRESS_1_REG - MMIOLIMITADDRESS_0_REG)),\r\n            FABRIC_REG_ACC_BC,\r\n            (uint32_t) ((BaseAddress + Length - 1) >> 16)\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_RE,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            1,\r\n            0\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_WE,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            1,\r\n            0\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_DstFabricID,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            (uint32_t) DfIp2IpApi->DfGetHostBridgeSystemFabricID(SilContext, SktNum, 0, RbNum),\r\n            0\r\n            );\r\n        }\r\n      }\r\n    }\r\n\r\n    Status = SilPass;\r\n  }\r\n\r\n  return Status;\r\n}",
                              "range": [
                                { "line": 1594, "character": 0 },
                                { "line": 1680, "character": 1 }
                              ],
                              "selectionRange": [
                                { "line": 1595, "character": 0 },
                                { "line": 1595, "character": 14 }
                              ],
                              "dependencies": {
                                "callTree": [
                                  {
                                    "name": "SIL_STATUS",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                    "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                    "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "range": [
                                      { "line": 49, "character": 0 },
                                      { "line": 74, "character": 13 }
                                    ],
                                    "selectionRange": [
                                      { "line": 74, "character": 2 },
                                      { "line": 74, "character": 12 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_CONTEXT",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                    "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "range": [
                                      { "line": 131, "character": 0 },
                                      { "line": 135, "character": 14 }
                                    ],
                                    "selectionRange": [
                                      { "line": 135, "character": 2 },
                                      { "line": 135, "character": 13 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "DF_IP2IP_API",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                                    "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                                    "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                    "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                    "range": [
                                      { "line": 199, "character": 0 },
                                      { "line": 226, "character": 15 }
                                    ],
                                    "selectionRange": [
                                      { "line": 226, "character": 2 },
                                      { "line": 226, "character": 14 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "APOB_SOC_DIE_INFO",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/Common/ApobCmn.h",
                                    "documentation": "/**\n * @brief AMD APOB_SOC_DIE_INFO\n *\n */",
                                    "definition": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                                    "implementation": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                                    "range": [
                                      { "line": 544, "character": 0 },
                                      { "line": 552, "character": 20 }
                                    ],
                                    "selectionRange": [
                                      { "line": 552, "character": 2 },
                                      { "line": 552, "character": 19 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "APOB_IP2IP_API",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/ApobIp2Ip.h",
                                    "documentation": "",
                                    "definition": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                                    "implementation": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                                    "range": [
                                      { "line": 105, "character": 0 },
                                      { "line": 119, "character": 17 }
                                    ],
                                    "selectionRange": [
                                      { "line": 119, "character": 2 },
                                      { "line": 119, "character": 16 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "RCMGR_MMIO_MIN_SIZE",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                                    "documentation": "",
                                    "definition": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                                    "implementation": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                                    "range": [
                                      { "line": 25, "character": 0 },
                                      { "line": 25, "character": 53 }
                                    ],
                                    "selectionRange": [
                                      { "line": 25, "character": 8 },
                                      { "line": 25, "character": 27 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "MMIOBASEADDRESS_0_FUNC",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "",
                                    "definition": "#define MMIOBASEADDRESS_0_FUNC 0x0",
                                    "implementation": "#define MMIOBASEADDRESS_0_FUNC 0x0",
                                    "range": [
                                      { "line": 149, "character": 0 },
                                      { "line": 149, "character": 34 }
                                    ],
                                    "selectionRange": [
                                      { "line": 149, "character": 8 },
                                      { "line": 149, "character": 30 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "MMIOBASEADDRESS_0_REG",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "",
                                    "definition": "#define MMIOBASEADDRESS_0_REG  0xD80",
                                    "implementation": "#define MMIOBASEADDRESS_0_REG  0xD80",
                                    "range": [
                                      { "line": 150, "character": 0 },
                                      { "line": 150, "character": 36 }
                                    ],
                                    "selectionRange": [
                                      { "line": 150, "character": 8 },
                                      { "line": 150, "character": 29 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "MMIOBASEADDRESS_1_REG",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "",
                                    "definition": "#define MMIOBASEADDRESS_1_REG  0xD90",
                                    "implementation": "#define MMIOBASEADDRESS_1_REG  0xD90",
                                    "range": [
                                      { "line": 152, "character": 0 },
                                      { "line": 152, "character": 36 }
                                    ],
                                    "selectionRange": [
                                      { "line": 152, "character": 8 },
                                      { "line": 152, "character": 29 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "FABRIC_REG_ACC_BC",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/FabricRegisterAccCmn.h",
                                    "documentation": "/**\n * @file  FabricRegisterAccCmn.h\n * @brief Common definitions for Df fabric register access\n *\n */",
                                    "definition": "#define FABRIC_REG_ACC_BC    (0xFFFFFFFF)",
                                    "implementation": "#define FABRIC_REG_ACC_BC    (0xFFFFFFFF)",
                                    "range": [
                                      { "line": 12, "character": 0 },
                                      { "line": 12, "character": 41 }
                                    ],
                                    "selectionRange": [
                                      { "line": 12, "character": 8 },
                                      { "line": 12, "character": 25 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "MMIOLIMITADDRESS_0_FUNC",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "",
                                    "definition": "#define MMIOLIMITADDRESS_0_FUNC 0x0",
                                    "implementation": "#define MMIOLIMITADDRESS_0_FUNC 0x0",
                                    "range": [
                                      { "line": 154, "character": 0 },
                                      { "line": 154, "character": 35 }
                                    ],
                                    "selectionRange": [
                                      { "line": 154, "character": 8 },
                                      { "line": 154, "character": 31 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "MMIOLIMITADDRESS_0_REG",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "",
                                    "definition": "#define MMIOLIMITADDRESS_0_REG  0xD84",
                                    "implementation": "#define MMIOLIMITADDRESS_0_REG  0xD84",
                                    "range": [
                                      { "line": 155, "character": 0 },
                                      { "line": 155, "character": 37 }
                                    ],
                                    "selectionRange": [
                                      { "line": 155, "character": 8 },
                                      { "line": 155, "character": 30 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "MMIOLIMITADDRESS_1_REG",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "",
                                    "definition": "#define MMIOLIMITADDRESS_1_REG  0xD94",
                                    "implementation": "#define MMIOLIMITADDRESS_1_REG  0xD94",
                                    "range": [
                                      { "line": 157, "character": 0 },
                                      { "line": 157, "character": 37 }
                                    ],
                                    "selectionRange": [
                                      { "line": 157, "character": 8 },
                                      { "line": 157, "character": 30 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "DF_ABSTRACT_REG_WRITE",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                    "documentation": "// Registers that are not supported in a specific program in register abstraction",
                                    "definition": "#define DF_ABSTRACT_REG_WRITE  1",
                                    "implementation": "#define DF_ABSTRACT_REG_WRITE  1",
                                    "range": [
                                      { "line": 90, "character": 0 },
                                      { "line": 90, "character": 32 }
                                    ],
                                    "selectionRange": [
                                      { "line": 90, "character": 8 },
                                      { "line": 90, "character": 29 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SilGetIp2IpApi",
                                    "kind": 11,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                                    "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                                    "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                                    "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                                    "range": [
                                      { "line": 190, "character": 0 },
                                      { "line": 219, "character": 1 }
                                    ],
                                    "selectionRange": [
                                      { "line": 191, "character": 0 },
                                      { "line": 191, "character": 14 }
                                    ],
                                    "dependencies": {
                                      "callTree": [
                                        {
                                          "name": "SIL_STATUS",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                          "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                          "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "range": [
                                            { "line": 49, "character": 0 },
                                            { "line": 74, "character": 13 }
                                          ],
                                          "selectionRange": [
                                            { "line": 74, "character": 2 },
                                            { "line": 74, "character": 12 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_CONTEXT",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                          "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                          "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "range": [
                                            { "line": 131, "character": 0 },
                                            { "line": 135, "character": 14 }
                                          ],
                                          "selectionRange": [
                                            { "line": 135, "character": 2 },
                                            { "line": 135, "character": 13 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_DATA_BLOCK_ID",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                          "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                                          "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                          "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                          "range": [
                                            { "line": 48, "character": 0 },
                                            { "line": 73, "character": 20 }
                                          ],
                                          "selectionRange": [
                                            { "line": 73, "character": 2 },
                                            { "line": 73, "character": 19 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_BLOCK_VARIABLES",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                          "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                                          "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                          "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                          "range": [
                                            { "line": 182, "character": 0 },
                                            { "line": 193, "character": 22 }
                                          ],
                                          "selectionRange": [
                                            { "line": 193, "character": 2 },
                                            { "line": 193, "character": 21 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_TRACE_ERROR",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                          "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                                          "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                          "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                          "range": [
                                            { "line": 100, "character": 0 },
                                            { "line": 100, "character": 87 }
                                          ],
                                          "selectionRange": [
                                            { "line": 100, "character": 8 },
                                            { "line": 100, "character": 23 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "__disable_tail_calls",
                                          "kind": 12,
                                          "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                          "documentation": "",
                                          "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "range": [
                                            { "line": 59, "character": 0 },
                                            { "line": 59, "character": 101 }
                                          ],
                                          "selectionRange": [
                                            { "line": 59, "character": 80 },
                                            { "line": 59, "character": 100 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "__disable_tail_calls",
                                    "kind": 12,
                                    "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                    "documentation": "",
                                    "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "range": [
                                      { "line": 59, "character": 0 },
                                      { "line": 59, "character": 101 }
                                    ],
                                    "selectionRange": [
                                      { "line": 59, "character": 80 },
                                      { "line": 59, "character": 100 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "SilAdditionalMmioSetting4",
                              "kind": 11,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                              "documentation": "/**\n * SilAdditionalMmioSetting4\n *\n * @brief Additional MMIO settings\n *\n * @details If reserved region for primary RB (AmdBottomMmioReservedForPrimaryRb ~ BottomOfCompat) has not been set,\n * or that region doesn't include\n * ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START ~ ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END,\n * set ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START ~ ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END as POSTED\n *\n * @param   SilContext                  A context structure through which host firmware defined data\n *                                      can be passed to openSIL. The host firmware is responsible\n *                                      for initializing the SIL_CONTEXT structure.\n * @param   SilData                     IP input block data\n * @param   BottomOfCompat              From BottomOfCompat to 4G is COMPAT region\n * @param   ReservedRegionAlreadySet    AmdBottomMmioReservedForPrimaryRb ~ BottomOfCompat has been set or not\n *\n */",
                              "definition": "void\r\nSilAdditionalMmioSetting4 (\r\n  SIL_CONTEXT             *SilContext,\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  uint64_t                BottomOfCompat,\r\n  bool                    ReservedRegionAlreadySet\r\n  )",
                              "implementation": "void\r\nSilAdditionalMmioSetting4 (\r\n  SIL_CONTEXT             *SilContext,\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  uint64_t                BottomOfCompat,\r\n  bool                    ReservedRegionAlreadySet\r\n  )\r\n{\r\n  uint8_t                 i;\r\n  uint8_t                 j;\r\n  uint64_t                Base;\r\n  uint64_t                Size;\r\n  uint32_t                PrimarySocket;\r\n  uint32_t                PrimaryDie;\r\n  uint32_t                PrimaryRootBridge;\r\n  bool                    AlreadySet;\r\n  DFX_FABRIC_MMIO_MANAGER *FabricMmioManager = &SilData->MmioRcMgr;\r\n  DF_IP2IP_API            *DfIp2IpApi;\r\n  SIL_STATUS              Status;\r\n  APOB_IP2IP_API          *ApobIp2IpApi;\r\n  APOB_SOC_DIE_INFO       SocMaxDieInfo;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  assert(Status == SilPass);\r\n  Status = SilGetIp2IpApi(SilContext, SilId_ApobClass, (void **) &ApobIp2IpApi);\r\n  if ((Status != SilPass) || (ApobIp2IpApi == NULL)) {\r\n    assert(Status == SilPass);\r\n    return;\r\n  }\r\n\r\n  ApobIp2IpApi->ApobGetMaxDieInfo(SilContext, &SocMaxDieInfo);\r\n\r\n  SilGetPrimaryRb(SilContext, &PrimarySocket, &PrimaryDie, &PrimaryRootBridge);\r\n\r\n  AlreadySet = false;\r\n  Base = ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START;\r\n  Size = ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END - ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START + 1;\r\n\r\n  // If reserved region for primary root bridge (AmdBottomMmioReservedForPrimaryRb ~ BottomOfCompat) has not been set\r\n  // or that region does not include\r\n  // ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START ~ ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END\r\n  if ((!ReservedRegionAlreadySet) ||\r\n    ((ReservedRegionAlreadySet) && (BottomOfCompat <= ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END))) {\r\n    if (Size >= RCMGR_MMIO_MIN_SIZE) {\r\n      for (i = 0; i < SocMaxDieInfo.MaxSocSocketsSupportedValue; i++) {\r\n        for (j = 0; j < SilData->RbsPerSocket; j++) {\r\n          // Find out a spare MMIO register pair\r\n          if (FabricMmioManager->AllocateMmioBelow4GOnThisRb[i][j] == false) {\r\n            if ((FabricMmioManager->PrimaryRbHas2ndMmioBelow4G) &&\r\n              (((FabricMmioManager->PrimaryRb2ndMmioPairBelow4G >> 4) & 0xF) == i) &&\r\n              ((FabricMmioManager->PrimaryRb2ndMmioPairBelow4G & 0xF) == j)) {\r\n              continue;\r\n            }\r\n            Status = SilSetMmioReg4(SilContext,\r\n              DfIp2IpApi,\r\n              SilData->SocketNumber,\r\n              ((i * SilData->RbsPerSocket + j) * 2),\r\n              PrimarySocket,\r\n              PrimaryRootBridge,\r\n              Base,\r\n              Size\r\n              );\r\n            AlreadySet = true;\r\n            break;\r\n          }\r\n\r\n          if (FabricMmioManager->AllocateMmioAbove4GOnThisRb[i][j] == false) {\r\n            Status = SilSetMmioReg4(SilContext,\r\n              DfIp2IpApi,\r\n              SilData->SocketNumber,\r\n              ((i * SilData->RbsPerSocket + j) * 2 + 1),\r\n              PrimarySocket,\r\n              PrimaryRootBridge,\r\n              Base,\r\n              Size\r\n              );\r\n            AlreadySet = true;\r\n            break;\r\n          }\r\n        }\r\n        if (AlreadySet) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}",
                              "range": [
                                { "line": 1489, "character": 0 },
                                { "line": 1575, "character": 1 }
                              ],
                              "selectionRange": [
                                { "line": 1490, "character": 0 },
                                { "line": 1490, "character": 25 }
                              ],
                              "dependencies": {
                                "callTree": [
                                  {
                                    "name": "SIL_CONTEXT",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                    "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                    "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                    "range": [
                                      { "line": 131, "character": 0 },
                                      { "line": 135, "character": 14 }
                                    ],
                                    "selectionRange": [
                                      { "line": 135, "character": 2 },
                                      { "line": 135, "character": 13 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "DFX_RCMGR_INPUT_BLK",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                                    "documentation": "",
                                    "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                                    "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                                    "range": [
                                      { "line": 124, "character": 0 },
                                      { "line": 143, "character": 22 }
                                    ],
                                    "selectionRange": [
                                      { "line": 143, "character": 2 },
                                      { "line": 143, "character": 21 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "DFX_FABRIC_MMIO_MANAGER",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                                    "documentation": "",
                                    "definition": "typedef struct {\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  bool    AllocateMmioAbove4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO above 4G?\r\n  bool    AllocateMmioBelow4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO below 4G?\r\n  bool    PrimaryRbHas2ndMmioBelow4G;                                               ///< Indicate if RootBridge 0 has a 2nd MMIO which is below 4G\r\n  bool    ReportToGcd;                                                              ///< TRUE - Need to report GCD if user call FabricAllocateMmio\r\n  uint8_t PrimaryRb2ndMmioPairBelow4G;                                              ///< Since AllocateMmioOnThisRootBridge[i][j] is FALSE, use this one for\r\n                                                                                    ///< RootBridge0's 2nd MMIO, RootBridge02ndMmioPair = (i << 4) | j\r\n  uint64_t  Reserved;                                                               ///< compatibility (ImageHandle)\r\n} DFX_FABRIC_MMIO_MANAGER;",
                                    "implementation": "typedef struct {\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_MMIO_REGION    MmioRegionBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  bool    AllocateMmioAbove4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO above 4G?\r\n  bool    AllocateMmioBelow4GOnThisRb[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< Allocate MMIO below 4G?\r\n  bool    PrimaryRbHas2ndMmioBelow4G;                                               ///< Indicate if RootBridge 0 has a 2nd MMIO which is below 4G\r\n  bool    ReportToGcd;                                                              ///< TRUE - Need to report GCD if user call FabricAllocateMmio\r\n  uint8_t PrimaryRb2ndMmioPairBelow4G;                                              ///< Since AllocateMmioOnThisRootBridge[i][j] is FALSE, use this one for\r\n                                                                                    ///< RootBridge0's 2nd MMIO, RootBridge02ndMmioPair = (i << 4) | j\r\n  uint64_t  Reserved;                                                               ///< compatibility (ImageHandle)\r\n} DFX_FABRIC_MMIO_MANAGER;",
                                    "range": [
                                      { "line": 100, "character": 0 },
                                      { "line": 110, "character": 26 }
                                    ],
                                    "selectionRange": [
                                      { "line": 110, "character": 2 },
                                      { "line": 110, "character": 25 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "DF_IP2IP_API",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                                    "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                                    "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                    "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                    "range": [
                                      { "line": 199, "character": 0 },
                                      { "line": 226, "character": 15 }
                                    ],
                                    "selectionRange": [
                                      { "line": 226, "character": 2 },
                                      { "line": 226, "character": 14 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SIL_STATUS",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                    "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                    "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                    "range": [
                                      { "line": 49, "character": 0 },
                                      { "line": 74, "character": 13 }
                                    ],
                                    "selectionRange": [
                                      { "line": 74, "character": 2 },
                                      { "line": 74, "character": 12 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "APOB_IP2IP_API",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/ApobIp2Ip.h",
                                    "documentation": "",
                                    "definition": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                                    "implementation": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                                    "range": [
                                      { "line": 105, "character": 0 },
                                      { "line": 119, "character": 17 }
                                    ],
                                    "selectionRange": [
                                      { "line": 119, "character": 2 },
                                      { "line": 119, "character": 16 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "APOB_SOC_DIE_INFO",
                                    "kind": 10,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/Common/ApobCmn.h",
                                    "documentation": "/**\n * @brief AMD APOB_SOC_DIE_INFO\n *\n */",
                                    "definition": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                                    "implementation": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                                    "range": [
                                      { "line": 544, "character": 0 },
                                      { "line": 552, "character": 20 }
                                    ],
                                    "selectionRange": [
                                      { "line": 552, "character": 2 },
                                      { "line": 552, "character": 19 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                                    "documentation": "",
                                    "definition": "#define ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START 0xFED00000ul",
                                    "implementation": "#define ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_START 0xFED00000ul",
                                    "range": [
                                      { "line": 39, "character": 0 },
                                      { "line": 39, "character": 68 }
                                    ],
                                    "selectionRange": [
                                      { "line": 39, "character": 8 },
                                      { "line": 39, "character": 55 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                                    "documentation": "",
                                    "definition": "#define ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END   0xFED0FFFFul",
                                    "implementation": "#define ADDITIONAL_POSTED_REGION_UNDER_PRIMARY_RB_END   0xFED0FFFFul",
                                    "range": [
                                      { "line": 40, "character": 0 },
                                      { "line": 40, "character": 68 }
                                    ],
                                    "selectionRange": [
                                      { "line": 40, "character": 8 },
                                      { "line": 40, "character": 53 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "RCMGR_MMIO_MIN_SIZE",
                                    "kind": 13,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                                    "documentation": "",
                                    "definition": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                                    "implementation": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                                    "range": [
                                      { "line": 25, "character": 0 },
                                      { "line": 25, "character": 53 }
                                    ],
                                    "selectionRange": [
                                      { "line": 25, "character": 8 },
                                      { "line": 25, "character": 27 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SilGetIp2IpApi",
                                    "kind": 11,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                                    "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                                    "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                                    "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                                    "range": [
                                      { "line": 190, "character": 0 },
                                      { "line": 219, "character": 1 }
                                    ],
                                    "selectionRange": [
                                      { "line": 191, "character": 0 },
                                      { "line": 191, "character": 14 }
                                    ],
                                    "dependencies": {
                                      "callTree": [
                                        {
                                          "name": "SIL_STATUS",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                          "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                          "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "range": [
                                            { "line": 49, "character": 0 },
                                            { "line": 74, "character": 13 }
                                          ],
                                          "selectionRange": [
                                            { "line": 74, "character": 2 },
                                            { "line": 74, "character": 12 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_CONTEXT",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                          "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                          "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "range": [
                                            { "line": 131, "character": 0 },
                                            { "line": 135, "character": 14 }
                                          ],
                                          "selectionRange": [
                                            { "line": 135, "character": 2 },
                                            { "line": 135, "character": 13 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_DATA_BLOCK_ID",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                          "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                                          "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                          "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                          "range": [
                                            { "line": 48, "character": 0 },
                                            { "line": 73, "character": 20 }
                                          ],
                                          "selectionRange": [
                                            { "line": 73, "character": 2 },
                                            { "line": 73, "character": 19 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_BLOCK_VARIABLES",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                          "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                                          "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                          "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                          "range": [
                                            { "line": 182, "character": 0 },
                                            { "line": 193, "character": 22 }
                                          ],
                                          "selectionRange": [
                                            { "line": 193, "character": 2 },
                                            { "line": 193, "character": 21 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_TRACE_ERROR",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                          "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                                          "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                          "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                          "range": [
                                            { "line": 100, "character": 0 },
                                            { "line": 100, "character": 87 }
                                          ],
                                          "selectionRange": [
                                            { "line": 100, "character": 8 },
                                            { "line": 100, "character": 23 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "__disable_tail_calls",
                                          "kind": 12,
                                          "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                          "documentation": "",
                                          "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "range": [
                                            { "line": 59, "character": 0 },
                                            { "line": 59, "character": 101 }
                                          ],
                                          "selectionRange": [
                                            { "line": 59, "character": 80 },
                                            { "line": 59, "character": 100 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "__disable_tail_calls",
                                    "kind": 12,
                                    "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                    "documentation": "",
                                    "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                    "range": [
                                      { "line": 59, "character": 0 },
                                      { "line": 59, "character": 101 }
                                    ],
                                    "selectionRange": [
                                      { "line": 59, "character": 80 },
                                      { "line": 59, "character": 100 }
                                    ],
                                    "dependencies": { "callTree": [] }
                                  },
                                  {
                                    "name": "SilGetPrimaryRb",
                                    "kind": 11,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricRcInit.c",
                                    "documentation": "/**\n * SilGetPrimaryRb\n *\n * @brief Returns primary RB socket number and RB number\n *\n * @param   SilContext          A context structure through which host firmware defined data\n *                              can be passed to openSIL. The host firmware is responsible\n *                              for initializing the SIL_CONTEXT structure.\n * @param   SocketNum           Primary RB socket number\n * @param   RootBridgeNum       Primary RB number\n *\n */",
                                    "definition": "void\r\nSilGetPrimaryRb (\r\n  SIL_CONTEXT      *SilContext,\r\n  uint32_t         *SocketNum,\r\n  uint32_t         *DieNum,\r\n  uint32_t         *RootBridgeNum\r\n  )",
                                    "implementation": "void\r\nSilGetPrimaryRb (\r\n  SIL_CONTEXT      *SilContext,\r\n  uint32_t         *SocketNum,\r\n  uint32_t         *DieNum,\r\n  uint32_t         *RootBridgeNum\r\n  )\r\n{\r\n  ROOT_BRIDGE_LOCATION Location;\r\n  DF_IP2IP_API *DfIp2IpApi;\r\n  SIL_STATUS           Status;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  if (Status != SilPass) {\r\n    assert(Status == SilPass);\r\n    return;\r\n  }\r\n\r\n  if (DfIp2IpApi->DfGetSystemComponentRootBridgeLocation(SilContext, PrimaryFch, &Location)) {\r\n    *SocketNum = Location.Socket;\r\n    *DieNum = Location.Die;\r\n    *RootBridgeNum = Location.Index;\r\n  } else {\r\n    *SocketNum = 0;\r\n    *DieNum = 0;\r\n    *RootBridgeNum = 0;\r\n  }\r\n}",
                                    "range": [
                                      { "line": 25, "character": 0 },
                                      { "line": 52, "character": 1 }
                                    ],
                                    "selectionRange": [
                                      { "line": 26, "character": 0 },
                                      { "line": 26, "character": 15 }
                                    ],
                                    "dependencies": {
                                      "callTree": [
                                        {
                                          "name": "SIL_CONTEXT",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                          "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                          "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "range": [
                                            { "line": 131, "character": 0 },
                                            { "line": 135, "character": 14 }
                                          ],
                                          "selectionRange": [
                                            { "line": 135, "character": 2 },
                                            { "line": 135, "character": 13 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "ROOT_BRIDGE_LOCATION",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/SilBaseFabricTopologyLib.h",
                                          "documentation": "/// Root Bridge location",
                                          "definition": "typedef struct {\r\n  uint32_t       Socket;\r\n  uint32_t       Die;\r\n  uint32_t       Index;\r\n} ROOT_BRIDGE_LOCATION;",
                                          "implementation": "typedef struct {\r\n  uint32_t       Socket;\r\n  uint32_t       Die;\r\n  uint32_t       Index;\r\n} ROOT_BRIDGE_LOCATION;",
                                          "range": [
                                            { "line": 24, "character": 0 },
                                            { "line": 28, "character": 23 }
                                          ],
                                          "selectionRange": [
                                            { "line": 28, "character": 2 },
                                            { "line": 28, "character": 22 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "DF_IP2IP_API",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                                          "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                                          "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                          "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                          "range": [
                                            { "line": 199, "character": 0 },
                                            { "line": 226, "character": 15 }
                                          ],
                                          "selectionRange": [
                                            { "line": 226, "character": 2 },
                                            { "line": 226, "character": 14 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_STATUS",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                          "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                          "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "range": [
                                            { "line": 49, "character": 0 },
                                            { "line": 74, "character": 13 }
                                          ],
                                          "selectionRange": [
                                            { "line": 74, "character": 2 },
                                            { "line": 74, "character": 12 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SilGetIp2IpApi",
                                          "kind": 11,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                                          "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                                          "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                                          "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                                          "range": [
                                            { "line": 190, "character": 0 },
                                            { "line": 219, "character": 1 }
                                          ],
                                          "selectionRange": [
                                            { "line": 191, "character": 0 },
                                            { "line": 191, "character": 14 }
                                          ],
                                          "dependencies": {
                                            "callTree": [
                                              {
                                                "name": "SIL_STATUS",
                                                "kind": 10,
                                                "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                                "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                                "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                                "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                                "range": [
                                                  {
                                                    "line": 49,
                                                    "character": 0
                                                  },
                                                  {
                                                    "line": 74,
                                                    "character": 13
                                                  }
                                                ],
                                                "selectionRange": [
                                                  {
                                                    "line": 74,
                                                    "character": 2
                                                  },
                                                  {
                                                    "line": 74,
                                                    "character": 12
                                                  }
                                                ],
                                                "dependencies": {
                                                  "callTree": []
                                                }
                                              },
                                              {
                                                "name": "SIL_CONTEXT",
                                                "kind": 10,
                                                "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                                "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                                "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                                "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                                "range": [
                                                  {
                                                    "line": 131,
                                                    "character": 0
                                                  },
                                                  {
                                                    "line": 135,
                                                    "character": 14
                                                  }
                                                ],
                                                "selectionRange": [
                                                  {
                                                    "line": 135,
                                                    "character": 2
                                                  },
                                                  {
                                                    "line": 135,
                                                    "character": 13
                                                  }
                                                ],
                                                "dependencies": {
                                                  "callTree": []
                                                }
                                              },
                                              {
                                                "name": "SIL_DATA_BLOCK_ID",
                                                "kind": 10,
                                                "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                                "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                                                "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                                "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                                "range": [
                                                  {
                                                    "line": 48,
                                                    "character": 0
                                                  },
                                                  {
                                                    "line": 73,
                                                    "character": 20
                                                  }
                                                ],
                                                "selectionRange": [
                                                  {
                                                    "line": 73,
                                                    "character": 2
                                                  },
                                                  {
                                                    "line": 73,
                                                    "character": 19
                                                  }
                                                ],
                                                "dependencies": {
                                                  "callTree": []
                                                }
                                              },
                                              {
                                                "name": "SIL_BLOCK_VARIABLES",
                                                "kind": 10,
                                                "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                                "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                                                "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                                "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                                "range": [
                                                  {
                                                    "line": 182,
                                                    "character": 0
                                                  },
                                                  {
                                                    "line": 193,
                                                    "character": 22
                                                  }
                                                ],
                                                "selectionRange": [
                                                  {
                                                    "line": 193,
                                                    "character": 2
                                                  },
                                                  {
                                                    "line": 193,
                                                    "character": 21
                                                  }
                                                ],
                                                "dependencies": {
                                                  "callTree": []
                                                }
                                              },
                                              {
                                                "name": "SIL_TRACE_ERROR",
                                                "kind": 13,
                                                "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                                "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                                                "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                                "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                                "range": [
                                                  {
                                                    "line": 100,
                                                    "character": 0
                                                  },
                                                  {
                                                    "line": 100,
                                                    "character": 87
                                                  }
                                                ],
                                                "selectionRange": [
                                                  {
                                                    "line": 100,
                                                    "character": 8
                                                  },
                                                  {
                                                    "line": 100,
                                                    "character": 23
                                                  }
                                                ],
                                                "dependencies": {
                                                  "callTree": []
                                                }
                                              },
                                              {
                                                "name": "__disable_tail_calls",
                                                "kind": 12,
                                                "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                                "documentation": "",
                                                "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                                "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                                "range": [
                                                  {
                                                    "line": 59,
                                                    "character": 0
                                                  },
                                                  {
                                                    "line": 59,
                                                    "character": 101
                                                  }
                                                ],
                                                "selectionRange": [
                                                  {
                                                    "line": 59,
                                                    "character": 80
                                                  },
                                                  {
                                                    "line": 59,
                                                    "character": 100
                                                  }
                                                ],
                                                "dependencies": {
                                                  "callTree": []
                                                }
                                              }
                                            ]
                                          }
                                        },
                                        {
                                          "name": "__disable_tail_calls",
                                          "kind": 12,
                                          "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                          "documentation": "",
                                          "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "range": [
                                            { "line": 59, "character": 0 },
                                            { "line": 59, "character": 101 }
                                          ],
                                          "selectionRange": [
                                            { "line": 59, "character": 80 },
                                            { "line": 59, "character": 100 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "SilSetMmioReg4",
                                    "kind": 11,
                                    "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                                    "documentation": "/**\n * SilSetMmioReg4\n *\n * @brief Set MMIO register pairs according to input parameters\n *\n * @param   SilContext      A context structure through which host firmware defined data\n *                          can be passed to openSIL. The host firmware is responsible\n *                          for initializing the SIL_CONTEXT structure.\n * @param   DfIp2IpApi      A pointer to the data fabric I2I api\n * @param   TotalSocket     System socket count\n * @param   MmioPairIndex   Which MMIO register pair should be set\n * @param   SktNum          Socket number\n * @param   RbNum           Root bridge number\n * @param   BaseAddress     Base address of MMIO region\n * @param   Length          Length of MMIO region\n *\n */",
                                    "definition": "SIL_STATUS\r\nSilSetMmioReg4 (\r\n  SIL_CONTEXT                   *SilContext,\r\n  DF_IP2IP_API                  *DfIp2IpApi,\r\n  uint8_t                       TotalSocket,\r\n  uint8_t                       MmioPairIndex,\r\n  uint32_t                      SktNum,\r\n  uint32_t                      RbNum,\r\n  uint64_t                      BaseAddress,\r\n  uint64_t                      Length\r\n  )",
                                    "implementation": "SIL_STATUS\r\nSilSetMmioReg4 (\r\n  SIL_CONTEXT                   *SilContext,\r\n  DF_IP2IP_API                  *DfIp2IpApi,\r\n  uint8_t                       TotalSocket,\r\n  uint8_t                       MmioPairIndex,\r\n  uint32_t                      SktNum,\r\n  uint32_t                      RbNum,\r\n  uint64_t                      BaseAddress,\r\n  uint64_t                      Length\r\n  )\r\n{\r\n  uint32_t            DiePerSkt;\r\n  SIL_STATUS          Status;\r\n  APOB_SOC_DIE_INFO   SocMaxDieInfo;\r\n  APOB_IP2IP_API      *ApobIp2IpApi;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_ApobClass, (void **) &ApobIp2IpApi);\r\n  if ((Status != SilPass) || (ApobIp2IpApi == NULL)) {\r\n    assert(Status == SilPass);\r\n  } else {\r\n    ApobIp2IpApi->ApobGetMaxDieInfo(SilContext, &SocMaxDieInfo);\r\n    assert(Length >= RCMGR_MMIO_MIN_SIZE);\r\n    BaseAddress = (BaseAddress + 0xFFFF) & 0xFFFFFFFFFFFF0000;\r\n\r\n    DiePerSkt = DfIp2IpApi->DfGetNumberOfDiesOnSocket(SilContext, SktNum);\r\n    if (DiePerSkt <= SocMaxDieInfo.MaxSocDiesPerSocketValue) {\r\n      for (uint32_t i = 0; i < TotalSocket; i++) {\r\n        for (uint32_t j = 0; j < DiePerSkt; j++) {\r\n          DfIp2IpApi->DfFabricRegisterAccWrite(SilContext,\r\n            i,\r\n            j,\r\n            MMIOBASEADDRESS_0_FUNC,\r\n            (MMIOBASEADDRESS_0_REG + MmioPairIndex * (MMIOBASEADDRESS_1_REG - MMIOBASEADDRESS_0_REG)),\r\n            FABRIC_REG_ACC_BC,\r\n            (uint32_t) (BaseAddress >> 16)\r\n            );\r\n          DfIp2IpApi->DfFabricRegisterAccWrite(SilContext,\r\n            i,\r\n            j,\r\n            MMIOLIMITADDRESS_0_FUNC,\r\n            (MMIOLIMITADDRESS_0_REG + MmioPairIndex * (MMIOLIMITADDRESS_1_REG - MMIOLIMITADDRESS_0_REG)),\r\n            FABRIC_REG_ACC_BC,\r\n            (uint32_t) ((BaseAddress + Length - 1) >> 16)\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_RE,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            1,\r\n            0\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_WE,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            1,\r\n            0\r\n            );\r\n\r\n          DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n            (uint8_t) MMIO_ADDRESS_CONTROL0_DstFabricID,\r\n            (uint32_t)i,\r\n            MmioPairIndex,\r\n            FABRIC_REG_ACC_BC,\r\n            0,\r\n            DF_ABSTRACT_REG_WRITE,\r\n            (uint32_t) DfIp2IpApi->DfGetHostBridgeSystemFabricID(SilContext, SktNum, 0, RbNum),\r\n            0\r\n            );\r\n        }\r\n      }\r\n    }\r\n\r\n    Status = SilPass;\r\n  }\r\n\r\n  return Status;\r\n}",
                                    "range": [
                                      { "line": 1594, "character": 0 },
                                      { "line": 1680, "character": 1 }
                                    ],
                                    "selectionRange": [
                                      { "line": 1595, "character": 0 },
                                      { "line": 1595, "character": 14 }
                                    ],
                                    "dependencies": {
                                      "callTree": [
                                        {
                                          "name": "SIL_STATUS",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                          "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                          "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                          "range": [
                                            { "line": 49, "character": 0 },
                                            { "line": 74, "character": 13 }
                                          ],
                                          "selectionRange": [
                                            { "line": 74, "character": 2 },
                                            { "line": 74, "character": 12 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SIL_CONTEXT",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                          "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                          "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                          "range": [
                                            { "line": 131, "character": 0 },
                                            { "line": 135, "character": 14 }
                                          ],
                                          "selectionRange": [
                                            { "line": 135, "character": 2 },
                                            { "line": 135, "character": 13 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "DF_IP2IP_API",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                                          "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                                          "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                          "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                                          "range": [
                                            { "line": 199, "character": 0 },
                                            { "line": 226, "character": 15 }
                                          ],
                                          "selectionRange": [
                                            { "line": 226, "character": 2 },
                                            { "line": 226, "character": 14 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "APOB_SOC_DIE_INFO",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/Common/ApobCmn.h",
                                          "documentation": "/**\n * @brief AMD APOB_SOC_DIE_INFO\n *\n */",
                                          "definition": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                                          "implementation": "typedef struct {\r\n  uint8_t     MaxSocCcdsPerDieValue;\r\n  uint8_t     MaxSocCcxPerCcdValue;\r\n  uint8_t     MaxSocCoresPerComplexValue;\r\n  uint8_t     MaxSocDiesPerSocketValue;\r\n  uint8_t     MaxSocSocketsSupportedValue;\r\n  uint8_t     MaxSocThreadPerCore;\r\n  uint8_t     MaxSocCcdPerSocket;\r\n} APOB_SOC_DIE_INFO;",
                                          "range": [
                                            { "line": 544, "character": 0 },
                                            { "line": 552, "character": 20 }
                                          ],
                                          "selectionRange": [
                                            { "line": 552, "character": 2 },
                                            { "line": 552, "character": 19 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "APOB_IP2IP_API",
                                          "kind": 10,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/APOB/ApobIp2Ip.h",
                                          "documentation": "",
                                          "definition": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                                          "implementation": "typedef struct {\r\n  APOB_IP2IP_API_HEADER          Header;\r\n  APOB_GET_PHYS_CCD_NUMBER       ApobGetPhysCcdNumber;\r\n  APOB_GET_PHYS_COMPLEX_NUMBER   ApobGetPhysComplexNumber;\r\n  APOB_GET_PHYS_CORE_NUMBER      ApobGetPhysCoreNumber;\r\n  APOB_GET_THREAD_ENABLE         ApobGetIsThreadEnabled;\r\n  APOB_GET_SUBPROGRAM            ApobGetSubProgram;\r\n  APOB_GET_DIMM_SPD_DATA         ApobGetDimmSpdData;\r\n  APOB_GET_CCDLOG_PHYMAP         ApobGetCcdLogToPhysMap;\r\n  APOB_GET_ACTIONON_BISTFAILURE  ApobGetActionOnBistFailure;\r\n  APOB_GET_MAXCPUS               ApobGetMaxCpus;\r\n  APOB_GET_SOC_MAX_DIE_INFO      ApobGetMaxDieInfo;\r\n  APOB_GET_ENTRY_INSTANCE        ApobAmdGetApobEntryInstance;\r\n  APOB_GET_APCB_UPDATE           ApobGetApcbUpdate;\r\n} APOB_IP2IP_API;",
                                          "range": [
                                            { "line": 105, "character": 0 },
                                            { "line": 119, "character": 17 }
                                          ],
                                          "selectionRange": [
                                            { "line": 119, "character": 2 },
                                            { "line": 119, "character": 16 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "RCMGR_MMIO_MIN_SIZE",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                                          "documentation": "",
                                          "definition": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                                          "implementation": "#define RCMGR_MMIO_MIN_SIZE                 0x10000ul",
                                          "range": [
                                            { "line": 25, "character": 0 },
                                            { "line": 25, "character": 53 }
                                          ],
                                          "selectionRange": [
                                            { "line": 25, "character": 8 },
                                            { "line": 25, "character": 27 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "MMIOBASEADDRESS_0_FUNC",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                          "documentation": "",
                                          "definition": "#define MMIOBASEADDRESS_0_FUNC 0x0",
                                          "implementation": "#define MMIOBASEADDRESS_0_FUNC 0x0",
                                          "range": [
                                            { "line": 149, "character": 0 },
                                            { "line": 149, "character": 34 }
                                          ],
                                          "selectionRange": [
                                            { "line": 149, "character": 8 },
                                            { "line": 149, "character": 30 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "MMIOBASEADDRESS_0_REG",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                          "documentation": "",
                                          "definition": "#define MMIOBASEADDRESS_0_REG  0xD80",
                                          "implementation": "#define MMIOBASEADDRESS_0_REG  0xD80",
                                          "range": [
                                            { "line": 150, "character": 0 },
                                            { "line": 150, "character": 36 }
                                          ],
                                          "selectionRange": [
                                            { "line": 150, "character": 8 },
                                            { "line": 150, "character": 29 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "MMIOBASEADDRESS_1_REG",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                          "documentation": "",
                                          "definition": "#define MMIOBASEADDRESS_1_REG  0xD90",
                                          "implementation": "#define MMIOBASEADDRESS_1_REG  0xD90",
                                          "range": [
                                            { "line": 152, "character": 0 },
                                            { "line": 152, "character": 36 }
                                          ],
                                          "selectionRange": [
                                            { "line": 152, "character": 8 },
                                            { "line": 152, "character": 29 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "FABRIC_REG_ACC_BC",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/FabricRegisterAccCmn.h",
                                          "documentation": "/**\n * @file  FabricRegisterAccCmn.h\n * @brief Common definitions for Df fabric register access\n *\n */",
                                          "definition": "#define FABRIC_REG_ACC_BC    (0xFFFFFFFF)",
                                          "implementation": "#define FABRIC_REG_ACC_BC    (0xFFFFFFFF)",
                                          "range": [
                                            { "line": 12, "character": 0 },
                                            { "line": 12, "character": 41 }
                                          ],
                                          "selectionRange": [
                                            { "line": 12, "character": 8 },
                                            { "line": 12, "character": 25 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "MMIOLIMITADDRESS_0_FUNC",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                          "documentation": "",
                                          "definition": "#define MMIOLIMITADDRESS_0_FUNC 0x0",
                                          "implementation": "#define MMIOLIMITADDRESS_0_FUNC 0x0",
                                          "range": [
                                            { "line": 154, "character": 0 },
                                            { "line": 154, "character": 35 }
                                          ],
                                          "selectionRange": [
                                            { "line": 154, "character": 8 },
                                            { "line": 154, "character": 31 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "MMIOLIMITADDRESS_0_REG",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                          "documentation": "",
                                          "definition": "#define MMIOLIMITADDRESS_0_REG  0xD84",
                                          "implementation": "#define MMIOLIMITADDRESS_0_REG  0xD84",
                                          "range": [
                                            { "line": 155, "character": 0 },
                                            { "line": 155, "character": 37 }
                                          ],
                                          "selectionRange": [
                                            { "line": 155, "character": 8 },
                                            { "line": 155, "character": 30 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "MMIOLIMITADDRESS_1_REG",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                          "documentation": "",
                                          "definition": "#define MMIOLIMITADDRESS_1_REG  0xD94",
                                          "implementation": "#define MMIOLIMITADDRESS_1_REG  0xD94",
                                          "range": [
                                            { "line": 157, "character": 0 },
                                            { "line": 157, "character": 37 }
                                          ],
                                          "selectionRange": [
                                            { "line": 157, "character": 8 },
                                            { "line": 157, "character": 30 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "DF_ABSTRACT_REG_WRITE",
                                          "kind": 13,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                                          "documentation": "// Registers that are not supported in a specific program in register abstraction",
                                          "definition": "#define DF_ABSTRACT_REG_WRITE  1",
                                          "implementation": "#define DF_ABSTRACT_REG_WRITE  1",
                                          "range": [
                                            { "line": 90, "character": 0 },
                                            { "line": 90, "character": 32 }
                                          ],
                                          "selectionRange": [
                                            { "line": 90, "character": 8 },
                                            { "line": 90, "character": 29 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        },
                                        {
                                          "name": "SilGetIp2IpApi",
                                          "kind": 11,
                                          "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                                          "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                                          "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                                          "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                                          "range": [
                                            { "line": 190, "character": 0 },
                                            { "line": 219, "character": 1 }
                                          ],
                                          "selectionRange": [
                                            { "line": 191, "character": 0 },
                                            { "line": 191, "character": 14 }
                                          ],
                                          "dependencies": {
                                            "callTree": [
                                              {
                                                "name": "SIL_STATUS",
                                                "kind": 10,
                                                "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                                                "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                                                "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                                "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                                                "range": [
                                                  {
                                                    "line": 49,
                                                    "character": 0
                                                  },
                                                  {
                                                    "line": 74,
                                                    "character": 13
                                                  }
                                                ],
                                                "selectionRange": [
                                                  {
                                                    "line": 74,
                                                    "character": 2
                                                  },
                                                  {
                                                    "line": 74,
                                                    "character": 12
                                                  }
                                                ],
                                                "dependencies": {
                                                  "callTree": []
                                                }
                                              },
                                              {
                                                "name": "SIL_CONTEXT",
                                                "kind": 10,
                                                "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                                "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                                                "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                                "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                                                "range": [
                                                  {
                                                    "line": 131,
                                                    "character": 0
                                                  },
                                                  {
                                                    "line": 135,
                                                    "character": 14
                                                  }
                                                ],
                                                "selectionRange": [
                                                  {
                                                    "line": 135,
                                                    "character": 2
                                                  },
                                                  {
                                                    "line": 135,
                                                    "character": 13
                                                  }
                                                ],
                                                "dependencies": {
                                                  "callTree": []
                                                }
                                              },
                                              {
                                                "name": "SIL_DATA_BLOCK_ID",
                                                "kind": 10,
                                                "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                                                "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                                                "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                                "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                                                "range": [
                                                  {
                                                    "line": 48,
                                                    "character": 0
                                                  },
                                                  {
                                                    "line": 73,
                                                    "character": 20
                                                  }
                                                ],
                                                "selectionRange": [
                                                  {
                                                    "line": 73,
                                                    "character": 2
                                                  },
                                                  {
                                                    "line": 73,
                                                    "character": 19
                                                  }
                                                ],
                                                "dependencies": {
                                                  "callTree": []
                                                }
                                              },
                                              {
                                                "name": "SIL_BLOCK_VARIABLES",
                                                "kind": 10,
                                                "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                                "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                                                "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                                "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                                                "range": [
                                                  {
                                                    "line": 182,
                                                    "character": 0
                                                  },
                                                  {
                                                    "line": 193,
                                                    "character": 22
                                                  }
                                                ],
                                                "selectionRange": [
                                                  {
                                                    "line": 193,
                                                    "character": 2
                                                  },
                                                  {
                                                    "line": 193,
                                                    "character": 21
                                                  }
                                                ],
                                                "dependencies": {
                                                  "callTree": []
                                                }
                                              },
                                              {
                                                "name": "SIL_TRACE_ERROR",
                                                "kind": 13,
                                                "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                                                "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                                                "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                                "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                                                "range": [
                                                  {
                                                    "line": 100,
                                                    "character": 0
                                                  },
                                                  {
                                                    "line": 100,
                                                    "character": 87
                                                  }
                                                ],
                                                "selectionRange": [
                                                  {
                                                    "line": 100,
                                                    "character": 8
                                                  },
                                                  {
                                                    "line": 100,
                                                    "character": 23
                                                  }
                                                ],
                                                "dependencies": {
                                                  "callTree": []
                                                }
                                              },
                                              {
                                                "name": "__disable_tail_calls",
                                                "kind": 12,
                                                "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                                "documentation": "",
                                                "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                                "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                                "range": [
                                                  {
                                                    "line": 59,
                                                    "character": 0
                                                  },
                                                  {
                                                    "line": 59,
                                                    "character": 101
                                                  }
                                                ],
                                                "selectionRange": [
                                                  {
                                                    "line": 59,
                                                    "character": 80
                                                  },
                                                  {
                                                    "line": 59,
                                                    "character": 100
                                                  }
                                                ],
                                                "dependencies": {
                                                  "callTree": []
                                                }
                                              }
                                            ]
                                          }
                                        },
                                        {
                                          "name": "__disable_tail_calls",
                                          "kind": 12,
                                          "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                                          "documentation": "",
                                          "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                                          "range": [
                                            { "line": 59, "character": 0 },
                                            { "line": 59, "character": 101 }
                                          ],
                                          "selectionRange": [
                                            { "line": 59, "character": 80 },
                                            { "line": 59, "character": 100 }
                                          ],
                                          "dependencies": { "callTree": [] }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "SilGetNextCombination",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                        "documentation": "/**\n * SilGetNextCombination\n *\n * @brief Get a different resource combination\n *\n *\n * @param[in]         NumberOfRbBelowPcieCfg      How many RootBridges MMIO should be put below Pcie Cfg\n * @param[in, out]    MmioIsAbovePcieCfg          An bool array, indicate which RootBridge's MMIO is above Pcie Cfg\n * @param[in]         SocketNumber                System socket count\n * @param[in]         RbsPerSocket                RootBridge number per socket\n *\n * @retval            true                        Get a combination\n *                    false                       All combinations have been tried\n *\n */",
                        "definition": "static\r\nbool\r\nSilGetNextCombination (\r\n  uint8_t   NumberOfRbBelowPcieCfg,\r\n  bool      *MmioIsAbovePcieCfg,\r\n  uint8_t   SocketNumber,\r\n  uint8_t   RbsPerSocket\r\n  )",
                        "implementation": "static\r\nbool\r\nSilGetNextCombination (\r\n  uint8_t   NumberOfRbBelowPcieCfg,\r\n  bool      *MmioIsAbovePcieCfg,\r\n  uint8_t   SocketNumber,\r\n  uint8_t   RbsPerSocket\r\n  )\r\n{\r\n  uint8_t   MoveThisOne;\r\n  uint8_t   ResetTheseRbs;\r\n\r\n  // From RootBridge 0, there're total number of 'ResetTheseRbs' sequential RootBridge, whose MMIO is below Pcie Cfg\r\n  for (ResetTheseRbs = 0; ResetTheseRbs < NumberOfRbBelowPcieCfg; ResetTheseRbs++) {\r\n    if (*(MmioIsAbovePcieCfg + ResetTheseRbs) == true) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (ResetTheseRbs == NumberOfRbBelowPcieCfg) {\r\n    return false; // All combinations have been tried.\r\n  }\r\n\r\n  // After number of ResetTheseRbs RootBridges, find out the first RootBridge whose MMIO is below Pcie Cfg.\r\n  for (MoveThisOne = ResetTheseRbs + 1; MoveThisOne < (SocketNumber * RbsPerSocket); MoveThisOne++) {\r\n    if (*(MmioIsAbovePcieCfg + MoveThisOne) == false) {\r\n      break;\r\n    }\r\n  }\r\n  assert(MoveThisOne < (SocketNumber * RbsPerSocket));\r\n  *(MmioIsAbovePcieCfg + MoveThisOne) = true;\r\n  *(MmioIsAbovePcieCfg + MoveThisOne - 1) = false;\r\n  memset(MmioIsAbovePcieCfg, true, (sizeof (bool) * ResetTheseRbs));\r\n  memset((MmioIsAbovePcieCfg + MoveThisOne - 1 - ResetTheseRbs), false, (sizeof (bool) * ResetTheseRbs));\r\n\r\n  return true;\r\n}",
                        "range": [
                          { "line": 254, "character": 0 },
                          { "line": 290, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 256, "character": 0 },
                          { "line": 256, "character": 21 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "__disable_tail_calls",
                              "kind": 12,
                              "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                              "documentation": "",
                              "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "range": [
                                { "line": 59, "character": 0 },
                                { "line": 59, "character": 101 }
                              ],
                              "selectionRange": [
                                { "line": 59, "character": 80 },
                                { "line": 59, "character": 100 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "SilFabricSetResourceDistribution",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                  "documentation": "/**\n * SilFabricSetResourceDistribution\n *\n * @brief Sets the resource distribution memory block with the provided data\n *\n * @param[in]    SilData               DFX_RCMGR_INPUT_BLK\n * @param[in]    ResourceDistribution  Array of booleans to be use for setting the data\n *\n */",
                  "definition": "static\r\nSIL_STATUS\r\nSilFabricSetResourceDistribution (\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  bool                    *ResourceDistribution\r\n  )",
                  "implementation": "static\r\nSIL_STATUS\r\nSilFabricSetResourceDistribution (\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  bool                    *ResourceDistribution\r\n  )\r\n{\r\n  UNUSED(SilData);\r\n  UNUSED(ResourceDistribution);\r\n  // This function is not supported in PI code for TP1\r\n  return SilUnsupported;\r\n}",
                  "range": [
                    { "line": 226, "character": 0 },
                    { "line": 237, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 228, "character": 0 },
                    { "line": 228, "character": 32 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "SIL_STATUS",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                        "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                        "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "range": [
                          { "line": 49, "character": 0 },
                          { "line": 74, "character": 13 }
                        ],
                        "selectionRange": [
                          { "line": 74, "character": 2 },
                          { "line": 74, "character": 12 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DFX_RCMGR_INPUT_BLK",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                        "documentation": "",
                        "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                        "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                        "range": [
                          { "line": 124, "character": 0 },
                          { "line": 143, "character": 22 }
                        ],
                        "selectionRange": [
                          { "line": 143, "character": 2 },
                          { "line": 143, "character": 21 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "UNUSED(X)",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                        "documentation": "/**\n * UNUSED macro\n *\n * @brief This macro is used to explicitly avoid compilation errors due to\n *        unused input parameters.  This macro should be used in APIs that have\n *        a fixed signature but differ in implementations.\n *\n */",
                        "definition": "#define UNUSED(X) ((void)(X))",
                        "implementation": "#define UNUSED(X) ((void)(X))",
                        "range": [
                          { "line": 29, "character": 0 },
                          { "line": 29, "character": 29 }
                        ],
                        "selectionRange": [
                          { "line": 29, "character": 8 },
                          { "line": 29, "character": 14 }
                        ],
                        "dependencies": { "callTree": [] }
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "name": "SilInitMmioEqually4",
            "kind": 11,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Source/xUSL/RcMgr/DfX/PHX/RcMgrSetInputBlkPhxUt/RcMgrSetInputBlkPhxUt.c",
            "documentation": "/**\n * SilInitMmioEqually4\n *\n * @brief Initialize MMIO registers for each RootBridge evenly.\n *\n * @param   SilContext            A context structure through which host firmware defined data\n *                                can be passed to openSIL. The host firmware is responsible\n *                                for initializing the SIL_CONTEXT structure.\n * @param   SilData               Point to DFX_RCMGR_INPUT_BLK data structure\n * @param   SilData->MmioRcMgr    Point to DFX_FABRIC_MMIO_MANAGER\n * @param   SilData->SocketNumber System socket count\n * @param   SilData->RbsPerSocket RootBridge number per socket\n * @param   SilData->PciExpressBaseAddress\n *\n */",
            "definition": "SIL_STATUS\r\nSilInitMmioEqually4 (\r\n  SIL_CONTEXT         *SilContext,\r\n  DFX_RCMGR_INPUT_BLK *SilData\r\n  )",
            "implementation": "SIL_STATUS\r\nSilInitMmioEqually4 (\r\n  SIL_CONTEXT         *SilContext,\r\n  DFX_RCMGR_INPUT_BLK *SilData\r\n  )\r\n{\r\n  return SilPass;\r\n}",
            "range": [
              { "line": 35, "character": 0 },
              { "line": 42, "character": 1 }
            ],
            "selectionRange": [
              { "line": 36, "character": 0 },
              { "line": 36, "character": 19 }
            ],
            "dependencies": {
              "callTree": [
                {
                  "name": "SIL_STATUS",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                  "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                  "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "range": [
                    { "line": 49, "character": 0 },
                    { "line": 74, "character": 13 }
                  ],
                  "selectionRange": [
                    { "line": 74, "character": 2 },
                    { "line": 74, "character": 12 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_CONTEXT",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                  "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "range": [
                    { "line": 131, "character": 0 },
                    { "line": 135, "character": 14 }
                  ],
                  "selectionRange": [
                    { "line": 135, "character": 2 },
                    { "line": 135, "character": 13 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "DFX_RCMGR_INPUT_BLK",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                  "documentation": "",
                  "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                  "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                  "range": [
                    { "line": 124, "character": 0 },
                    { "line": 143, "character": 22 }
                  ],
                  "selectionRange": [
                    { "line": 143, "character": 2 },
                    { "line": 143, "character": 21 }
                  ],
                  "dependencies": { "callTree": [] }
                }
              ]
            }
          },
          {
            "name": "SilInitIoBasedOnNvVariable4",
            "kind": 11,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
            "documentation": "/**\n * SilInitIoBasedOnNvVariable4\n *\n * @brief Initialize IO registers for each Root Bridge based on NV variable.\n *\n * @param   SilContext                   A context structure through which host firmware defined data\n *                                       can be passed to openSIL. The host firmware is responsible\n *                                       for initializing the SIL_CONTEXT structure.\n * @param    SilData                     Point to DFX_RCMGR_INPUT_BLK\n *             SilData->FabricIoManager  Point to DFX_FABRIC_IO_MANAGER\n *             SilData->IoSizeForEachRb  How much IO size is required for each Root Bridge\n *             SilData->SocketNumber     System socket count\n *             SilData->RbsPerSocket     Root Bridge number per socket\n * @param    SpaceStatus                  Current status\n * @param    SetDfRegisters              true  - Set DF MMIO registers\n *                                        false - Do Not set DF MMIO registers, just calculate\n *                                                if user's requirement could be satisfied.\n *\n */",
            "definition": "SIL_STATUS\r\nSilInitIoBasedOnNvVariable4 (\r\n  SIL_CONTEXT             *SilContext,\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  FABRIC_ADDR_SPACE_SIZE  *SpaceStatus,\r\n  bool                    SetDfRegisters\r\n  )",
            "implementation": "SIL_STATUS\r\nSilInitIoBasedOnNvVariable4 (\r\n  SIL_CONTEXT             *SilContext,\r\n  DFX_RCMGR_INPUT_BLK     *SilData,\r\n  FABRIC_ADDR_SPACE_SIZE  *SpaceStatus,\r\n  bool                    SetDfRegisters\r\n  )\r\n{\r\n  uint32_t  PhySktLoop;\r\n  uint32_t  PhyRbLoop;\r\n  uint32_t  LogSktLoop;\r\n  uint32_t  LogRbLoop;\r\n  uint8_t   RegIndex;\r\n  uint32_t  IoBase;\r\n  uint32_t  IoSize;\r\n  uint32_t  IoBaseForPrimaryRb;\r\n  uint32_t  IoSizeForPrimaryRb;\r\n  uint32_t  IoBaseForOthers;\r\n  uint32_t  LegacyIoSize;\r\n  uint32_t  PrimarySocket;\r\n  uint32_t  PrimaryDie;\r\n  uint32_t  PrimaryRootBridge;\r\n  bool      LogToPhyMapInit;\r\n  FABRIC_RB_LOG_TO_PHY_MAP LogToPhyMap[PROJ_MAX_SOCKETS_SUPPORTED * PROJ_MAX_HOST_BRIDGES_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB  *IoSizeForEachRb;\r\n  DFX_FABRIC_IO_MANAGER *FabricIoManager;\r\n  SIL_STATUS            Status;\r\n  DF_IP2IP_API          *DfIp2IpApi;\r\n\r\n  IoSizeForEachRb = &SilData->ResourceSizeForEachRb;\r\n  FabricIoManager = &SilData->IoRcMgr;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  if (Status != SilPass) {\r\n    assert(Status == SilPass);\r\n    return Status;\r\n  }\r\n\r\n  RegIndex = 0;\r\n  LegacyIoSize = X86_LEGACY_IO_SIZE;\r\n  LogToPhyMapInit = false;\r\n\r\n  IoBaseForPrimaryRb = 0;\r\n  IoSizeForPrimaryRb = DF_IO_LIMIT - IoBaseForPrimaryRb;\r\n  IoBase = 0;\r\n  IoBaseForOthers = 0;\r\n\r\n  SilGetPrimaryRb(SilContext, &PrimarySocket, &PrimaryDie, &PrimaryRootBridge);\r\n  if ((SilData->SocketNumber != 1) || (SilData->RbsPerSocket != 1)) {\r\n    // If we have more than one RootBridge\r\n    // find out primary RootBridge and reserve an IO region start from 0 for it\r\n    for (PhySktLoop = 0; PhySktLoop < SilData->SocketNumber; PhySktLoop++) {\r\n      for (PhyRbLoop = 0; PhyRbLoop < SilData->RbsPerSocket; PhyRbLoop++) {\r\n        if ((PhySktLoop == PrimarySocket) && (PhyRbLoop == PrimaryRootBridge)) {\r\n          IoSizeForPrimaryRb =\r\n            (uint32_t) (IoSizeForEachRb->IO[PhySktLoop][PhyRbLoop].Size & RCMGR_IO_SIZE_MASK) + LegacyIoSize;\r\n          IoBaseForOthers = IoBaseForPrimaryRb + IoSizeForPrimaryRb;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  RCMGR_TRACEPOINT(SIL_TRACE_INFO, \"   reserve 0x%X IO size for legacy devices\\n\", LegacyIoSize);\r\n\r\n  for (LogSktLoop = 0; LogSktLoop < SilData->SocketNumber; LogSktLoop++) {\r\n    for (LogRbLoop = 0; LogRbLoop < SilData->RbsPerSocket; LogRbLoop++) {\r\n      DfXSilGetPhySktRbNum(SilContext,\r\n        DfIp2IpApi,\r\n        LogSktLoop,\r\n        LogRbLoop,\r\n        &PhySktLoop,\r\n        &PhyRbLoop,\r\n        &LogToPhyMapInit,\r\n        &LogToPhyMap[0]\r\n        );\r\n      if (SpaceStatus != NULL) {\r\n        SpaceStatus->IoSize += (uint32_t) IoSizeForEachRb->IO[PhySktLoop][PhyRbLoop].Size & RCMGR_IO_SIZE_MASK;\r\n      }\r\n\r\n      if ((PhySktLoop == PrimarySocket) && (PhyRbLoop == PrimaryRootBridge)) {\r\n        IoBase = IoBaseForPrimaryRb;\r\n        IoSize = IoSizeForPrimaryRb;\r\n      } else {\r\n        IoBase = IoBaseForOthers;\r\n        IoSize = (uint32_t) IoSizeForEachRb->IO[PhySktLoop][PhyRbLoop].Size & RCMGR_IO_SIZE_MASK;\r\n        IoBaseForOthers += IoSize;\r\n      }\r\n\r\n      if (((LogSktLoop + 1) == SilData->SocketNumber) && ((LogRbLoop + 1) == SilData->RbsPerSocket)) {\r\n        // check if it's the last RB. DF's IO space is up to 25 bits, so set limit to 0x1FFFFFF for last RB\r\n        IoSize = DF_IO_LIMIT - IoBase;\r\n      }\r\n\r\n      assert(IoBase < X86IO_LIMIT);\r\n\r\n      if (IoSize == 0) {\r\n        continue;\r\n      }\r\n\r\n      if ((FabricIoManager != NULL) && SetDfRegisters) {\r\n        SilSetIoReg4(SilContext, SilData->SocketNumber, RegIndex, PhySktLoop, PhyRbLoop, IoBase, IoSize);\r\n\r\n        if ((PhySktLoop == PrimarySocket) && (PhyRbLoop == PrimaryRootBridge)) {\r\n          // This root bridge has an additional IO region for legacy devices, size is LegacyIoSize\r\n          FabricIoManager->IoRegion[PhySktLoop][PhyRbLoop].IoBase = IoBase + LegacyIoSize;\r\n          FabricIoManager->IoRegion[PhySktLoop][PhyRbLoop].IoSize = IoSize - LegacyIoSize;\r\n        } else {\r\n          FabricIoManager->IoRegion[PhySktLoop][PhyRbLoop].IoBase = IoBase;\r\n          FabricIoManager->IoRegion[PhySktLoop][PhyRbLoop].IoSize = IoSize;\r\n        }\r\n        FabricIoManager->IoRegion[PhySktLoop][PhyRbLoop].IoUsed = 0;\r\n\r\n        if (((LogSktLoop + 1) == SilData->SocketNumber) && ((LogRbLoop + 1) == SilData->RbsPerSocket)) {\r\n          // When report to X86, IO region should be IoBase ~ X86IO_LIMIT since X86 only support 16 bits IO space\r\n          FabricIoManager->IoRegion[PhySktLoop][PhyRbLoop].IoSize =\r\n            X86IO_LIMIT - FabricIoManager->IoRegion[PhySktLoop][PhyRbLoop].IoBase;\r\n        }\r\n\r\n        RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n          \"  Socket%x RootBridge%x has IO base 0x%X size 0x%X\\n\\n\",\r\n          PhySktLoop,\r\n          PhyRbLoop,\r\n          FabricIoManager->IoRegion[PhySktLoop][PhyRbLoop].IoBase,\r\n          FabricIoManager->IoRegion[PhySktLoop][PhyRbLoop].IoSize\r\n          );\r\n      }\r\n\r\n      RegIndex++;\r\n    }\r\n  }\r\n\r\n  if (SpaceStatus != NULL) {\r\n    if (SpaceStatus->IoSize > X86IO_LIMIT) {\r\n      SpaceStatus->IoSizeReqInc = SpaceStatus->IoSize - X86IO_LIMIT;\r\n    } else {\r\n      SpaceStatus->IoSizeReqInc = 0;\r\n    }\r\n    RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n      \"  Space Status: IoSize %X, IoSizeReqInc %X\\n\",\r\n      SpaceStatus->IoSize,\r\n      SpaceStatus->IoSizeReqInc\r\n      );\r\n  }\r\n\r\n  if (FabricIoManager != NULL) {\r\n    FabricIoManager->GlobalCtrl = true;\r\n  }\r\n\r\n  return SilPass;\r\n}",
            "range": [
              { "line": 43, "character": 0 },
              { "line": 192, "character": 1 }
            ],
            "selectionRange": [
              { "line": 44, "character": 0 },
              { "line": 44, "character": 27 }
            ],
            "dependencies": {
              "callTree": [
                {
                  "name": "SIL_STATUS",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                  "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                  "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "range": [
                    { "line": 49, "character": 0 },
                    { "line": 74, "character": 13 }
                  ],
                  "selectionRange": [
                    { "line": 74, "character": 2 },
                    { "line": 74, "character": 12 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_CONTEXT",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                  "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "range": [
                    { "line": 131, "character": 0 },
                    { "line": 135, "character": 14 }
                  ],
                  "selectionRange": [
                    { "line": 135, "character": 2 },
                    { "line": 135, "character": 13 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "DFX_RCMGR_INPUT_BLK",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                  "documentation": "",
                  "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                  "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                  "range": [
                    { "line": 124, "character": 0 },
                    { "line": 143, "character": 22 }
                  ],
                  "selectionRange": [
                    { "line": 143, "character": 2 },
                    { "line": 143, "character": 21 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "FABRIC_ADDR_SPACE_SIZE",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                  "documentation": "/// Current status",
                  "definition": "typedef struct _FABRIC_ADDR_SPACE_SIZE {\r\n  uint32_t  IoSize;                ///< IO size required by system resources\r\n  uint32_t  IoSizeReqInc;          ///< The amount needed over the current size\r\n  uint32_t  MmioSizeBelow4G;       ///< Below 4G Mmio size required by system resources\r\n  uint32_t  MmioSizeBelow4GReqInc; ///< The amount needed over the current size\r\n  uint64_t  MmioSizeAbove4G;       ///< Above 4G Mmio size required by system resources\r\n  uint64_t  MmioSizeAbove4GReqInc; ///< The amount needed over the current size\r\n} FABRIC_ADDR_SPACE_SIZE;",
                  "implementation": "typedef struct _FABRIC_ADDR_SPACE_SIZE {\r\n  uint32_t  IoSize;                ///< IO size required by system resources\r\n  uint32_t  IoSizeReqInc;          ///< The amount needed over the current size\r\n  uint32_t  MmioSizeBelow4G;       ///< Below 4G Mmio size required by system resources\r\n  uint32_t  MmioSizeBelow4GReqInc; ///< The amount needed over the current size\r\n  uint64_t  MmioSizeAbove4G;       ///< Above 4G Mmio size required by system resources\r\n  uint64_t  MmioSizeAbove4GReqInc; ///< The amount needed over the current size\r\n} FABRIC_ADDR_SPACE_SIZE;",
                  "range": [
                    { "line": 45, "character": 0 },
                    { "line": 52, "character": 25 }
                  ],
                  "selectionRange": [
                    { "line": 52, "character": 2 },
                    { "line": 52, "character": 24 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "FABRIC_RB_LOG_TO_PHY_MAP",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/SilBaseFabricTopologyLib.h",
                  "documentation": "/// Logical to physical map",
                  "definition": "typedef struct _FABRIC_RB_LOG_TO_PHY_MAP {\r\n  uint32_t PhySktNum;\r\n  uint32_t PhyRbNum;\r\n  uint32_t PciBusBase;\r\n  uint32_t PciBusLimit;\r\n} FABRIC_RB_LOG_TO_PHY_MAP;",
                  "implementation": "typedef struct _FABRIC_RB_LOG_TO_PHY_MAP {\r\n  uint32_t PhySktNum;\r\n  uint32_t PhyRbNum;\r\n  uint32_t PciBusBase;\r\n  uint32_t PciBusLimit;\r\n} FABRIC_RB_LOG_TO_PHY_MAP;",
                  "range": [
                    { "line": 100, "character": 0 },
                    { "line": 105, "character": 27 }
                  ],
                  "selectionRange": [
                    { "line": 105, "character": 2 },
                    { "line": 105, "character": 26 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "PROJ_MAX_SOCKETS_SUPPORTED",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xSIM/SoC/F19M70/F19M70Charz.h",
                  "documentation": "/**\n * @file F19M70Charz.h\n * @brief SoC characteristics constants\n */\n\n#pragma once\n\n/* SoC construction constants */",
                  "definition": "#define PROJ_MAX_SOCKETS_SUPPORTED      1",
                  "implementation": "#define PROJ_MAX_SOCKETS_SUPPORTED      1",
                  "range": [
                    { "line": 12, "character": 2 },
                    { "line": 12, "character": 43 }
                  ],
                  "selectionRange": [
                    { "line": 12, "character": 10 },
                    { "line": 12, "character": 36 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "PROJ_MAX_HOST_BRIDGES_PER_SOCKET",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xSIM/SoC/F19M70/F19M70Charz.h",
                  "documentation": "/**\n * @file F19M70Charz.h\n * @brief SoC characteristics constants\n */\n\n#pragma once\n\n/* SoC construction constants */\n#if      (PROJ_MAX_SOCKETS_SUPPORTED < 1)\n  #undef  PROJ_MAX_SOCKETS_SUPPORTED\n  #define PROJ_MAX_SOCKETS_SUPPORTED      1\n#endif\n#if      (PROJ_MAX_CCD_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_CCD_DIES_PER_SOCKET\n  #define PROJ_MAX_CCD_DIES_PER_SOCKET      1\n#endif\n#if      (PROJ_MAX_MEM_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_MEM_DIES_PER_SOCKET\n  #define PROJ_MAX_MEM_DIES_PER_SOCKET      1\n#endif\n#if      (PROJ_MAX_IO_DIES_PER_SOCKET < 1)\n  #undef  PROJ_MAX_IO_DIES_PER_SOCKET\n  #define PROJ_MAX_IO_DIES_PER_SOCKET      1\n#endif\n\n/* Processor Cores sub-system constants */\n#if      (PROJ_MAX_COMPLEXES_PER_CCD < 1)\n  #undef  PROJ_MAX_COMPLEXES_PER_CCD\n  #define PROJ_MAX_COMPLEXES_PER_CCD      1\n#endif\n#if      (PROJ_MAX_CCX_CORES_PER_COMPLEX < 8)\n  #undef  PROJ_MAX_CCX_CORES_PER_COMPLEX\n  #define PROJ_MAX_CCX_CORES_PER_COMPLEX      8\n#endif\n#if      (PROJ_MAX_CCX_THREADS_PER_CORE < 2)\n  #undef  PROJ_MAX_CCX_THREADS_PER_CORE\n  #define PROJ_MAX_CCX_THREADS_PER_CORE      2\n#endif\n#if      (PROJ_CCX_MAX_DIES_PER_SOCKET < 1)\n  #undef  PROJ_CCX_MAX_DIES_PER_SOCKET\n  #define PROJ_CCX_MAX_DIES_PER_SOCKET      1\n#endif\n\n/* Memory sub-system constants */\n#if      (PROJ_MAX_UMCS_PER_MEM_DIE < 2)\n  #undef  PROJ_MAX_UMCS_PER_MEM_DIE\n  #define PROJ_MAX_UMCS_PER_MEM_DIE      2\n#endif\n#if      (PROJ_MAX_CHANNELS_PER_UMC < 1)\n  #undef  PROJ_MAX_CHANNELS_PER_UMC\n  #define PROJ_MAX_CHANNELS_PER_UMC      1\n#endif\n#if      (PROJ_MAX_DIMMS_PER_CHANNEL < 2)\n  #undef  PROJ_MAX_DIMMS_PER_CHANNEL\n  #define PROJ_MAX_DIMMS_PER_CHANNEL      2\n#endif\n\n/* IO Hub sub-system constants */",
                  "definition": "#define PROJ_MAX_HOST_BRIDGES_PER_SOCKET      1",
                  "implementation": "#define PROJ_MAX_HOST_BRIDGES_PER_SOCKET      1",
                  "range": [
                    { "line": 66, "character": 2 },
                    { "line": 66, "character": 49 }
                  ],
                  "selectionRange": [
                    { "line": 66, "character": 10 },
                    { "line": 66, "character": 42 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "DFX_FABRIC_RESOURCE_FOR_EACH_RB",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                  "documentation": "/// Resource for each RootBridge",
                  "definition": "typedef struct {\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondNonPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  IO[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  uint16_t              PciBusNumber[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n} DFX_FABRIC_RESOURCE_FOR_EACH_RB;",
                  "implementation": "typedef struct {\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeAbove4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  NonPrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrefetchableMmioSizeBelow4G[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondNonPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  PrimaryRbSecondPrefetchableMmioSizeBelow4G;\r\n  SIL_FABRIC_ADDR_APERTURE  IO[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n  uint16_t              PciBusNumber[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET];\r\n} DFX_FABRIC_RESOURCE_FOR_EACH_RB;",
                  "range": [
                    { "line": 74, "character": 0 },
                    { "line": 83, "character": 34 }
                  ],
                  "selectionRange": [
                    { "line": 83, "character": 2 },
                    { "line": 83, "character": 33 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "DFX_FABRIC_IO_MANAGER",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                  "documentation": "",
                  "definition": "typedef struct {\r\n  bool             GlobalCtrl;                                                ///< FALSE - forbid FabricAllocateIo\r\n  SIL_FABRIC_IO_REGION IoRegion[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< IO region for Skt[0~1], RB[0~3]\r\n} DFX_FABRIC_IO_MANAGER;",
                  "implementation": "typedef struct {\r\n  bool             GlobalCtrl;                                                ///< FALSE - forbid FabricAllocateIo\r\n  SIL_FABRIC_IO_REGION IoRegion[RCMGR_MAX_SOCKETS][RCMGR_MAX_RBS_PER_SOCKET]; ///< IO region for Skt[0~1], RB[0~3]\r\n} DFX_FABRIC_IO_MANAGER;",
                  "range": [
                    { "line": 119, "character": 0 },
                    { "line": 122, "character": 24 }
                  ],
                  "selectionRange": [
                    { "line": 122, "character": 2 },
                    { "line": 122, "character": 23 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "DF_IP2IP_API",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                  "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                  "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                  "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                  "range": [
                    { "line": 199, "character": 0 },
                    { "line": 226, "character": 15 }
                  ],
                  "selectionRange": [
                    { "line": 226, "character": 2 },
                    { "line": 226, "character": 14 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "X86_LEGACY_IO_SIZE",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                  "documentation": "",
                  "definition": "#define X86_LEGACY_IO_SIZE         0x1000     // IO size which is reserved for legacy devices",
                  "implementation": "#define X86_LEGACY_IO_SIZE         0x1000     // IO size which is reserved for legacy devices",
                  "range": [
                    { "line": 32, "character": 0 },
                    { "line": 32, "character": 93 }
                  ],
                  "selectionRange": [
                    { "line": 32, "character": 8 },
                    { "line": 32, "character": 26 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "DF_IO_LIMIT",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                  "documentation": "",
                  "definition": "#define DF_IO_LIMIT                         0x2000000       // IO Limit",
                  "implementation": "#define DF_IO_LIMIT                         0x2000000       // IO Limit",
                  "range": [
                    { "line": 29, "character": 0 },
                    { "line": 29, "character": 71 }
                  ],
                  "selectionRange": [
                    { "line": 29, "character": 8 },
                    { "line": 29, "character": 19 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "RCMGR_IO_SIZE_MASK",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                  "documentation": "",
                  "definition": "#define RCMGR_IO_SIZE_MASK         0xFFFFF000ull",
                  "implementation": "#define RCMGR_IO_SIZE_MASK         0xFFFFF000ull",
                  "range": [
                    { "line": 33, "character": 0 },
                    { "line": 33, "character": 48 }
                  ],
                  "selectionRange": [
                    { "line": 33, "character": 8 },
                    { "line": 33, "character": 26 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "RCMGR_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                  "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
                  "definition": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                  "implementation": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                  "range": [
                    { "line": 18, "character": 0 },
                    { "line": 23, "character": 19 }
                  ],
                  "selectionRange": [
                    { "line": 18, "character": 8 },
                    { "line": 18, "character": 24 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_INFO",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                  "implementation": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                  "range": [
                    { "line": 104, "character": 0 },
                    { "line": 104, "character": 118 }
                  ],
                  "selectionRange": [
                    { "line": 104, "character": 8 },
                    { "line": 104, "character": 22 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "X86IO_LIMIT",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                  "documentation": "",
                  "definition": "#define X86IO_LIMIT                0x10000    // X86 IO Limit",
                  "implementation": "#define X86IO_LIMIT                0x10000    // X86 IO Limit",
                  "range": [
                    { "line": 31, "character": 0 },
                    { "line": 31, "character": 61 }
                  ],
                  "selectionRange": [
                    { "line": 31, "character": 8 },
                    { "line": 31, "character": 19 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SilGetIp2IpApi",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                  "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                  "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                  "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                  "range": [
                    { "line": 190, "character": 0 },
                    { "line": 219, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 191, "character": 0 },
                    { "line": 191, "character": 14 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "SIL_STATUS",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                        "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                        "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "range": [
                          { "line": 49, "character": 0 },
                          { "line": 74, "character": 13 }
                        ],
                        "selectionRange": [
                          { "line": 74, "character": 2 },
                          { "line": 74, "character": 12 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_CONTEXT",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                        "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                        "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "range": [
                          { "line": 131, "character": 0 },
                          { "line": 135, "character": 14 }
                        ],
                        "selectionRange": [
                          { "line": 135, "character": 2 },
                          { "line": 135, "character": 13 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_DATA_BLOCK_ID",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                        "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                        "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                        "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                        "range": [
                          { "line": 48, "character": 0 },
                          { "line": 73, "character": 20 }
                        ],
                        "selectionRange": [
                          { "line": 73, "character": 2 },
                          { "line": 73, "character": 19 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_BLOCK_VARIABLES",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                        "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                        "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                        "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                        "range": [
                          { "line": 182, "character": 0 },
                          { "line": 193, "character": 22 }
                        ],
                        "selectionRange": [
                          { "line": 193, "character": 2 },
                          { "line": 193, "character": 21 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_TRACE_ERROR",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                        "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                        "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                        "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                        "range": [
                          { "line": 100, "character": 0 },
                          { "line": 100, "character": 87 }
                        ],
                        "selectionRange": [
                          { "line": 100, "character": 8 },
                          { "line": 100, "character": 23 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "__disable_tail_calls",
                        "kind": 12,
                        "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                        "documentation": "",
                        "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "range": [
                          { "line": 59, "character": 0 },
                          { "line": 59, "character": 101 }
                        ],
                        "selectionRange": [
                          { "line": 59, "character": 80 },
                          { "line": 59, "character": 100 }
                        ],
                        "dependencies": { "callTree": [] }
                      }
                    ]
                  }
                },
                {
                  "name": "__disable_tail_calls",
                  "kind": 12,
                  "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                  "documentation": "",
                  "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                  "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                  "range": [
                    { "line": 59, "character": 0 },
                    { "line": 59, "character": 101 }
                  ],
                  "selectionRange": [
                    { "line": 59, "character": 80 },
                    { "line": 59, "character": 100 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SilGetPrimaryRb",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricRcInit.c",
                  "documentation": "/**\n * SilGetPrimaryRb\n *\n * @brief Returns primary RB socket number and RB number\n *\n * @param   SilContext          A context structure through which host firmware defined data\n *                              can be passed to openSIL. The host firmware is responsible\n *                              for initializing the SIL_CONTEXT structure.\n * @param   SocketNum           Primary RB socket number\n * @param   RootBridgeNum       Primary RB number\n *\n */",
                  "definition": "void\r\nSilGetPrimaryRb (\r\n  SIL_CONTEXT      *SilContext,\r\n  uint32_t         *SocketNum,\r\n  uint32_t         *DieNum,\r\n  uint32_t         *RootBridgeNum\r\n  )",
                  "implementation": "void\r\nSilGetPrimaryRb (\r\n  SIL_CONTEXT      *SilContext,\r\n  uint32_t         *SocketNum,\r\n  uint32_t         *DieNum,\r\n  uint32_t         *RootBridgeNum\r\n  )\r\n{\r\n  ROOT_BRIDGE_LOCATION Location;\r\n  DF_IP2IP_API *DfIp2IpApi;\r\n  SIL_STATUS           Status;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  if (Status != SilPass) {\r\n    assert(Status == SilPass);\r\n    return;\r\n  }\r\n\r\n  if (DfIp2IpApi->DfGetSystemComponentRootBridgeLocation(SilContext, PrimaryFch, &Location)) {\r\n    *SocketNum = Location.Socket;\r\n    *DieNum = Location.Die;\r\n    *RootBridgeNum = Location.Index;\r\n  } else {\r\n    *SocketNum = 0;\r\n    *DieNum = 0;\r\n    *RootBridgeNum = 0;\r\n  }\r\n}",
                  "range": [
                    { "line": 25, "character": 0 },
                    { "line": 52, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 26, "character": 0 },
                    { "line": 26, "character": 15 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "SIL_CONTEXT",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                        "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                        "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "range": [
                          { "line": 131, "character": 0 },
                          { "line": 135, "character": 14 }
                        ],
                        "selectionRange": [
                          { "line": 135, "character": 2 },
                          { "line": 135, "character": 13 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "ROOT_BRIDGE_LOCATION",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/SilBaseFabricTopologyLib.h",
                        "documentation": "/// Root Bridge location",
                        "definition": "typedef struct {\r\n  uint32_t       Socket;\r\n  uint32_t       Die;\r\n  uint32_t       Index;\r\n} ROOT_BRIDGE_LOCATION;",
                        "implementation": "typedef struct {\r\n  uint32_t       Socket;\r\n  uint32_t       Die;\r\n  uint32_t       Index;\r\n} ROOT_BRIDGE_LOCATION;",
                        "range": [
                          { "line": 24, "character": 0 },
                          { "line": 28, "character": 23 }
                        ],
                        "selectionRange": [
                          { "line": 28, "character": 2 },
                          { "line": 28, "character": 22 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DF_IP2IP_API",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                        "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                        "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                        "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                        "range": [
                          { "line": 199, "character": 0 },
                          { "line": 226, "character": 15 }
                        ],
                        "selectionRange": [
                          { "line": 226, "character": 2 },
                          { "line": 226, "character": 14 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_STATUS",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                        "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                        "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "range": [
                          { "line": 49, "character": 0 },
                          { "line": 74, "character": 13 }
                        ],
                        "selectionRange": [
                          { "line": 74, "character": 2 },
                          { "line": 74, "character": 12 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SilGetIp2IpApi",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                        "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                        "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                        "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                        "range": [
                          { "line": 190, "character": 0 },
                          { "line": 219, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 191, "character": 0 },
                          { "line": 191, "character": 14 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "SIL_STATUS",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                              "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                              "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "range": [
                                { "line": 49, "character": 0 },
                                { "line": 74, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 74, "character": 2 },
                                { "line": 74, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_CONTEXT",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                              "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "range": [
                                { "line": 131, "character": 0 },
                                { "line": 135, "character": 14 }
                              ],
                              "selectionRange": [
                                { "line": 135, "character": 2 },
                                { "line": 135, "character": 13 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_DATA_BLOCK_ID",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                              "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                              "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                              "range": [
                                { "line": 48, "character": 0 },
                                { "line": 73, "character": 20 }
                              ],
                              "selectionRange": [
                                { "line": 73, "character": 2 },
                                { "line": 73, "character": 19 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_BLOCK_VARIABLES",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                              "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                              "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                              "range": [
                                { "line": 182, "character": 0 },
                                { "line": 193, "character": 22 }
                              ],
                              "selectionRange": [
                                { "line": 193, "character": 2 },
                                { "line": 193, "character": 21 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_TRACE_ERROR",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                              "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                              "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                              "range": [
                                { "line": 100, "character": 0 },
                                { "line": 100, "character": 87 }
                              ],
                              "selectionRange": [
                                { "line": 100, "character": 8 },
                                { "line": 100, "character": 23 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "__disable_tail_calls",
                              "kind": 12,
                              "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                              "documentation": "",
                              "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "range": [
                                { "line": 59, "character": 0 },
                                { "line": 59, "character": 101 }
                              ],
                              "selectionRange": [
                                { "line": 59, "character": 80 },
                                { "line": 59, "character": 100 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      },
                      {
                        "name": "__disable_tail_calls",
                        "kind": 12,
                        "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                        "documentation": "",
                        "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "range": [
                          { "line": 59, "character": 0 },
                          { "line": 59, "character": 101 }
                        ],
                        "selectionRange": [
                          { "line": 59, "character": 80 },
                          { "line": 59, "character": 100 }
                        ],
                        "dependencies": { "callTree": [] }
                      }
                    ]
                  }
                },
                {
                  "name": "DfXSilGetPhySktRbNum",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                  "documentation": "/**\n * DfXSilGetPhySktRbNum\n *\n * @brief Returns primary RB socket number and RB number\n *\n * @param   SilContext      A context structure through which host firmware defined data\n *                          can be passed to openSIL. The host firmware is responsible\n *                          for initializing the SIL_CONTEXT structure.\n * @param   DfIp2IpApi      A pointer to the data fabric I2I api\n * @param   LogSktNum       Logical socket number\n * @param   LogRbNum        Logical root bridge number\n * @param   PhySktNum       Physical socket number\n * @param   PhyRbNum        Physical root bridge number\n * @param   LogToPhyMapInit Logical-to-physical map initialized indicator\n * @param   pLogToPhyMap    Logical-to-physical map\n *\n */",
                  "definition": "void\r\nDfXSilGetPhySktRbNum (\r\n  SIL_CONTEXT   *SilContext,\r\n  DF_IP2IP_API  *DfIp2IpApi,\r\n  uint32_t      LogSktNum,\r\n  uint32_t      LogRbNum,\r\n  uint32_t      *PhySktNum,\r\n  uint32_t      *PhyRbNum,\r\n  bool          *LogToPhyMapInit,\r\n  FABRIC_RB_LOG_TO_PHY_MAP *pLogToPhyMap\r\n  )",
                  "implementation": "void\r\nDfXSilGetPhySktRbNum (\r\n  SIL_CONTEXT   *SilContext,\r\n  DF_IP2IP_API  *DfIp2IpApi,\r\n  uint32_t      LogSktNum,\r\n  uint32_t      LogRbNum,\r\n  uint32_t      *PhySktNum,\r\n  uint32_t      *PhyRbNum,\r\n  bool          *LogToPhyMapInit,\r\n  FABRIC_RB_LOG_TO_PHY_MAP *pLogToPhyMap\r\n  )\r\n{\r\n  uint32_t i;\r\n  uint32_t j;\r\n  uint32_t k;\r\n  uint32_t SysRbCount;\r\n  uint32_t SocketCount;\r\n  uint32_t DieCount;\r\n  uint32_t RbCount;\r\n  uint32_t RbNumInSkt;\r\n  FABRIC_RB_LOG_TO_PHY_MAP Temp;\r\n\r\n  if (!(*LogToPhyMapInit)) {\r\n    SysRbCount = 0;\r\n    SocketCount = DfIp2IpApi->DfGetNumberOfProcessorsPresent(SilContext);\r\n    for (i = 0; i < SocketCount; i++) {\r\n      DieCount = DfIp2IpApi->DfGetNumberOfDiesOnSocket(SilContext, i);\r\n      RbNumInSkt = 0;\r\n      for (j = 0; j < DieCount; j++) {\r\n        RbCount = DfIp2IpApi->DfGetNumberOfRootBridgesOnDie(SilContext, i, j);\r\n        for (k = 0; k < RbCount; k++) {\r\n          (pLogToPhyMap + SysRbCount)->PhySktNum = i;\r\n          (pLogToPhyMap + SysRbCount)->PhyRbNum = RbNumInSkt;\r\n          (pLogToPhyMap + SysRbCount)->PciBusBase = DfIp2IpApi->DfGetHostBridgeBusBase(SilContext, i, j, k);\r\n          (pLogToPhyMap + SysRbCount)->PciBusLimit = DfIp2IpApi->DfGetHostBridgeBusLimit(SilContext, i, j, k);\r\n          if ((pLogToPhyMap + SysRbCount)->PciBusBase > (pLogToPhyMap + SysRbCount)->PciBusLimit) {\r\n            (pLogToPhyMap + SysRbCount)->PciBusBase = 0xFFFFFFFF;\r\n            (pLogToPhyMap + SysRbCount)->PciBusLimit = 0;\r\n          }\r\n\r\n          RbNumInSkt++;\r\n          SysRbCount++;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < SysRbCount; i++) {\r\n      for (j = (SysRbCount - 1); j > i; j--) {\r\n        if ((pLogToPhyMap + j)->PciBusBase < (pLogToPhyMap + j - 1)->PciBusBase) {\r\n          Temp.PhySktNum = (pLogToPhyMap + j)->PhySktNum;\r\n          Temp.PhyRbNum = (pLogToPhyMap + j)->PhyRbNum;\r\n          Temp.PciBusBase = (pLogToPhyMap + j)->PciBusBase;\r\n          Temp.PciBusLimit = (pLogToPhyMap + j)->PciBusLimit;\r\n\r\n          (pLogToPhyMap + j)->PhySktNum = (pLogToPhyMap + j - 1)->PhySktNum;\r\n          (pLogToPhyMap + j)->PhyRbNum = (pLogToPhyMap + j - 1)->PhyRbNum;\r\n          (pLogToPhyMap + j)->PciBusBase = (pLogToPhyMap + j - 1)->PciBusBase;\r\n          (pLogToPhyMap + j)->PciBusLimit = (pLogToPhyMap + j - 1)->PciBusLimit;\r\n\r\n          (pLogToPhyMap + j - 1)->PhySktNum = Temp.PhySktNum;\r\n          (pLogToPhyMap + j - 1)->PhyRbNum = Temp.PhyRbNum;\r\n          (pLogToPhyMap + j - 1)->PciBusBase = Temp.PciBusBase;\r\n          (pLogToPhyMap + j - 1)->PciBusLimit = Temp.PciBusLimit;\r\n        }\r\n      }\r\n    }\r\n    *LogToPhyMapInit = true;\r\n  }\r\n\r\n  RbNumInSkt = DfIp2IpApi->DfGetNumberOfRootBridgesOnSocket(SilContext, 0);\r\n  *PhySktNum = (pLogToPhyMap + LogSktNum * RbNumInSkt + LogRbNum)->PhySktNum;\r\n  *PhyRbNum = (pLogToPhyMap + LogSktNum * RbNumInSkt + LogRbNum)->PhyRbNum;\r\n  RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n    \"  Logical Socket %x, Rb %x is Physical Socket%x, Rb %x\\n\",\r\n    LogSktNum,\r\n    LogRbNum,\r\n    *PhySktNum,\r\n    *PhyRbNum\r\n    );\r\n}",
                  "range": [
                    { "line": 1791, "character": 0 },
                    { "line": 1870, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 1792, "character": 0 },
                    { "line": 1792, "character": 20 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "SIL_CONTEXT",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                        "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                        "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "range": [
                          { "line": 131, "character": 0 },
                          { "line": 135, "character": 14 }
                        ],
                        "selectionRange": [
                          { "line": 135, "character": 2 },
                          { "line": 135, "character": 13 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DF_IP2IP_API",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                        "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                        "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                        "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                        "range": [
                          { "line": 199, "character": 0 },
                          { "line": 226, "character": 15 }
                        ],
                        "selectionRange": [
                          { "line": 226, "character": 2 },
                          { "line": 226, "character": 14 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "FABRIC_RB_LOG_TO_PHY_MAP",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/SilBaseFabricTopologyLib.h",
                        "documentation": "/// Logical to physical map",
                        "definition": "typedef struct _FABRIC_RB_LOG_TO_PHY_MAP {\r\n  uint32_t PhySktNum;\r\n  uint32_t PhyRbNum;\r\n  uint32_t PciBusBase;\r\n  uint32_t PciBusLimit;\r\n} FABRIC_RB_LOG_TO_PHY_MAP;",
                        "implementation": "typedef struct _FABRIC_RB_LOG_TO_PHY_MAP {\r\n  uint32_t PhySktNum;\r\n  uint32_t PhyRbNum;\r\n  uint32_t PciBusBase;\r\n  uint32_t PciBusLimit;\r\n} FABRIC_RB_LOG_TO_PHY_MAP;",
                        "range": [
                          { "line": 100, "character": 0 },
                          { "line": 105, "character": 27 }
                        ],
                        "selectionRange": [
                          { "line": 105, "character": 2 },
                          { "line": 105, "character": 26 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "RCMGR_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                        "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
                        "definition": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                        "implementation": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                        "range": [
                          { "line": 18, "character": 0 },
                          { "line": 23, "character": 19 }
                        ],
                        "selectionRange": [
                          { "line": 18, "character": 8 },
                          { "line": 18, "character": 24 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_TRACE_INFO",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                        "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                        "definition": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                        "implementation": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                        "range": [
                          { "line": 104, "character": 0 },
                          { "line": 104, "character": 118 }
                        ],
                        "selectionRange": [
                          { "line": 104, "character": 8 },
                          { "line": 104, "character": 22 }
                        ],
                        "dependencies": { "callTree": [] }
                      }
                    ]
                  }
                },
                {
                  "name": "SilSetIoReg4",
                  "kind": 11,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/FabricRcInit.c",
                  "documentation": "/**\n * SilSetIoReg4\n *\n * @brief Set IO register pairs according to input parameters\n *\n * @param   SilContext          A context structure through which host firmware defined data\n *                              can be passed to openSIL. The host firmware is responsible\n *                              for initializing the SIL_CONTEXT structure.\n * @param   TotalSocket         System socket count\n * @param   RegIndex            Which IO register should be set\n * @param   SktNum              Socket number\n * @param   RbNum               Root bridge number\n * @param   IoBase              Base address of IO region\n * @param   IoSize              Length of IO region\n *\n */",
                  "definition": "void\r\nSilSetIoReg4 (\r\n  SIL_CONTEXT     *SilContext,\r\n  uint8_t         TotalSocket,\r\n  uint8_t         RegIndex,\r\n  uint32_t        SktNum,\r\n  uint32_t        RbNum,\r\n  uint32_t        IoBase,\r\n  uint32_t        IoSize\r\n  )",
                  "implementation": "void\r\nSilSetIoReg4 (\r\n  SIL_CONTEXT     *SilContext,\r\n  uint8_t         TotalSocket,\r\n  uint8_t         RegIndex,\r\n  uint32_t        SktNum,\r\n  uint32_t        RbNum,\r\n  uint32_t        IoBase,\r\n  uint32_t        IoSize\r\n  )\r\n{\r\n  uint32_t  i;\r\n  uint32_t  j;\r\n  uint32_t  DiePerSkt;\r\n  X86_IOBASE_ADDRESS_REGISTER  IoBaseReg;\r\n  DF_IP2IP_API *DfIp2IpApi;\r\n  SIL_STATUS    Status;\r\n\r\n  Status = SilGetIp2IpApi(SilContext, SilId_DfClass, (void **) &DfIp2IpApi);\r\n  assert(Status == SilPass);\r\n\r\n  IoBaseReg.Value = 0;\r\n  IoBaseReg.Field.RE = 1;\r\n  IoBaseReg.Field.WE = 1;\r\n  IoBaseReg.Field.IOBase = (IoBase & 0xFFFFF000) >> 12;\r\n\r\n  for (i = 0; i < TotalSocket; i++) {\r\n    DiePerSkt = DfIp2IpApi->DfGetNumberOfDiesOnSocket(SilContext, i);\r\n    for (j = 0; j < DiePerSkt; j++) {\r\n      /*\r\n         Writing into abstract x86 IOLIMIT register fields: DstFabricID and IOLIMIT\r\n       */\r\n      DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n        (uint8_t) X86_IOLIMIT_ADDRESS0_DstFabricID,\r\n        (uint32_t)i,\r\n        RegIndex,\r\n        FABRIC_REG_ACC_BC,\r\n        0,\r\n        DF_ABSTRACT_REG_WRITE,\r\n        (uint32_t) DfIp2IpApi->DfGetHostBridgeSystemFabricID(SilContext, SktNum, 0, RbNum),\r\n        0\r\n        );\r\n\r\n      DfIp2IpApi->DfAbstractRegAcc(SilContext,\r\n        (uint8_t) X86_IOLIMIT_ADDRESS0_IOLimit,\r\n        (uint32_t)i,\r\n        RegIndex,\r\n        FABRIC_REG_ACC_BC,\r\n        0,\r\n        DF_ABSTRACT_REG_WRITE,\r\n        ((IoBase + IoSize - 1) & 0xFFFFF000) >> 12,\r\n        0\r\n        );\r\n\r\n      // Enable after limit is set\r\n      DfIp2IpApi->DfFabricRegisterAccWrite(SilContext,\r\n        i,\r\n        j,\r\n        X86IOBASEADDRESS_0_FUNC,\r\n        (X86IOBASEADDRESS_0_REG + RegIndex * (X86IOBASEADDRESS_1_REG - X86IOBASEADDRESS_0_REG)),\r\n        FABRIC_REG_ACC_BC,\r\n        IoBaseReg.Value\r\n        );\r\n    }\r\n  }\r\n\r\n  RCMGR_TRACEPOINT(SIL_TRACE_INFO,\r\n    \"  openSIL set IO pair #%X, 0x%X000 ~ 0x%XFFF DstFabricID: 0x%X\\n\",\r\n    RegIndex,\r\n    (uint32_t) (IoBase >> 12),\r\n    (uint32_t) ((IoBase + IoSize - 1) >> 12),\r\n    (uint32_t) DfIp2IpApi->DfGetHostBridgeSystemFabricID(SilContext, SktNum, 0, RbNum)\r\n    );\r\n\r\n}",
                  "range": [
                    { "line": 1698, "character": 0 },
                    { "line": 1772, "character": 1 }
                  ],
                  "selectionRange": [
                    { "line": 1699, "character": 0 },
                    { "line": 1699, "character": 12 }
                  ],
                  "dependencies": {
                    "callTree": [
                      {
                        "name": "SIL_CONTEXT",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                        "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                        "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                        "range": [
                          { "line": 131, "character": 0 },
                          { "line": 135, "character": 14 }
                        ],
                        "selectionRange": [
                          { "line": 135, "character": 2 },
                          { "line": 135, "character": 13 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "X86_IOBASE_ADDRESS_REGISTER",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                        "documentation": "",
                        "definition": "typedef union {\r\n  struct {\r\n    uint32_t RE:1;\r\n    uint32_t WE:1;\r\n    uint32_t :3;\r\n    uint32_t IE:1;\r\n    uint32_t :10;\r\n    uint32_t IOBase:13;\r\n    uint32_t :3;\r\n  } Field;\r\n  uint32_t  Value;\r\n} X86_IOBASE_ADDRESS_REGISTER;",
                        "implementation": "typedef union {\r\n  struct {\r\n    uint32_t RE:1;\r\n    uint32_t WE:1;\r\n    uint32_t :3;\r\n    uint32_t IE:1;\r\n    uint32_t :10;\r\n    uint32_t IOBase:13;\r\n    uint32_t :3;\r\n  } Field;\r\n  uint32_t  Value;\r\n} X86_IOBASE_ADDRESS_REGISTER;",
                        "range": [
                          { "line": 136, "character": 0 },
                          { "line": 147, "character": 30 }
                        ],
                        "selectionRange": [
                          { "line": 147, "character": 2 },
                          { "line": 147, "character": 29 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DF_IP2IP_API",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfIp2Ip.h",
                        "documentation": "// Define the Ip2Ip API as a struct containing pointers to these functions",
                        "definition": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                        "implementation": "typedef struct {\r\n  DF_NUMBER_OF_PROCESSORS_PRESENT        DfGetNumberOfProcessorsPresent;\r\n  DF_NUMBER_OF_SYSTEM_DIES               DfGetNumberOfSystemDies;\r\n  DF_NUMBER_OF_SYSTEM_ROOT_BRIDGES       DfGetNumberOfSystemRootBridges;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_SOCKET    DfGetNumberOfRootBridgesOnSocket;\r\n  DF_NUMBER_OF_ROOT_BRIDGES_ON_DIE       DfGetNumberOfRootBridgesOnDie;\r\n  DF_DIE_SYSTEM_OFFSET                   DfGetDieSystemOffset;\r\n  DF_DEVICE_MAP_ON_DIE                   DfGetDeviceMapOnDie;\r\n  DF_HOST_BRIDGE_BUS_BASE                DfGetHostBridgeBusBase;\r\n  DF_GET_NUMBER_OF_BUS_REGIONS           DfGetNumberOfBusRegions;\r\n  DF_HOST_BRIDGE_BUS_LIMIT               DfGetHostBridgeBusLimit;\r\n  DF_PHYS_ROOT_BRIDGE_NUMBER             DfGetPhysRootBridgeNumber;\r\n  DF_NUMBER_OF_DIES_ON_SOCKET            DfGetNumberOfDiesOnSocket;\r\n  DF_GET_HOST_BRIDGE_SYSTEM_FABRIC_ID    DfGetHostBridgeSystemFabricID;\r\n  DF_GET_SYS_COMPONENT_RB_LOC            DfGetSystemComponentRootBridgeLocation;\r\n  DF_HAS_FCH                             DfHasFch;\r\n  DF_HAS_SMU                             DfHasSmu;\r\n  DF_FIND_DEVICE_TYPE_ENTRY_IN_MAP       DfFindDeviceTypeEntryInMap;\r\n  DF_FABRIC_REGISTER_ACC_READ            DfFabricRegisterAccRead;\r\n  DF_FABRIC_REGISTER_ACC_WRITE           DfFabricRegisterAccWrite;\r\n  DF_GET_WDT_INFO                        DfGetWdtInfo;\r\n  DF_GET_ROOT_BRIDGE_INFO                DfGetRootBridgeInfo;\r\n  DF_GET_DIE_INFO                        DfGetDieInfo;\r\n  DF_GET_PROCESSOR_INFO                  DfGetProcessorInfo;\r\n  DF_GET_SYSTEM_INFO                     DfGetSystemInfo;\r\n  DF_GET_DOMAINXLAT_INFO                 DfDomainXlat;\r\n  DF_ABSTRACT_REG_ACC                    DfAbstractRegAcc;\r\n} DF_IP2IP_API;",
                        "range": [
                          { "line": 199, "character": 0 },
                          { "line": 226, "character": 15 }
                        ],
                        "selectionRange": [
                          { "line": 226, "character": 2 },
                          { "line": 226, "character": 14 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_STATUS",
                        "kind": 10,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                        "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                        "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                        "range": [
                          { "line": 49, "character": 0 },
                          { "line": 74, "character": 13 }
                        ],
                        "selectionRange": [
                          { "line": 74, "character": 2 },
                          { "line": 74, "character": 12 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "FABRIC_REG_ACC_BC",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/Common/FabricRegisterAccCmn.h",
                        "documentation": "/**\n * @file  FabricRegisterAccCmn.h\n * @brief Common definitions for Df fabric register access\n *\n */",
                        "definition": "#define FABRIC_REG_ACC_BC    (0xFFFFFFFF)",
                        "implementation": "#define FABRIC_REG_ACC_BC    (0xFFFFFFFF)",
                        "range": [
                          { "line": 12, "character": 0 },
                          { "line": 12, "character": 41 }
                        ],
                        "selectionRange": [
                          { "line": 12, "character": 8 },
                          { "line": 12, "character": 25 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "DF_ABSTRACT_REG_WRITE",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                        "documentation": "// Registers that are not supported in a specific program in register abstraction",
                        "definition": "#define DF_ABSTRACT_REG_WRITE  1",
                        "implementation": "#define DF_ABSTRACT_REG_WRITE  1",
                        "range": [
                          { "line": 90, "character": 0 },
                          { "line": 90, "character": 32 }
                        ],
                        "selectionRange": [
                          { "line": 90, "character": 8 },
                          { "line": 90, "character": 29 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "X86IOBASEADDRESS_0_FUNC",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                        "documentation": "",
                        "definition": "#define X86IOBASEADDRESS_0_FUNC 0x0",
                        "implementation": "#define X86IOBASEADDRESS_0_FUNC 0x0",
                        "range": [
                          { "line": 131, "character": 0 },
                          { "line": 131, "character": 35 }
                        ],
                        "selectionRange": [
                          { "line": 131, "character": 8 },
                          { "line": 131, "character": 31 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "X86IOBASEADDRESS_0_REG",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                        "documentation": "",
                        "definition": "#define X86IOBASEADDRESS_0_REG  0xD00",
                        "implementation": "#define X86IOBASEADDRESS_0_REG  0xD00",
                        "range": [
                          { "line": 132, "character": 0 },
                          { "line": 132, "character": 37 }
                        ],
                        "selectionRange": [
                          { "line": 132, "character": 8 },
                          { "line": 132, "character": 30 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "X86IOBASEADDRESS_1_REG",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/DF/DfX/SilFabricRegistersDfX.h",
                        "documentation": "",
                        "definition": "#define X86IOBASEADDRESS_1_REG  0xD08",
                        "implementation": "#define X86IOBASEADDRESS_1_REG  0xD08",
                        "range": [
                          { "line": 134, "character": 0 },
                          { "line": 134, "character": 37 }
                        ],
                        "selectionRange": [
                          { "line": 134, "character": 8 },
                          { "line": 134, "character": 30 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "RCMGR_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
                        "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
                        "definition": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                        "implementation": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
                        "range": [
                          { "line": 18, "character": 0 },
                          { "line": 23, "character": 19 }
                        ],
                        "selectionRange": [
                          { "line": 18, "character": 8 },
                          { "line": 18, "character": 24 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SIL_TRACE_INFO",
                        "kind": 13,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                        "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                        "definition": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                        "implementation": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                        "range": [
                          { "line": 104, "character": 0 },
                          { "line": 104, "character": 118 }
                        ],
                        "selectionRange": [
                          { "line": 104, "character": 8 },
                          { "line": 104, "character": 22 }
                        ],
                        "dependencies": { "callTree": [] }
                      },
                      {
                        "name": "SilGetIp2IpApi",
                        "kind": 11,
                        "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
                        "documentation": "/**\n * SilGetIp2IpApi\n *\n * @details This function is used by openSIL IPs to find and return a pointer to the Ip-2-Ip API installed for the\n *          specified IP ID.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP block to request the Ip-2-Ip API for.  The list of\n *                       valid Ids is defined in xSIM-api.h.\n * @param   Api          Upon success, this output is a pointer to the Ip-2-Ip API.\n *\n * @returns SIL_STATUS\n * @retval  SilPass     The Api was found and returned in the Api pointer\n * @retval  SilNotFound No API was installed for IP\n *\n */",
                        "definition": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )",
                        "implementation": "SIL_STATUS\r\nSilGetIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                **Api\r\n  )\r\n{\r\n  SIL_STATUS          Status;\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  // Comment this TRACEPOINT to reduce debug output\r\n  //XUSL_TRACEPOINT (SIL_TRACE_INFO, \"Get Ip-2-Ip API for IP ID %d\\n\", IpId);\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n\r\n  Status = SilPass;\r\n\r\n  *Api = (void *)((uintptr_t)SilVars->Ip2IpApi[IpId]);\r\n  if (*Api == NULL) {\r\n    Status = SilNotFound;\r\n    XUSL_TRACEPOINT(SIL_TRACE_ERROR, \"Ip-2-Ip API for IP ID %d NOT FOUND!\\n\", IpId);\r\n    assert(*Api != NULL);// Assert if the requested API is null\r\n  }\r\n\r\n  return Status;\r\n}",
                        "range": [
                          { "line": 190, "character": 0 },
                          { "line": 219, "character": 1 }
                        ],
                        "selectionRange": [
                          { "line": 191, "character": 0 },
                          { "line": 191, "character": 14 }
                        ],
                        "dependencies": {
                          "callTree": [
                            {
                              "name": "SIL_STATUS",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                              "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                              "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                              "range": [
                                { "line": 49, "character": 0 },
                                { "line": 74, "character": 13 }
                              ],
                              "selectionRange": [
                                { "line": 74, "character": 2 },
                                { "line": 74, "character": 12 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_CONTEXT",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                              "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                              "range": [
                                { "line": 131, "character": 0 },
                                { "line": 135, "character": 14 }
                              ],
                              "selectionRange": [
                                { "line": 135, "character": 2 },
                                { "line": 135, "character": 13 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_DATA_BLOCK_ID",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                              "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                              "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                              "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                              "range": [
                                { "line": 48, "character": 0 },
                                { "line": 73, "character": 20 }
                              ],
                              "selectionRange": [
                                { "line": 73, "character": 2 },
                                { "line": 73, "character": 19 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_BLOCK_VARIABLES",
                              "kind": 10,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                              "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                              "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                              "range": [
                                { "line": 182, "character": 0 },
                                { "line": 193, "character": 22 }
                              ],
                              "selectionRange": [
                                { "line": 193, "character": 2 },
                                { "line": 193, "character": 21 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "SIL_TRACE_ERROR",
                              "kind": 13,
                              "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                              "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                              "definition": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                              "implementation": "#define SIL_TRACE_ERROR   BIT_32(0)   ///< Unexpected/unwanted (problematic) conditions",
                              "range": [
                                { "line": 100, "character": 0 },
                                { "line": 100, "character": 87 }
                              ],
                              "selectionRange": [
                                { "line": 100, "character": 8 },
                                { "line": 100, "character": 23 }
                              ],
                              "dependencies": { "callTree": [] }
                            },
                            {
                              "name": "__disable_tail_calls",
                              "kind": 12,
                              "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                              "documentation": "",
                              "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                              "range": [
                                { "line": 59, "character": 0 },
                                { "line": 59, "character": 101 }
                              ],
                              "selectionRange": [
                                { "line": 59, "character": 80 },
                                { "line": 59, "character": 100 }
                              ],
                              "dependencies": { "callTree": [] }
                            }
                          ]
                        }
                      },
                      {
                        "name": "__disable_tail_calls",
                        "kind": 12,
                        "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                        "documentation": "",
                        "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                        "range": [
                          { "line": 59, "character": 0 },
                          { "line": 59, "character": 101 }
                        ],
                        "selectionRange": [
                          { "line": 59, "character": 80 },
                          { "line": 59, "character": 100 }
                        ],
                        "dependencies": { "callTree": [] }
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "name": "SilInitIoEqually4",
            "kind": 11,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Source/xUSL/RcMgr/DfX/PHX/RcMgrSetInputBlkPhxUt/RcMgrSetInputBlkPhxUt.c",
            "documentation": "/**\n * SilInitIoEqually4\n *\n * @brief Initialize IO registers for each RootBridge evenly.\n *\n * @param   SilContext              A context structure through which host firmware defined data\n *                                  can be passed to openSIL. The host firmware is responsible\n *                                  for initializing the SIL_CONTEXT structure.\n * @param   SilData                 Pointer to DFX_RCMGR_INPUT_BLK data structure:\n * @param   SilData->IoRcMgr        Point to DFX_FABRIC_IO_MANAGER\n * @param   SilData->SocketNumber   System socket count\n * @param   SilData->RbsPerSocket   RootBridge number per socket\n *\n */",
            "definition": "SIL_STATUS\r\nSilInitIoEqually4 (\r\n  SIL_CONTEXT         *SilContext,\r\n  DFX_RCMGR_INPUT_BLK *SilData\r\n  )",
            "implementation": "SIL_STATUS\r\nSilInitIoEqually4 (\r\n  SIL_CONTEXT         *SilContext,\r\n  DFX_RCMGR_INPUT_BLK *SilData\r\n  )\r\n{\r\n  return SilPass;\r\n}",
            "range": [
              { "line": 58, "character": 0 },
              { "line": 65, "character": 1 }
            ],
            "selectionRange": [
              { "line": 59, "character": 0 },
              { "line": 59, "character": 17 }
            ],
            "dependencies": {
              "callTree": [
                {
                  "name": "SIL_STATUS",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                  "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                  "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "range": [
                    { "line": 49, "character": 0 },
                    { "line": 74, "character": 13 }
                  ],
                  "selectionRange": [
                    { "line": 74, "character": 2 },
                    { "line": 74, "character": 12 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_CONTEXT",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                  "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "range": [
                    { "line": 131, "character": 0 },
                    { "line": 135, "character": 14 }
                  ],
                  "selectionRange": [
                    { "line": 135, "character": 2 },
                    { "line": 135, "character": 13 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "DFX_RCMGR_INPUT_BLK",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/RcManager-api.h",
                  "documentation": "",
                  "definition": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                  "implementation": "typedef struct {\r\n  DFX_FABRIC_IO_MANAGER   IoRcMgr;\r\n  DFX_FABRIC_MMIO_MANAGER MmioRcMgr;\r\n  bool      SetRcBasedOnNv;\r\n  bool      SetRdOnNv;                                    ///< is Resource Distribution input valid?\r\n  uint8_t   SocketNumber;\r\n  uint8_t   RbsPerSocket;\r\n  bool      McptEnable;\r\n  uint64_t  PciExpressBaseAddress;\r\n  uint32_t  BottomMmioReservedForPrimaryRb;\r\n  uint64_t  MmioLimitAbovePcieCfg;                        ///< PCIe Config MMIO upper limit\r\n  uint64_t  MmioLimitBelowPcieCfg;                        ///< PCIe Config MMIO lower limit\r\n  uint32_t  MmioSizePerRbForNonPciDevice;\r\n  uint64_t  MmioAbove4GLimit;\r\n  uint32_t  Above4GMmioSizePerRbForNonPciDevice;\r\n  bool      AmdSmee;\r\n  uint8_t   AmdFabric1TbRemap;\r\n  bool      ResourceDistributionNv[RCMGR_MAX_SOCKETS * RCMGR_MAX_RBS_PER_SOCKET];\r\n  DFX_FABRIC_RESOURCE_FOR_EACH_RB ResourceSizeForEachRb;\r\n} DFX_RCMGR_INPUT_BLK;",
                  "range": [
                    { "line": 124, "character": 0 },
                    { "line": 143, "character": 22 }
                  ],
                  "selectionRange": [
                    { "line": 143, "character": 2 },
                    { "line": 143, "character": 21 }
                  ],
                  "dependencies": { "callTree": [] }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "name": "InitializeRcMgrPhxTp2",
      "kind": 11,
      "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/PHX/RcMgrPhx.c",
      "documentation": "/**\n * InitializeRcMgrPhxTp2\n *\n * @brief Initialize PHX resource manager at Tp2.\n *\n * @param   SilContext          A context structure through which host firmware defined data\n *                              can be passed to openSIL. The host firmware is responsible\n *                              for initializing the SIL_CONTEXT structure.\n */",
      "definition": "SIL_STATUS\r\nInitializeRcMgrPhxTp2 (\r\n  SIL_CONTEXT  *SilContext\r\n  )",
      "implementation": "SIL_STATUS\r\nInitializeRcMgrPhxTp2 (\r\n  SIL_CONTEXT  *SilContext\r\n  )\r\n{\r\n  RCMGR_TRACEPOINT(SIL_TRACE_ENTRY, \"\\n\");\r\n  RCMGR_TRACEPOINT(SIL_TRACE_EXIT, \"\\n\");\r\n  return SilPass;\r\n}",
      "range": [
        { "line": 150, "character": 0 },
        { "line": 158, "character": 1 }
      ],
      "selectionRange": [
        { "line": 151, "character": 0 },
        { "line": 151, "character": 21 }
      ],
      "dependencies": {
        "callTree": [
          {
            "name": "SIL_STATUS",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
            "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
            "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
            "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
            "range": [
              { "line": 49, "character": 0 },
              { "line": 74, "character": 13 }
            ],
            "selectionRange": [
              { "line": 74, "character": 2 },
              { "line": 74, "character": 12 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SIL_CONTEXT",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
            "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
            "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
            "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
            "range": [
              { "line": 131, "character": 0 },
              { "line": 135, "character": 14 }
            ],
            "selectionRange": [
              { "line": 135, "character": 2 },
              { "line": 135, "character": 13 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "RCMGR_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
            "kind": 13,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
            "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
            "definition": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
            "implementation": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
            "range": [
              { "line": 18, "character": 0 },
              { "line": 23, "character": 19 }
            ],
            "selectionRange": [
              { "line": 18, "character": 8 },
              { "line": 18, "character": 24 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SIL_TRACE_ENTRY",
            "kind": 13,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
            "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
            "definition": "#define SIL_TRACE_ENTRY   BIT_32(2)   ///< Messages showing entry flow",
            "implementation": "#define SIL_TRACE_ENTRY   BIT_32(2)   ///< Messages showing entry flow",
            "range": [
              { "line": 102, "character": 0 },
              { "line": 102, "character": 70 }
            ],
            "selectionRange": [
              { "line": 102, "character": 8 },
              { "line": 102, "character": 23 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SIL_TRACE_EXIT",
            "kind": 13,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
            "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
            "definition": "#define SIL_TRACE_EXIT    BIT_32(3)   ///< Messages showing exit flow",
            "implementation": "#define SIL_TRACE_EXIT    BIT_32(3)   ///< Messages showing exit flow",
            "range": [
              { "line": 103, "character": 0 },
              { "line": 103, "character": 69 }
            ],
            "selectionRange": [
              { "line": 103, "character": 8 },
              { "line": 103, "character": 22 }
            ],
            "dependencies": { "callTree": [] }
          }
        ]
      }
    },
    {
      "name": "InitializeRcMgrPhxTp3",
      "kind": 11,
      "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/PHX/RcMgrPhx.c",
      "documentation": "/**\n * InitializeRcMgrPhxTp3\n *\n * @brief Initialize PHX resource manager at Tp3.\n *\n * @param   SilContext          A context structure through which host firmware defined data\n *                              can be passed to openSIL. The host firmware is responsible\n *                              for initializing the SIL_CONTEXT structure.\n */",
      "definition": "SIL_STATUS\r\nInitializeRcMgrPhxTp3 (\r\n  SIL_CONTEXT  *SilContext\r\n  )",
      "implementation": "SIL_STATUS\r\nInitializeRcMgrPhxTp3 (\r\n  SIL_CONTEXT  *SilContext\r\n  )\r\n{\r\n  RCMGR_TRACEPOINT(SIL_TRACE_ENTRY, \"\\n\");\r\n  RCMGR_TRACEPOINT(SIL_TRACE_EXIT, \"\\n\");\r\n  return SilPass;\r\n}",
      "range": [
        { "line": 169, "character": 0 },
        { "line": 177, "character": 1 }
      ],
      "selectionRange": [
        { "line": 170, "character": 0 },
        { "line": 170, "character": 21 }
      ],
      "dependencies": {
        "callTree": [
          {
            "name": "SIL_STATUS",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
            "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
            "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
            "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
            "range": [
              { "line": 49, "character": 0 },
              { "line": 74, "character": 13 }
            ],
            "selectionRange": [
              { "line": 74, "character": 2 },
              { "line": 74, "character": 12 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SIL_CONTEXT",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
            "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
            "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
            "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
            "range": [
              { "line": 131, "character": 0 },
              { "line": 135, "character": 14 }
            ],
            "selectionRange": [
              { "line": 135, "character": 2 },
              { "line": 135, "character": 13 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "RCMGR_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
            "kind": 13,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/Common/FabricResourceManager.h",
            "documentation": "/**\n * @file  FabricResourceManager.h\n * @brief OpenSIL Fabric resource manager common definition\n */",
            "definition": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
            "implementation": "#define RCMGR_TRACEPOINT(MsgLevel, Message, ...)        \\\r\n        do {                \\\r\n          if (DEBUG_FILTER_RCMGR & SIL_DEBUG_MODULE_FILTER) {    \\\r\n            XUSL_TRACEPOINT(MsgLevel, Message, ## __VA_ARGS__);  \\\r\n          } \\\r\n        } while (0)",
            "range": [
              { "line": 18, "character": 0 },
              { "line": 23, "character": 19 }
            ],
            "selectionRange": [
              { "line": 18, "character": 8 },
              { "line": 18, "character": 24 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SIL_TRACE_ENTRY",
            "kind": 13,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
            "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
            "definition": "#define SIL_TRACE_ENTRY   BIT_32(2)   ///< Messages showing entry flow",
            "implementation": "#define SIL_TRACE_ENTRY   BIT_32(2)   ///< Messages showing entry flow",
            "range": [
              { "line": 102, "character": 0 },
              { "line": 102, "character": 70 }
            ],
            "selectionRange": [
              { "line": 102, "character": 8 },
              { "line": 102, "character": 23 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SIL_TRACE_EXIT",
            "kind": 13,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
            "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
            "definition": "#define SIL_TRACE_EXIT    BIT_32(3)   ///< Messages showing exit flow",
            "implementation": "#define SIL_TRACE_EXIT    BIT_32(3)   ///< Messages showing exit flow",
            "range": [
              { "line": 103, "character": 0 },
              { "line": 103, "character": 69 }
            ],
            "selectionRange": [
              { "line": 103, "character": 8 },
              { "line": 103, "character": 22 }
            ],
            "dependencies": { "callTree": [] }
          }
        ]
      }
    },
    {
      "name": "InitializeApiRcMgrPhx",
      "kind": 11,
      "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/PHX/RcMgrPhx.c",
      "documentation": "/**\n * InitializeApiRcMgrPhx\n *\n * @brief   Initialize internal and external APIs for Resource Manager\n *\n * @param   SilContext          A context structure through which host firmware defined data\n *                              can be passed to openSIL. The host firmware is responsible\n *                              for initializing the SIL_CONTEXT structure.\n * @retval  SilPass             API initialized successfully\n * @retval  SilInvalidParameter Id class is invalid\n *\n */",
      "definition": "SIL_STATUS\r\nInitializeApiRcMgrPhx (\r\n  SIL_CONTEXT  *SilContext\r\n  )",
      "implementation": "SIL_STATUS\r\nInitializeApiRcMgrPhx (\r\n  SIL_CONTEXT  *SilContext\r\n  )\r\n{\r\n  SIL_STATUS  Status;\r\n\r\n  // Initialize Common to Rev specific transfer table first\r\n  Status = SilInitCommon2RevXferTable(SilContext, SilId_RcManager, (void *)&mRcMgrXferPhx);\r\n  if (Status != SilPass) {\r\n    return Status;\r\n  }\r\n\r\n  return SilInitIp2IpApi(SilContext, SilId_RcManager, (void *)&mRcMgrApiPhx);\r\n}",
      "range": [
        { "line": 191, "character": 0 },
        { "line": 205, "character": 1 }
      ],
      "selectionRange": [
        { "line": 192, "character": 0 },
        { "line": 192, "character": 21 }
      ],
      "dependencies": {
        "callTree": [
          {
            "name": "SIL_STATUS",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
            "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
            "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
            "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
            "range": [
              { "line": 49, "character": 0 },
              { "line": 74, "character": 13 }
            ],
            "selectionRange": [
              { "line": 74, "character": 2 },
              { "line": 74, "character": 12 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SIL_CONTEXT",
            "kind": 10,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
            "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
            "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
            "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
            "range": [
              { "line": 131, "character": 0 },
              { "line": 135, "character": 14 }
            ],
            "selectionRange": [
              { "line": 135, "character": 2 },
              { "line": 135, "character": 13 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "mRcMgrXferPhx",
            "kind": 12,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/PHX/RcMgrCmn2Phx.c",
            "documentation": "/**\n * @file  RcMgrCmn2Phx.c\n * @brief OpenSIL Resource Manager PHX transfer block functions\n *\n */",
            "definition": "RCMGR_COMMON_2_REV_XFER_BLOCK mRcMgrXferPhx = {\r\n  .Header = {\r\n    .Version = 1\r\n  }\r\n};",
            "implementation": "RCMGR_COMMON_2_REV_XFER_BLOCK mRcMgrXferPhx = {\r\n  .Header = {\r\n    .Version = 1\r\n  }\r\n};",
            "range": [
              { "line": 12, "character": 0 },
              { "line": 16, "character": 2 }
            ],
            "selectionRange": [
              { "line": 12, "character": 30 },
              { "line": 12, "character": 43 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "mRcMgrApiPhx",
            "kind": 12,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Source/xUSL/Nbio/Common/NbioUT/MockNbioUT.c",
            "documentation": "",
            "definition": "RCMGR_IP2IP_API mRcMgrApiPhx = {\r\n    .FabricReserveMmio    = FabricReserveMmio\r\n};",
            "implementation": "RCMGR_IP2IP_API mRcMgrApiPhx = {\r\n    .FabricReserveMmio    = FabricReserveMmio\r\n};",
            "range": [
              { "line": 325, "character": 0 },
              { "line": 327, "character": 2 }
            ],
            "selectionRange": [
              { "line": 325, "character": 16 },
              { "line": 325, "character": 28 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "mRcMgrApiPhx",
            "kind": 12,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/UnitTest/Source/xUSL/Nbio/Phx/NbioIommuUT/NbioIommuUT.c",
            "documentation": "",
            "definition": "RCMGR_IP2IP_API mRcMgrApiPhx = {\r\n    .FabricReserveMmio    = LocalFabricReserveMmio\r\n};",
            "implementation": "RCMGR_IP2IP_API mRcMgrApiPhx = {\r\n    .FabricReserveMmio    = LocalFabricReserveMmio\r\n};",
            "range": [
              { "line": 58, "character": 0 },
              { "line": 60, "character": 2 }
            ],
            "selectionRange": [
              { "line": 58, "character": 16 },
              { "line": 58, "character": 28 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "mRcMgrApiPhx",
            "kind": 12,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/RcMgr/DfX/PHX/RcMgrIp2IpPhx.c",
            "documentation": "/**\n * @file RcMgrIp2IpPhx.c\n * @brief PHX RCMGR core specific transfer table functions\n *\n */",
            "definition": "RCMGR_IP2IP_API mRcMgrApiPhx = {\r\n  .FabricReserveMmio = FabricReserveMmio\r\n};",
            "implementation": "RCMGR_IP2IP_API mRcMgrApiPhx = {\r\n  .FabricReserveMmio = FabricReserveMmio\r\n};",
            "range": [
              { "line": 10, "character": 0 },
              { "line": 12, "character": 2 }
            ],
            "selectionRange": [
              { "line": 10, "character": 16 },
              { "line": 10, "character": 28 }
            ],
            "dependencies": { "callTree": [] }
          },
          {
            "name": "SilInitCommon2RevXferTable",
            "kind": 11,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
            "documentation": "/**\n * SilInitCommon2RevXferTable\n *\n * @brief   Register an IP Common to revision specific transfer table.\n *\n * @details The common to revision specific transfer table is an interface from common code to abstracted program\n *          specific code.\n *\n * @param   SilContext  A context structure through which host firmware defined data\n *                      can be passed to openSIL. The host firmware is responsible\n *                      for initializing the SIL_CONTEXT structure.\n * @param   IpId        The ID of the IP providing the table.\n * @param   XferTable   Input of the transfar table to initialize.\n *\n * @retval  SilPass             The Xfer table was initialized for IpId.\n * @retval  SilInvalidParameter The Ip ID was outside the bounds of valid IDs defined by SIL_DATA_BLOCK_ID.\n *\n */",
            "definition": "SIL_STATUS\r\nSilInitCommon2RevXferTable (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                *XferTable\r\n  )",
            "implementation": "SIL_STATUS\r\nSilInitCommon2RevXferTable (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                *XferTable\r\n  )\r\n{\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  XUSL_TRACEPOINT(SIL_TRACE_ENTRY, \"\\n\");\r\n\r\n  assert(IpId < SilId_ListEnd);\r\n  if (IpId >= SilId_ListEnd) {\r\n    return SilInvalidParameter;\r\n  }\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The transfer table (Common2RevXferTable) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n  XUSL_TRACEPOINT(SIL_TRACE_INFO, \"Initializing transfer table for IP ID = %d\\n\", IpId);\r\n  SilVars->Common2RevXferTable[IpId] = (uintptr_t)XferTable;\r\n\r\n  XUSL_TRACEPOINT(SIL_TRACE_EXIT, \"\\n\");\r\n  return SilPass;\r\n}",
            "range": [
              { "line": 239, "character": 0 },
              { "line": 265, "character": 1 }
            ],
            "selectionRange": [
              { "line": 240, "character": 0 },
              { "line": 240, "character": 26 }
            ],
            "dependencies": {
              "callTree": [
                {
                  "name": "SIL_STATUS",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                  "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                  "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "range": [
                    { "line": 49, "character": 0 },
                    { "line": 74, "character": 13 }
                  ],
                  "selectionRange": [
                    { "line": 74, "character": 2 },
                    { "line": 74, "character": 12 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_CONTEXT",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                  "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "range": [
                    { "line": 131, "character": 0 },
                    { "line": 135, "character": 14 }
                  ],
                  "selectionRange": [
                    { "line": 135, "character": 2 },
                    { "line": 135, "character": 13 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_DATA_BLOCK_ID",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                  "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                  "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                  "range": [
                    { "line": 48, "character": 0 },
                    { "line": 73, "character": 20 }
                  ],
                  "selectionRange": [
                    { "line": 73, "character": 2 },
                    { "line": 73, "character": 19 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_BLOCK_VARIABLES",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                  "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                  "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                  "range": [
                    { "line": 182, "character": 0 },
                    { "line": 193, "character": 22 }
                  ],
                  "selectionRange": [
                    { "line": 193, "character": 2 },
                    { "line": 193, "character": 21 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "XUSL_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "",
                  "definition": "#define XUSL_TRACEPOINT(MsgLevel, Message, ...) \\\r\n        do { \\\r\n          if (SIL_DEBUG_ENABLE) { \\\r\n            ((HOST_DEBUG_SERVICE)SilTracePoint) (MsgLevel, \"SIL:xUSL:\", \\\r\n            Message, __FUNCTION__, __LINE__, ## __VA_ARGS__); \\\r\n          } \\\r\n        } while (false)",
                  "implementation": "#define XUSL_TRACEPOINT(MsgLevel, Message, ...) \\\r\n        do { \\\r\n          if (SIL_DEBUG_ENABLE) { \\\r\n            ((HOST_DEBUG_SERVICE)SilTracePoint) (MsgLevel, \"SIL:xUSL:\", \\\r\n            Message, __FUNCTION__, __LINE__, ## __VA_ARGS__); \\\r\n          } \\\r\n        } while (false)",
                  "range": [
                    { "line": 136, "character": 0 },
                    { "line": 142, "character": 23 }
                  ],
                  "selectionRange": [
                    { "line": 136, "character": 8 },
                    { "line": 136, "character": 23 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_ENTRY",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_ENTRY   BIT_32(2)   ///< Messages showing entry flow",
                  "implementation": "#define SIL_TRACE_ENTRY   BIT_32(2)   ///< Messages showing entry flow",
                  "range": [
                    { "line": 102, "character": 0 },
                    { "line": 102, "character": 70 }
                  ],
                  "selectionRange": [
                    { "line": 102, "character": 8 },
                    { "line": 102, "character": 23 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_INFO",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                  "implementation": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                  "range": [
                    { "line": 104, "character": 0 },
                    { "line": 104, "character": 118 }
                  ],
                  "selectionRange": [
                    { "line": 104, "character": 8 },
                    { "line": 104, "character": 22 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_EXIT",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_EXIT    BIT_32(3)   ///< Messages showing exit flow",
                  "implementation": "#define SIL_TRACE_EXIT    BIT_32(3)   ///< Messages showing exit flow",
                  "range": [
                    { "line": 103, "character": 0 },
                    { "line": 103, "character": 69 }
                  ],
                  "selectionRange": [
                    { "line": 103, "character": 8 },
                    { "line": 103, "character": 22 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "__disable_tail_calls",
                  "kind": 12,
                  "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                  "documentation": "",
                  "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                  "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                  "range": [
                    { "line": 59, "character": 0 },
                    { "line": 59, "character": 101 }
                  ],
                  "selectionRange": [
                    { "line": 59, "character": 80 },
                    { "line": 59, "character": 100 }
                  ],
                  "dependencies": { "callTree": [] }
                }
              ]
            }
          },
          {
            "name": "SilInitIp2IpApi",
            "kind": 11,
            "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/CommonLib/SilServices.c",
            "documentation": "/**\n * SilInitIp2IpApi\n *\n * @brief   Register an Ip-2-Ip API for IpId to the API table.\n *\n * @param   SilContext   A context structure through which host firmware defined data\n *                       can be passed to openSIL. The host firmware is responsible\n *                       for initializing the SIL_CONTEXT structure.\n * @param   IpId         The ID of the IP providing the API.\n * @param   Api          Input of the Ip-2-Ip API table to initialize.\n *\n * @retval  SilPass             The Ip-2-Ip API was initialized for IpId.\n * @retval  SilInvalidParameter The Ip ID was outside the bounds of valid IDs defined by SIL_DATA_BLOCK_ID.\n *\n */",
            "definition": "SIL_STATUS\r\nSilInitIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                *IpApi\r\n  )",
            "implementation": "SIL_STATUS\r\nSilInitIp2IpApi (\r\n  SIL_CONTEXT         *SilContext,\r\n  SIL_DATA_BLOCK_ID   IpId,\r\n  void                *IpApi\r\n  )\r\n{\r\n  SIL_BLOCK_VARIABLES *SilVars;\r\n\r\n  XUSL_TRACEPOINT(SIL_TRACE_ENTRY, \"\\n\");\r\n\r\n  assert(IpId < SilId_ListEnd);\r\n  if (IpId >= SilId_ListEnd) {\r\n    return SilInvalidParameter;\r\n  }\r\n\r\n  SilVars = (SIL_BLOCK_VARIABLES *)(uintptr_t)SilContext->SilMemBaseAddress;\r\n\r\n  /*\r\n   * The API table (Ip2IpApi) is a member of the SIL_BLOCK_VARIABLES struct.\r\n   */\r\n  XUSL_TRACEPOINT(SIL_TRACE_INFO, \"Initializing Ip-2-Ip API for IP ID = %d\\n\", IpId);\r\n  SilVars->Ip2IpApi[IpId] = (uintptr_t)IpApi;\r\n\r\n  XUSL_TRACEPOINT(SIL_TRACE_EXIT, \"\\n\");\r\n  return SilPass;\r\n}",
            "range": [
              { "line": 144, "character": 0 },
              { "line": 170, "character": 1 }
            ],
            "selectionRange": [
              { "line": 145, "character": 0 },
              { "line": 145, "character": 15 }
            ],
            "dependencies": {
              "callTree": [
                {
                  "name": "SIL_STATUS",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/Sil-api.h",
                  "documentation": "/** @brief Return values\n *\n * @details The openSIL routines will never 'hang'. They will always return with a\n * code or value indicating the state of the outcome of the operation. For\n * functions returning status, these are the defined status codes for\n * all openSIL code.\n * Starting from value 0xF0, this enum defines reset request types from openSIL IPs.\n */",
                  "definition": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "implementation": "typedef enum {\r\n  SilPass = 0,                    ///< Success, function finished without error.\r\n  SilUnsupportedHardware,         ///< Fail, SoC does not support the function.\r\n  SilUnsupported,                 ///< Fail, the request is not supported.\r\n  SilInvalidParameter,            ///< Fail, the function was called with an\r\n                                  ///<   invalid parameter.\r\n  SilAborted,                     ///< Fail, the processing incurred an error\r\n                                  ///<   causing the processing to be aborted.\r\n                                  ///<   Host should take action.\r\n  SilOutOfResources,              ///< Fail, assignment of memory block failed,\r\n                                  ///<   due to depletion of available resources\r\n  SilNotFound,                    ///< Fail, The element was not found. Recheck\r\n                                  ///<   the ID unique identifier used.\r\n  SilOutOfBounds,                 ///< Fail, there is an out of bounds condition\r\n  SilDeviceError,                 ///< Fail, device being initialized reported\r\n                                  ///<   an error. Check if the IP output block\r\n                                  ///<   has more information.\r\n\r\n  SilResetRequestColdImm = 0xF0,  ///< The following values indicate a special\r\n                                  ///<   condition requiring the Host to perform\r\n                                  ///<   a system reset\r\n                                  ///< requesting Host do immediate cold reset\r\n  SilResetRequestColdDef,         ///< requesting Host do deferred cold reset\r\n  SilResetRequestWarmImm,         ///< requesting Host do immediate warm reset\r\n  SilResetRequestWarmDef,         ///< requesting Host do deferred warm reset\r\n} SIL_STATUS;",
                  "range": [
                    { "line": 49, "character": 0 },
                    { "line": 74, "character": 13 }
                  ],
                  "selectionRange": [
                    { "line": 74, "character": 2 },
                    { "line": 74, "character": 12 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_CONTEXT",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/**\n * @brief   SIL_CONTEXT\n *\n * @details A context structure through which host firmware defined data\n *          can be passed to openSIL. The host firmware is responsible for\n *          initializing the SIL_CONTEXT structure and providing it to openSIL APIs\n */",
                  "definition": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "implementation": "typedef struct {\r\n  uint32_t ApobBaseAddress;   ///< Address of the APOB Info stored\r\n  uint64_t SilMemBaseAddress; ///< The base address of the SIL memory block\r\n                              ///< provided by host firmware\r\n} SIL_CONTEXT;",
                  "range": [
                    { "line": 131, "character": 0 },
                    { "line": 135, "character": 14 }
                  ],
                  "selectionRange": [
                    { "line": 135, "character": 2 },
                    { "line": 135, "character": 13 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_DATA_BLOCK_ID",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/Include/xSIM-api.h",
                  "documentation": "/** @brief Data Block Identifiers\n *\n *  @details These are unique identifiers used by the xSIM and the Host\n *  sides to locate an IPblock Input or Output data structure. See @ref SilFindStructure.\n *  Each block type must have a unique identifier, so an IP  may have several\n *  block IDs defined for the sections of memory it uses (input, output, private)\n *  and each may have multiple instances. For example, a UART port may use one\n *  ID for 'UART Port' but have several instances, one per port.\n */",
                  "definition": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                  "implementation": "typedef enum {\r\n  SilId_SocCommon = 0,\r\n  SilId_DfClass,\r\n  SilId_CcxClass,\r\n  SilId_FchClass,\r\n  SilId_MultiFchClass,\r\n  SilId_FchHwAcpiP,\r\n  SilId_FchAb,\r\n  SilId_FchHwAcpi,\r\n  SilId_FchIsa,\r\n  SilId_FchEspi,\r\n  SilId_FchUsb,\r\n  SilId_MemClass,\r\n  SilId_MultiFch,\r\n  SilId_NbioClass,\r\n  SilId_XmpClass,\r\n  SilId_RcManager,\r\n  SilId_SmuClass,\r\n  SilId_MpioClass,\r\n  SilId_CxlClass,\r\n  SilId_RasClass,\r\n  SilId_ApobClass,\r\n  SilId_GfxClass,\r\n  // Add new elements above this line ^^^\r\n  SilId_ListEnd             ///< Value to bound the list\r\n} SIL_DATA_BLOCK_ID;",
                  "range": [
                    { "line": 48, "character": 0 },
                    { "line": 73, "character": 20 }
                  ],
                  "selectionRange": [
                    { "line": 73, "character": 2 },
                    { "line": 73, "character": 19 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_BLOCK_VARIABLES",
                  "kind": 10,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Block (private) variables for xSIM\n *\n *  These are variables held in the Host memory, dereferenced by\n *  the mSilMemoryBase global. Think of them as the input block\n *  for the SIL core.\n *\n */",
                  "definition": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                  "implementation": "typedef struct {\r\n  uint32_t                HostBlockSize;                      ///< Size of block allocated by the Host\r\n  uint32_t                FreeSpaceOffset;                    ///< Offset to next area of free space\r\n  uint32_t                FreeSpaceLeft;                      ///< tracking remaining free space\r\n  ACTIVE_SOC_DATA         ActiveSoC;                          ///< Descriptors for SoC in the socket\r\n  PLATFORM_DESC           PlatformData;                       ///< Descriptors for the platform\r\n  uint64_t                Ip2IpApi[SilId_ListEnd];            ///< IP to IP API table.  This table provides IP\r\n                                                              ///< abstraction between IPs.\r\n  uint64_t                Common2RevXferTable[SilId_ListEnd]; ///< IP Common to Rev specific transfer (Xfer) table.\r\n                                                              ///< This table provides abstraction IP version specific\r\n                                                              ///< code from common code.\r\n} SIL_BLOCK_VARIABLES;",
                  "range": [
                    { "line": 182, "character": 0 },
                    { "line": 193, "character": 22 }
                  ],
                  "selectionRange": [
                    { "line": 193, "character": 2 },
                    { "line": 193, "character": 21 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "XUSL_TRACEPOINT(MsgLevel, Message, __VA_ARGS__)",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "",
                  "definition": "#define XUSL_TRACEPOINT(MsgLevel, Message, ...) \\\r\n        do { \\\r\n          if (SIL_DEBUG_ENABLE) { \\\r\n            ((HOST_DEBUG_SERVICE)SilTracePoint) (MsgLevel, \"SIL:xUSL:\", \\\r\n            Message, __FUNCTION__, __LINE__, ## __VA_ARGS__); \\\r\n          } \\\r\n        } while (false)",
                  "implementation": "#define XUSL_TRACEPOINT(MsgLevel, Message, ...) \\\r\n        do { \\\r\n          if (SIL_DEBUG_ENABLE) { \\\r\n            ((HOST_DEBUG_SERVICE)SilTracePoint) (MsgLevel, \"SIL:xUSL:\", \\\r\n            Message, __FUNCTION__, __LINE__, ## __VA_ARGS__); \\\r\n          } \\\r\n        } while (false)",
                  "range": [
                    { "line": 136, "character": 0 },
                    { "line": 142, "character": 23 }
                  ],
                  "selectionRange": [
                    { "line": 136, "character": 8 },
                    { "line": 136, "character": 23 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_ENTRY",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_ENTRY   BIT_32(2)   ///< Messages showing entry flow",
                  "implementation": "#define SIL_TRACE_ENTRY   BIT_32(2)   ///< Messages showing entry flow",
                  "range": [
                    { "line": 102, "character": 0 },
                    { "line": 102, "character": 70 }
                  ],
                  "selectionRange": [
                    { "line": 102, "character": 8 },
                    { "line": 102, "character": 23 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_INFO",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                  "implementation": "#define SIL_TRACE_INFO    BIT_32(4)   ///< Discovery/Configuration information that is likely useful to any log reader",
                  "range": [
                    { "line": 104, "character": 0 },
                    { "line": 104, "character": 118 }
                  ],
                  "selectionRange": [
                    { "line": 104, "character": 8 },
                    { "line": 104, "character": 22 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "SIL_TRACE_EXIT",
                  "kind": 13,
                  "uri": "file:///Users/tieuma/Documents/amd/Seneca/AGESA/AmdOuiPkg/openSIL/xUSL/Include/SilCommon.h",
                  "documentation": "/** Message type enables\n * @name Group: Trace Enables\n * @anchor Trace_Enables\n * These values set the level or importance of then information being passed\n * in the message. The most critical/important are lower in value.\n * @{\n */",
                  "definition": "#define SIL_TRACE_EXIT    BIT_32(3)   ///< Messages showing exit flow",
                  "implementation": "#define SIL_TRACE_EXIT    BIT_32(3)   ///< Messages showing exit flow",
                  "range": [
                    { "line": 103, "character": 0 },
                    { "line": 103, "character": 69 }
                  ],
                  "selectionRange": [
                    { "line": 103, "character": 8 },
                    { "line": 103, "character": 22 }
                  ],
                  "dependencies": { "callTree": [] }
                },
                {
                  "name": "__disable_tail_calls",
                  "kind": 12,
                  "uri": "file:///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_assert.h",
                  "documentation": "",
                  "definition": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                  "implementation": "void __assert_rtn(const char *, const char *, int, const char *) __dead2 __cold __disable_tail_calls;",
                  "range": [
                    { "line": 59, "character": 0 },
                    { "line": 59, "character": 101 }
                  ],
                  "selectionRange": [
                    { "line": 59, "character": 80 },
                    { "line": 59, "character": 100 }
                  ],
                  "dependencies": { "callTree": [] }
                }
              ]
            }
          }
        ]
      }
    }
  ]
}
